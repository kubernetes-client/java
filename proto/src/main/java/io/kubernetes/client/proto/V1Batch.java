// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/batch/v1/generated.proto

package io.kubernetes.client.proto;

public final class V1Batch {
  private V1Batch() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface CronJobOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.CronJob)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of a cron job, including the schedule.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of a cron job, including the schedule.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.CronJobSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of a cron job, including the schedule.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * Current status of a cron job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * Current status of a cron job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Batch.CronJobStatus getStatus();
    /**
     * <pre>
     * Current status of a cron job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * CronJob represents the configuration of a single cron job.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.CronJob}
   */
  public  static final class CronJob extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.CronJob)
      CronJobOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CronJob.newBuilder() to construct.
    private CronJob(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CronJob() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CronJob(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1Batch.CronJobSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = status_.toBuilder();
              }
              status_ = input.readMessage(io.kubernetes.client.proto.V1Batch.CronJobStatus.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(status_);
                status_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJob_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJob_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.CronJob.class, io.kubernetes.client.proto.V1Batch.CronJob.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Batch.CronJobSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of a cron job, including the schedule.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of a cron job, including the schedule.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.CronJobSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of a cron job, including the schedule.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Batch.CronJobStatus status_;
    /**
     * <pre>
     * Current status of a cron job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Current status of a cron job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Batch.CronJobStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * Current status of a cron job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.CronJob)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.CronJob other = (io.kubernetes.client.proto.V1Batch.CronJob) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJob parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.CronJob prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CronJob represents the configuration of a single cron job.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.CronJob}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.CronJob)
        io.kubernetes.client.proto.V1Batch.CronJobOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJob_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJob_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.CronJob.class, io.kubernetes.client.proto.V1Batch.CronJob.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.CronJob.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJob_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJob getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.CronJob.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJob build() {
        io.kubernetes.client.proto.V1Batch.CronJob result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJob buildPartial() {
        io.kubernetes.client.proto.V1Batch.CronJob result = new io.kubernetes.client.proto.V1Batch.CronJob(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.CronJob) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.CronJob)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.CronJob other) {
        if (other == io.kubernetes.client.proto.V1Batch.CronJob.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.CronJob parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.CronJob) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Batch.CronJobSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.CronJobSpec, io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder, io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Batch.CronJobSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Batch.CronJobSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1Batch.CronJobSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of a cron job, including the schedule.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.CronJobSpec, io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder, io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.CronJobSpec, io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder, io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Batch.CronJobStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.CronJobStatus, io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder, io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Batch.CronJobStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Batch.CronJobStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              status_ != null &&
              status_ != io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance()) {
            status_ =
              io.kubernetes.client.proto.V1Batch.CronJobStatus.newBuilder(status_).mergeFrom(value).buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * Current status of a cron job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.CronJobStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.CronJobStatus, io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder, io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.CronJobStatus, io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder, io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.CronJob)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.CronJob)
    private static final io.kubernetes.client.proto.V1Batch.CronJob DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.CronJob();
    }

    public static io.kubernetes.client.proto.V1Batch.CronJob getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CronJob>
        PARSER = new com.google.protobuf.AbstractParser<CronJob>() {
      @java.lang.Override
      public CronJob parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CronJob(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CronJob> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CronJob> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.CronJob getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CronJobListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.CronJobList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Batch.CronJob> 
        getItemsList();
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.CronJob getItems(int index);
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Batch.CronJobOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.CronJobOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * CronJobList is a collection of cron jobs.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.CronJobList}
   */
  public  static final class CronJobList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.CronJobList)
      CronJobListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CronJobList.newBuilder() to construct.
    private CronJobList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CronJobList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CronJobList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.CronJob>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Batch.CronJob.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.CronJobList.class, io.kubernetes.client.proto.V1Batch.CronJobList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Batch.CronJob> items_;
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Batch.CronJob> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Batch.CronJobOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.CronJob getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of CronJobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.CronJobOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.CronJobList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.CronJobList other = (io.kubernetes.client.proto.V1Batch.CronJobList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.CronJobList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CronJobList is a collection of cron jobs.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.CronJobList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.CronJobList)
        io.kubernetes.client.proto.V1Batch.CronJobListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.CronJobList.class, io.kubernetes.client.proto.V1Batch.CronJobList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.CronJobList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.CronJobList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobList build() {
        io.kubernetes.client.proto.V1Batch.CronJobList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobList buildPartial() {
        io.kubernetes.client.proto.V1Batch.CronJobList result = new io.kubernetes.client.proto.V1Batch.CronJobList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.CronJobList) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.CronJobList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.CronJobList other) {
        if (other == io.kubernetes.client.proto.V1Batch.CronJobList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.CronJobList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.CronJobList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Batch.CronJob> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.CronJob>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.CronJob, io.kubernetes.client.proto.V1Batch.CronJob.Builder, io.kubernetes.client.proto.V1Batch.CronJobOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.CronJob> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJob getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Batch.CronJob value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Batch.CronJob.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Batch.CronJob value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Batch.CronJob value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Batch.CronJob.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Batch.CronJob.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Batch.CronJob> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJob.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJobOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Batch.CronJobOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJob.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Batch.CronJob.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.CronJob.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Batch.CronJob.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of CronJobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.CronJob items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.CronJob.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.CronJob, io.kubernetes.client.proto.V1Batch.CronJob.Builder, io.kubernetes.client.proto.V1Batch.CronJobOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.CronJob, io.kubernetes.client.proto.V1Batch.CronJob.Builder, io.kubernetes.client.proto.V1Batch.CronJobOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.CronJobList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.CronJobList)
    private static final io.kubernetes.client.proto.V1Batch.CronJobList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.CronJobList();
    }

    public static io.kubernetes.client.proto.V1Batch.CronJobList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CronJobList>
        PARSER = new com.google.protobuf.AbstractParser<CronJobList>() {
      @java.lang.Override
      public CronJobList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CronJobList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CronJobList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CronJobList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.CronJobList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CronJobSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.CronJobSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
     * +required
     * +k8s:required
     * </pre>
     *
     * <code>optional string schedule = 1;</code>
     */
    boolean hasSchedule();
    /**
     * <pre>
     * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
     * +required
     * +k8s:required
     * </pre>
     *
     * <code>optional string schedule = 1;</code>
     */
    java.lang.String getSchedule();
    /**
     * <pre>
     * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
     * +required
     * +k8s:required
     * </pre>
     *
     * <code>optional string schedule = 1;</code>
     */
    com.google.protobuf.ByteString
        getScheduleBytes();

    /**
     * <pre>
     * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
     * If not specified, this will default to the time zone of the kube-controller-manager process.
     * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
     * database by the API server during CronJob validation and the controller manager during execution.
     * If no system-wide time zone database can be found a bundled version of the database is used instead.
     * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
     * configuration, the controller will stop creating new new Jobs and will create a system event with the
     * reason UnknownTimeZone.
     * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
     * +optional
     * </pre>
     *
     * <code>optional string timeZone = 8;</code>
     */
    boolean hasTimeZone();
    /**
     * <pre>
     * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
     * If not specified, this will default to the time zone of the kube-controller-manager process.
     * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
     * database by the API server during CronJob validation and the controller manager during execution.
     * If no system-wide time zone database can be found a bundled version of the database is used instead.
     * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
     * configuration, the controller will stop creating new new Jobs and will create a system event with the
     * reason UnknownTimeZone.
     * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
     * +optional
     * </pre>
     *
     * <code>optional string timeZone = 8;</code>
     */
    java.lang.String getTimeZone();
    /**
     * <pre>
     * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
     * If not specified, this will default to the time zone of the kube-controller-manager process.
     * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
     * database by the API server during CronJob validation and the controller manager during execution.
     * If no system-wide time zone database can be found a bundled version of the database is used instead.
     * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
     * configuration, the controller will stop creating new new Jobs and will create a system event with the
     * reason UnknownTimeZone.
     * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
     * +optional
     * </pre>
     *
     * <code>optional string timeZone = 8;</code>
     */
    com.google.protobuf.ByteString
        getTimeZoneBytes();

    /**
     * <pre>
     * Optional deadline in seconds for starting the job if it misses scheduled
     * time for any reason.  Missed jobs executions will be counted as failed ones.
     * +optional
     * </pre>
     *
     * <code>optional int64 startingDeadlineSeconds = 2;</code>
     */
    boolean hasStartingDeadlineSeconds();
    /**
     * <pre>
     * Optional deadline in seconds for starting the job if it misses scheduled
     * time for any reason.  Missed jobs executions will be counted as failed ones.
     * +optional
     * </pre>
     *
     * <code>optional int64 startingDeadlineSeconds = 2;</code>
     */
    long getStartingDeadlineSeconds();

    /**
     * <pre>
     * Specifies how to treat concurrent executions of a Job.
     * Valid values are:
     * - "Allow" (default): allows CronJobs to run concurrently;
     * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
     * - "Replace": cancels currently running job and replaces it with a new one
     * +optional
     * </pre>
     *
     * <code>optional string concurrencyPolicy = 3;</code>
     */
    boolean hasConcurrencyPolicy();
    /**
     * <pre>
     * Specifies how to treat concurrent executions of a Job.
     * Valid values are:
     * - "Allow" (default): allows CronJobs to run concurrently;
     * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
     * - "Replace": cancels currently running job and replaces it with a new one
     * +optional
     * </pre>
     *
     * <code>optional string concurrencyPolicy = 3;</code>
     */
    java.lang.String getConcurrencyPolicy();
    /**
     * <pre>
     * Specifies how to treat concurrent executions of a Job.
     * Valid values are:
     * - "Allow" (default): allows CronJobs to run concurrently;
     * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
     * - "Replace": cancels currently running job and replaces it with a new one
     * +optional
     * </pre>
     *
     * <code>optional string concurrencyPolicy = 3;</code>
     */
    com.google.protobuf.ByteString
        getConcurrencyPolicyBytes();

    /**
     * <pre>
     * This flag tells the controller to suspend subsequent executions, it does
     * not apply to already started executions.  Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 4;</code>
     */
    boolean hasSuspend();
    /**
     * <pre>
     * This flag tells the controller to suspend subsequent executions, it does
     * not apply to already started executions.  Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 4;</code>
     */
    boolean getSuspend();

    /**
     * <pre>
     * Specifies the job that will be created when executing a CronJob.
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
     */
    boolean hasJobTemplate();
    /**
     * <pre>
     * Specifies the job that will be created when executing a CronJob.
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobTemplateSpec getJobTemplate();
    /**
     * <pre>
     * Specifies the job that will be created when executing a CronJob.
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder getJobTemplateOrBuilder();

    /**
     * <pre>
     * The number of successful finished jobs to retain. Value must be non-negative integer.
     * Defaults to 3.
     * +optional
     * </pre>
     *
     * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
     */
    boolean hasSuccessfulJobsHistoryLimit();
    /**
     * <pre>
     * The number of successful finished jobs to retain. Value must be non-negative integer.
     * Defaults to 3.
     * +optional
     * </pre>
     *
     * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
     */
    int getSuccessfulJobsHistoryLimit();

    /**
     * <pre>
     * The number of failed finished jobs to retain. Value must be non-negative integer.
     * Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 failedJobsHistoryLimit = 7;</code>
     */
    boolean hasFailedJobsHistoryLimit();
    /**
     * <pre>
     * The number of failed finished jobs to retain. Value must be non-negative integer.
     * Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 failedJobsHistoryLimit = 7;</code>
     */
    int getFailedJobsHistoryLimit();
  }
  /**
   * <pre>
   * CronJobSpec describes how the job execution will look like and when it will actually run.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.CronJobSpec}
   */
  public  static final class CronJobSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.CronJobSpec)
      CronJobSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CronJobSpec.newBuilder() to construct.
    private CronJobSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CronJobSpec() {
      schedule_ = "";
      timeZone_ = "";
      startingDeadlineSeconds_ = 0L;
      concurrencyPolicy_ = "";
      suspend_ = false;
      successfulJobsHistoryLimit_ = 0;
      failedJobsHistoryLimit_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CronJobSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              schedule_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000004;
              startingDeadlineSeconds_ = input.readInt64();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              concurrencyPolicy_ = bs;
              break;
            }
            case 32: {
              bitField0_ |= 0x00000010;
              suspend_ = input.readBool();
              break;
            }
            case 42: {
              io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = jobTemplate_.toBuilder();
              }
              jobTemplate_ = input.readMessage(io.kubernetes.client.proto.V1Batch.JobTemplateSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(jobTemplate_);
                jobTemplate_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 48: {
              bitField0_ |= 0x00000040;
              successfulJobsHistoryLimit_ = input.readInt32();
              break;
            }
            case 56: {
              bitField0_ |= 0x00000080;
              failedJobsHistoryLimit_ = input.readInt32();
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              timeZone_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.CronJobSpec.class, io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder.class);
    }

    private int bitField0_;
    public static final int SCHEDULE_FIELD_NUMBER = 1;
    private volatile java.lang.Object schedule_;
    /**
     * <pre>
     * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
     * +required
     * +k8s:required
     * </pre>
     *
     * <code>optional string schedule = 1;</code>
     */
    public boolean hasSchedule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
     * +required
     * +k8s:required
     * </pre>
     *
     * <code>optional string schedule = 1;</code>
     */
    public java.lang.String getSchedule() {
      java.lang.Object ref = schedule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          schedule_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
     * +required
     * +k8s:required
     * </pre>
     *
     * <code>optional string schedule = 1;</code>
     */
    public com.google.protobuf.ByteString
        getScheduleBytes() {
      java.lang.Object ref = schedule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        schedule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEZONE_FIELD_NUMBER = 8;
    private volatile java.lang.Object timeZone_;
    /**
     * <pre>
     * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
     * If not specified, this will default to the time zone of the kube-controller-manager process.
     * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
     * database by the API server during CronJob validation and the controller manager during execution.
     * If no system-wide time zone database can be found a bundled version of the database is used instead.
     * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
     * configuration, the controller will stop creating new new Jobs and will create a system event with the
     * reason UnknownTimeZone.
     * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
     * +optional
     * </pre>
     *
     * <code>optional string timeZone = 8;</code>
     */
    public boolean hasTimeZone() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
     * If not specified, this will default to the time zone of the kube-controller-manager process.
     * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
     * database by the API server during CronJob validation and the controller manager during execution.
     * If no system-wide time zone database can be found a bundled version of the database is used instead.
     * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
     * configuration, the controller will stop creating new new Jobs and will create a system event with the
     * reason UnknownTimeZone.
     * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
     * +optional
     * </pre>
     *
     * <code>optional string timeZone = 8;</code>
     */
    public java.lang.String getTimeZone() {
      java.lang.Object ref = timeZone_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          timeZone_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
     * If not specified, this will default to the time zone of the kube-controller-manager process.
     * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
     * database by the API server during CronJob validation and the controller manager during execution.
     * If no system-wide time zone database can be found a bundled version of the database is used instead.
     * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
     * configuration, the controller will stop creating new new Jobs and will create a system event with the
     * reason UnknownTimeZone.
     * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
     * +optional
     * </pre>
     *
     * <code>optional string timeZone = 8;</code>
     */
    public com.google.protobuf.ByteString
        getTimeZoneBytes() {
      java.lang.Object ref = timeZone_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        timeZone_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STARTINGDEADLINESECONDS_FIELD_NUMBER = 2;
    private long startingDeadlineSeconds_;
    /**
     * <pre>
     * Optional deadline in seconds for starting the job if it misses scheduled
     * time for any reason.  Missed jobs executions will be counted as failed ones.
     * +optional
     * </pre>
     *
     * <code>optional int64 startingDeadlineSeconds = 2;</code>
     */
    public boolean hasStartingDeadlineSeconds() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Optional deadline in seconds for starting the job if it misses scheduled
     * time for any reason.  Missed jobs executions will be counted as failed ones.
     * +optional
     * </pre>
     *
     * <code>optional int64 startingDeadlineSeconds = 2;</code>
     */
    public long getStartingDeadlineSeconds() {
      return startingDeadlineSeconds_;
    }

    public static final int CONCURRENCYPOLICY_FIELD_NUMBER = 3;
    private volatile java.lang.Object concurrencyPolicy_;
    /**
     * <pre>
     * Specifies how to treat concurrent executions of a Job.
     * Valid values are:
     * - "Allow" (default): allows CronJobs to run concurrently;
     * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
     * - "Replace": cancels currently running job and replaces it with a new one
     * +optional
     * </pre>
     *
     * <code>optional string concurrencyPolicy = 3;</code>
     */
    public boolean hasConcurrencyPolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Specifies how to treat concurrent executions of a Job.
     * Valid values are:
     * - "Allow" (default): allows CronJobs to run concurrently;
     * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
     * - "Replace": cancels currently running job and replaces it with a new one
     * +optional
     * </pre>
     *
     * <code>optional string concurrencyPolicy = 3;</code>
     */
    public java.lang.String getConcurrencyPolicy() {
      java.lang.Object ref = concurrencyPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          concurrencyPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Specifies how to treat concurrent executions of a Job.
     * Valid values are:
     * - "Allow" (default): allows CronJobs to run concurrently;
     * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
     * - "Replace": cancels currently running job and replaces it with a new one
     * +optional
     * </pre>
     *
     * <code>optional string concurrencyPolicy = 3;</code>
     */
    public com.google.protobuf.ByteString
        getConcurrencyPolicyBytes() {
      java.lang.Object ref = concurrencyPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        concurrencyPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SUSPEND_FIELD_NUMBER = 4;
    private boolean suspend_;
    /**
     * <pre>
     * This flag tells the controller to suspend subsequent executions, it does
     * not apply to already started executions.  Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 4;</code>
     */
    public boolean hasSuspend() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * This flag tells the controller to suspend subsequent executions, it does
     * not apply to already started executions.  Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 4;</code>
     */
    public boolean getSuspend() {
      return suspend_;
    }

    public static final int JOBTEMPLATE_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.V1Batch.JobTemplateSpec jobTemplate_;
    /**
     * <pre>
     * Specifies the job that will be created when executing a CronJob.
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
     */
    public boolean hasJobTemplate() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Specifies the job that will be created when executing a CronJob.
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobTemplateSpec getJobTemplate() {
      return jobTemplate_ == null ? io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance() : jobTemplate_;
    }
    /**
     * <pre>
     * Specifies the job that will be created when executing a CronJob.
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder getJobTemplateOrBuilder() {
      return jobTemplate_ == null ? io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance() : jobTemplate_;
    }

    public static final int SUCCESSFULJOBSHISTORYLIMIT_FIELD_NUMBER = 6;
    private int successfulJobsHistoryLimit_;
    /**
     * <pre>
     * The number of successful finished jobs to retain. Value must be non-negative integer.
     * Defaults to 3.
     * +optional
     * </pre>
     *
     * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
     */
    public boolean hasSuccessfulJobsHistoryLimit() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * The number of successful finished jobs to retain. Value must be non-negative integer.
     * Defaults to 3.
     * +optional
     * </pre>
     *
     * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
     */
    public int getSuccessfulJobsHistoryLimit() {
      return successfulJobsHistoryLimit_;
    }

    public static final int FAILEDJOBSHISTORYLIMIT_FIELD_NUMBER = 7;
    private int failedJobsHistoryLimit_;
    /**
     * <pre>
     * The number of failed finished jobs to retain. Value must be non-negative integer.
     * Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 failedJobsHistoryLimit = 7;</code>
     */
    public boolean hasFailedJobsHistoryLimit() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * The number of failed finished jobs to retain. Value must be non-negative integer.
     * Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 failedJobsHistoryLimit = 7;</code>
     */
    public int getFailedJobsHistoryLimit() {
      return failedJobsHistoryLimit_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, schedule_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt64(2, startingDeadlineSeconds_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, concurrencyPolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBool(4, suspend_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(5, getJobTemplate());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(6, successfulJobsHistoryLimit_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(7, failedJobsHistoryLimit_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, timeZone_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, schedule_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, startingDeadlineSeconds_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, concurrencyPolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, suspend_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getJobTemplate());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, successfulJobsHistoryLimit_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, failedJobsHistoryLimit_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, timeZone_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.CronJobSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.CronJobSpec other = (io.kubernetes.client.proto.V1Batch.CronJobSpec) obj;

      boolean result = true;
      result = result && (hasSchedule() == other.hasSchedule());
      if (hasSchedule()) {
        result = result && getSchedule()
            .equals(other.getSchedule());
      }
      result = result && (hasTimeZone() == other.hasTimeZone());
      if (hasTimeZone()) {
        result = result && getTimeZone()
            .equals(other.getTimeZone());
      }
      result = result && (hasStartingDeadlineSeconds() == other.hasStartingDeadlineSeconds());
      if (hasStartingDeadlineSeconds()) {
        result = result && (getStartingDeadlineSeconds()
            == other.getStartingDeadlineSeconds());
      }
      result = result && (hasConcurrencyPolicy() == other.hasConcurrencyPolicy());
      if (hasConcurrencyPolicy()) {
        result = result && getConcurrencyPolicy()
            .equals(other.getConcurrencyPolicy());
      }
      result = result && (hasSuspend() == other.hasSuspend());
      if (hasSuspend()) {
        result = result && (getSuspend()
            == other.getSuspend());
      }
      result = result && (hasJobTemplate() == other.hasJobTemplate());
      if (hasJobTemplate()) {
        result = result && getJobTemplate()
            .equals(other.getJobTemplate());
      }
      result = result && (hasSuccessfulJobsHistoryLimit() == other.hasSuccessfulJobsHistoryLimit());
      if (hasSuccessfulJobsHistoryLimit()) {
        result = result && (getSuccessfulJobsHistoryLimit()
            == other.getSuccessfulJobsHistoryLimit());
      }
      result = result && (hasFailedJobsHistoryLimit() == other.hasFailedJobsHistoryLimit());
      if (hasFailedJobsHistoryLimit()) {
        result = result && (getFailedJobsHistoryLimit()
            == other.getFailedJobsHistoryLimit());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSchedule()) {
        hash = (37 * hash) + SCHEDULE_FIELD_NUMBER;
        hash = (53 * hash) + getSchedule().hashCode();
      }
      if (hasTimeZone()) {
        hash = (37 * hash) + TIMEZONE_FIELD_NUMBER;
        hash = (53 * hash) + getTimeZone().hashCode();
      }
      if (hasStartingDeadlineSeconds()) {
        hash = (37 * hash) + STARTINGDEADLINESECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartingDeadlineSeconds());
      }
      if (hasConcurrencyPolicy()) {
        hash = (37 * hash) + CONCURRENCYPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getConcurrencyPolicy().hashCode();
      }
      if (hasSuspend()) {
        hash = (37 * hash) + SUSPEND_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSuspend());
      }
      if (hasJobTemplate()) {
        hash = (37 * hash) + JOBTEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getJobTemplate().hashCode();
      }
      if (hasSuccessfulJobsHistoryLimit()) {
        hash = (37 * hash) + SUCCESSFULJOBSHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getSuccessfulJobsHistoryLimit();
      }
      if (hasFailedJobsHistoryLimit()) {
        hash = (37 * hash) + FAILEDJOBSHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getFailedJobsHistoryLimit();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.CronJobSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CronJobSpec describes how the job execution will look like and when it will actually run.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.CronJobSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.CronJobSpec)
        io.kubernetes.client.proto.V1Batch.CronJobSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.CronJobSpec.class, io.kubernetes.client.proto.V1Batch.CronJobSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.CronJobSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getJobTemplateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        schedule_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        timeZone_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        startingDeadlineSeconds_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000004);
        concurrencyPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        suspend_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (jobTemplateBuilder_ == null) {
          jobTemplate_ = null;
        } else {
          jobTemplateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        successfulJobsHistoryLimit_ = 0;
        bitField0_ = (bitField0_ & ~0x00000040);
        failedJobsHistoryLimit_ = 0;
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobSpec build() {
        io.kubernetes.client.proto.V1Batch.CronJobSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobSpec buildPartial() {
        io.kubernetes.client.proto.V1Batch.CronJobSpec result = new io.kubernetes.client.proto.V1Batch.CronJobSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.schedule_ = schedule_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.timeZone_ = timeZone_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.startingDeadlineSeconds_ = startingDeadlineSeconds_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.concurrencyPolicy_ = concurrencyPolicy_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.suspend_ = suspend_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        if (jobTemplateBuilder_ == null) {
          result.jobTemplate_ = jobTemplate_;
        } else {
          result.jobTemplate_ = jobTemplateBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.successfulJobsHistoryLimit_ = successfulJobsHistoryLimit_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.failedJobsHistoryLimit_ = failedJobsHistoryLimit_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.CronJobSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.CronJobSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.CronJobSpec other) {
        if (other == io.kubernetes.client.proto.V1Batch.CronJobSpec.getDefaultInstance()) return this;
        if (other.hasSchedule()) {
          bitField0_ |= 0x00000001;
          schedule_ = other.schedule_;
          onChanged();
        }
        if (other.hasTimeZone()) {
          bitField0_ |= 0x00000002;
          timeZone_ = other.timeZone_;
          onChanged();
        }
        if (other.hasStartingDeadlineSeconds()) {
          setStartingDeadlineSeconds(other.getStartingDeadlineSeconds());
        }
        if (other.hasConcurrencyPolicy()) {
          bitField0_ |= 0x00000008;
          concurrencyPolicy_ = other.concurrencyPolicy_;
          onChanged();
        }
        if (other.hasSuspend()) {
          setSuspend(other.getSuspend());
        }
        if (other.hasJobTemplate()) {
          mergeJobTemplate(other.getJobTemplate());
        }
        if (other.hasSuccessfulJobsHistoryLimit()) {
          setSuccessfulJobsHistoryLimit(other.getSuccessfulJobsHistoryLimit());
        }
        if (other.hasFailedJobsHistoryLimit()) {
          setFailedJobsHistoryLimit(other.getFailedJobsHistoryLimit());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.CronJobSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.CronJobSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object schedule_ = "";
      /**
       * <pre>
       * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
       * +required
       * +k8s:required
       * </pre>
       *
       * <code>optional string schedule = 1;</code>
       */
      public boolean hasSchedule() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
       * +required
       * +k8s:required
       * </pre>
       *
       * <code>optional string schedule = 1;</code>
       */
      public java.lang.String getSchedule() {
        java.lang.Object ref = schedule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            schedule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
       * +required
       * +k8s:required
       * </pre>
       *
       * <code>optional string schedule = 1;</code>
       */
      public com.google.protobuf.ByteString
          getScheduleBytes() {
        java.lang.Object ref = schedule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          schedule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
       * +required
       * +k8s:required
       * </pre>
       *
       * <code>optional string schedule = 1;</code>
       */
      public Builder setSchedule(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        schedule_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
       * +required
       * +k8s:required
       * </pre>
       *
       * <code>optional string schedule = 1;</code>
       */
      public Builder clearSchedule() {
        bitField0_ = (bitField0_ & ~0x00000001);
        schedule_ = getDefaultInstance().getSchedule();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
       * +required
       * +k8s:required
       * </pre>
       *
       * <code>optional string schedule = 1;</code>
       */
      public Builder setScheduleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        schedule_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object timeZone_ = "";
      /**
       * <pre>
       * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
       * If not specified, this will default to the time zone of the kube-controller-manager process.
       * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
       * database by the API server during CronJob validation and the controller manager during execution.
       * If no system-wide time zone database can be found a bundled version of the database is used instead.
       * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
       * configuration, the controller will stop creating new new Jobs and will create a system event with the
       * reason UnknownTimeZone.
       * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
       * +optional
       * </pre>
       *
       * <code>optional string timeZone = 8;</code>
       */
      public boolean hasTimeZone() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
       * If not specified, this will default to the time zone of the kube-controller-manager process.
       * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
       * database by the API server during CronJob validation and the controller manager during execution.
       * If no system-wide time zone database can be found a bundled version of the database is used instead.
       * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
       * configuration, the controller will stop creating new new Jobs and will create a system event with the
       * reason UnknownTimeZone.
       * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
       * +optional
       * </pre>
       *
       * <code>optional string timeZone = 8;</code>
       */
      public java.lang.String getTimeZone() {
        java.lang.Object ref = timeZone_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            timeZone_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
       * If not specified, this will default to the time zone of the kube-controller-manager process.
       * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
       * database by the API server during CronJob validation and the controller manager during execution.
       * If no system-wide time zone database can be found a bundled version of the database is used instead.
       * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
       * configuration, the controller will stop creating new new Jobs and will create a system event with the
       * reason UnknownTimeZone.
       * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
       * +optional
       * </pre>
       *
       * <code>optional string timeZone = 8;</code>
       */
      public com.google.protobuf.ByteString
          getTimeZoneBytes() {
        java.lang.Object ref = timeZone_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          timeZone_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
       * If not specified, this will default to the time zone of the kube-controller-manager process.
       * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
       * database by the API server during CronJob validation and the controller manager during execution.
       * If no system-wide time zone database can be found a bundled version of the database is used instead.
       * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
       * configuration, the controller will stop creating new new Jobs and will create a system event with the
       * reason UnknownTimeZone.
       * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
       * +optional
       * </pre>
       *
       * <code>optional string timeZone = 8;</code>
       */
      public Builder setTimeZone(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        timeZone_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
       * If not specified, this will default to the time zone of the kube-controller-manager process.
       * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
       * database by the API server during CronJob validation and the controller manager during execution.
       * If no system-wide time zone database can be found a bundled version of the database is used instead.
       * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
       * configuration, the controller will stop creating new new Jobs and will create a system event with the
       * reason UnknownTimeZone.
       * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
       * +optional
       * </pre>
       *
       * <code>optional string timeZone = 8;</code>
       */
      public Builder clearTimeZone() {
        bitField0_ = (bitField0_ & ~0x00000002);
        timeZone_ = getDefaultInstance().getTimeZone();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
       * If not specified, this will default to the time zone of the kube-controller-manager process.
       * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
       * database by the API server during CronJob validation and the controller manager during execution.
       * If no system-wide time zone database can be found a bundled version of the database is used instead.
       * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
       * configuration, the controller will stop creating new new Jobs and will create a system event with the
       * reason UnknownTimeZone.
       * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
       * +optional
       * </pre>
       *
       * <code>optional string timeZone = 8;</code>
       */
      public Builder setTimeZoneBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        timeZone_ = value;
        onChanged();
        return this;
      }

      private long startingDeadlineSeconds_ ;
      /**
       * <pre>
       * Optional deadline in seconds for starting the job if it misses scheduled
       * time for any reason.  Missed jobs executions will be counted as failed ones.
       * +optional
       * </pre>
       *
       * <code>optional int64 startingDeadlineSeconds = 2;</code>
       */
      public boolean hasStartingDeadlineSeconds() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Optional deadline in seconds for starting the job if it misses scheduled
       * time for any reason.  Missed jobs executions will be counted as failed ones.
       * +optional
       * </pre>
       *
       * <code>optional int64 startingDeadlineSeconds = 2;</code>
       */
      public long getStartingDeadlineSeconds() {
        return startingDeadlineSeconds_;
      }
      /**
       * <pre>
       * Optional deadline in seconds for starting the job if it misses scheduled
       * time for any reason.  Missed jobs executions will be counted as failed ones.
       * +optional
       * </pre>
       *
       * <code>optional int64 startingDeadlineSeconds = 2;</code>
       */
      public Builder setStartingDeadlineSeconds(long value) {
        bitField0_ |= 0x00000004;
        startingDeadlineSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional deadline in seconds for starting the job if it misses scheduled
       * time for any reason.  Missed jobs executions will be counted as failed ones.
       * +optional
       * </pre>
       *
       * <code>optional int64 startingDeadlineSeconds = 2;</code>
       */
      public Builder clearStartingDeadlineSeconds() {
        bitField0_ = (bitField0_ & ~0x00000004);
        startingDeadlineSeconds_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object concurrencyPolicy_ = "";
      /**
       * <pre>
       * Specifies how to treat concurrent executions of a Job.
       * Valid values are:
       * - "Allow" (default): allows CronJobs to run concurrently;
       * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
       * - "Replace": cancels currently running job and replaces it with a new one
       * +optional
       * </pre>
       *
       * <code>optional string concurrencyPolicy = 3;</code>
       */
      public boolean hasConcurrencyPolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * Specifies how to treat concurrent executions of a Job.
       * Valid values are:
       * - "Allow" (default): allows CronJobs to run concurrently;
       * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
       * - "Replace": cancels currently running job and replaces it with a new one
       * +optional
       * </pre>
       *
       * <code>optional string concurrencyPolicy = 3;</code>
       */
      public java.lang.String getConcurrencyPolicy() {
        java.lang.Object ref = concurrencyPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            concurrencyPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies how to treat concurrent executions of a Job.
       * Valid values are:
       * - "Allow" (default): allows CronJobs to run concurrently;
       * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
       * - "Replace": cancels currently running job and replaces it with a new one
       * +optional
       * </pre>
       *
       * <code>optional string concurrencyPolicy = 3;</code>
       */
      public com.google.protobuf.ByteString
          getConcurrencyPolicyBytes() {
        java.lang.Object ref = concurrencyPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          concurrencyPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies how to treat concurrent executions of a Job.
       * Valid values are:
       * - "Allow" (default): allows CronJobs to run concurrently;
       * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
       * - "Replace": cancels currently running job and replaces it with a new one
       * +optional
       * </pre>
       *
       * <code>optional string concurrencyPolicy = 3;</code>
       */
      public Builder setConcurrencyPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        concurrencyPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies how to treat concurrent executions of a Job.
       * Valid values are:
       * - "Allow" (default): allows CronJobs to run concurrently;
       * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
       * - "Replace": cancels currently running job and replaces it with a new one
       * +optional
       * </pre>
       *
       * <code>optional string concurrencyPolicy = 3;</code>
       */
      public Builder clearConcurrencyPolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        concurrencyPolicy_ = getDefaultInstance().getConcurrencyPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies how to treat concurrent executions of a Job.
       * Valid values are:
       * - "Allow" (default): allows CronJobs to run concurrently;
       * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
       * - "Replace": cancels currently running job and replaces it with a new one
       * +optional
       * </pre>
       *
       * <code>optional string concurrencyPolicy = 3;</code>
       */
      public Builder setConcurrencyPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        concurrencyPolicy_ = value;
        onChanged();
        return this;
      }

      private boolean suspend_ ;
      /**
       * <pre>
       * This flag tells the controller to suspend subsequent executions, it does
       * not apply to already started executions.  Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 4;</code>
       */
      public boolean hasSuspend() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * This flag tells the controller to suspend subsequent executions, it does
       * not apply to already started executions.  Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 4;</code>
       */
      public boolean getSuspend() {
        return suspend_;
      }
      /**
       * <pre>
       * This flag tells the controller to suspend subsequent executions, it does
       * not apply to already started executions.  Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 4;</code>
       */
      public Builder setSuspend(boolean value) {
        bitField0_ |= 0x00000010;
        suspend_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This flag tells the controller to suspend subsequent executions, it does
       * not apply to already started executions.  Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 4;</code>
       */
      public Builder clearSuspend() {
        bitField0_ = (bitField0_ & ~0x00000010);
        suspend_ = false;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Batch.JobTemplateSpec jobTemplate_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobTemplateSpec, io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder, io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder> jobTemplateBuilder_;
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public boolean hasJobTemplate() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobTemplateSpec getJobTemplate() {
        if (jobTemplateBuilder_ == null) {
          return jobTemplate_ == null ? io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance() : jobTemplate_;
        } else {
          return jobTemplateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public Builder setJobTemplate(io.kubernetes.client.proto.V1Batch.JobTemplateSpec value) {
        if (jobTemplateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          jobTemplate_ = value;
          onChanged();
        } else {
          jobTemplateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public Builder setJobTemplate(
          io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder builderForValue) {
        if (jobTemplateBuilder_ == null) {
          jobTemplate_ = builderForValue.build();
          onChanged();
        } else {
          jobTemplateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public Builder mergeJobTemplate(io.kubernetes.client.proto.V1Batch.JobTemplateSpec value) {
        if (jobTemplateBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020) &&
              jobTemplate_ != null &&
              jobTemplate_ != io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance()) {
            jobTemplate_ =
              io.kubernetes.client.proto.V1Batch.JobTemplateSpec.newBuilder(jobTemplate_).mergeFrom(value).buildPartial();
          } else {
            jobTemplate_ = value;
          }
          onChanged();
        } else {
          jobTemplateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public Builder clearJobTemplate() {
        if (jobTemplateBuilder_ == null) {
          jobTemplate_ = null;
          onChanged();
        } else {
          jobTemplateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder getJobTemplateBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getJobTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder getJobTemplateOrBuilder() {
        if (jobTemplateBuilder_ != null) {
          return jobTemplateBuilder_.getMessageOrBuilder();
        } else {
          return jobTemplate_ == null ?
              io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance() : jobTemplate_;
        }
      }
      /**
       * <pre>
       * Specifies the job that will be created when executing a CronJob.
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobTemplateSpec jobTemplate = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobTemplateSpec, io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder, io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder> 
          getJobTemplateFieldBuilder() {
        if (jobTemplateBuilder_ == null) {
          jobTemplateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.JobTemplateSpec, io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder, io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder>(
                  getJobTemplate(),
                  getParentForChildren(),
                  isClean());
          jobTemplate_ = null;
        }
        return jobTemplateBuilder_;
      }

      private int successfulJobsHistoryLimit_ ;
      /**
       * <pre>
       * The number of successful finished jobs to retain. Value must be non-negative integer.
       * Defaults to 3.
       * +optional
       * </pre>
       *
       * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
       */
      public boolean hasSuccessfulJobsHistoryLimit() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * The number of successful finished jobs to retain. Value must be non-negative integer.
       * Defaults to 3.
       * +optional
       * </pre>
       *
       * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
       */
      public int getSuccessfulJobsHistoryLimit() {
        return successfulJobsHistoryLimit_;
      }
      /**
       * <pre>
       * The number of successful finished jobs to retain. Value must be non-negative integer.
       * Defaults to 3.
       * +optional
       * </pre>
       *
       * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
       */
      public Builder setSuccessfulJobsHistoryLimit(int value) {
        bitField0_ |= 0x00000040;
        successfulJobsHistoryLimit_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of successful finished jobs to retain. Value must be non-negative integer.
       * Defaults to 3.
       * +optional
       * </pre>
       *
       * <code>optional int32 successfulJobsHistoryLimit = 6;</code>
       */
      public Builder clearSuccessfulJobsHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000040);
        successfulJobsHistoryLimit_ = 0;
        onChanged();
        return this;
      }

      private int failedJobsHistoryLimit_ ;
      /**
       * <pre>
       * The number of failed finished jobs to retain. Value must be non-negative integer.
       * Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 failedJobsHistoryLimit = 7;</code>
       */
      public boolean hasFailedJobsHistoryLimit() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * The number of failed finished jobs to retain. Value must be non-negative integer.
       * Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 failedJobsHistoryLimit = 7;</code>
       */
      public int getFailedJobsHistoryLimit() {
        return failedJobsHistoryLimit_;
      }
      /**
       * <pre>
       * The number of failed finished jobs to retain. Value must be non-negative integer.
       * Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 failedJobsHistoryLimit = 7;</code>
       */
      public Builder setFailedJobsHistoryLimit(int value) {
        bitField0_ |= 0x00000080;
        failedJobsHistoryLimit_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of failed finished jobs to retain. Value must be non-negative integer.
       * Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 failedJobsHistoryLimit = 7;</code>
       */
      public Builder clearFailedJobsHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000080);
        failedJobsHistoryLimit_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.CronJobSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.CronJobSpec)
    private static final io.kubernetes.client.proto.V1Batch.CronJobSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.CronJobSpec();
    }

    public static io.kubernetes.client.proto.V1Batch.CronJobSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CronJobSpec>
        PARSER = new com.google.protobuf.AbstractParser<CronJobSpec>() {
      @java.lang.Override
      public CronJobSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CronJobSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CronJobSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CronJobSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.CronJobSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CronJobStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.CronJobStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1.ObjectReference> 
        getActiveList();
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    io.kubernetes.client.proto.V1.ObjectReference getActive(int index);
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    int getActiveCount();
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder> 
        getActiveOrBuilderList();
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder getActiveOrBuilder(
        int index);

    /**
     * <pre>
     * Information when was the last time the job was successfully scheduled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
     */
    boolean hasLastScheduleTime();
    /**
     * <pre>
     * Information when was the last time the job was successfully scheduled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastScheduleTime();
    /**
     * <pre>
     * Information when was the last time the job was successfully scheduled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastScheduleTimeOrBuilder();

    /**
     * <pre>
     * Information when was the last time the job successfully completed.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
     */
    boolean hasLastSuccessfulTime();
    /**
     * <pre>
     * Information when was the last time the job successfully completed.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastSuccessfulTime();
    /**
     * <pre>
     * Information when was the last time the job successfully completed.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastSuccessfulTimeOrBuilder();
  }
  /**
   * <pre>
   * CronJobStatus represents the current state of a cron job.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.CronJobStatus}
   */
  public  static final class CronJobStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.CronJobStatus)
      CronJobStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CronJobStatus.newBuilder() to construct.
    private CronJobStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CronJobStatus() {
      active_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CronJobStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                active_ = new java.util.ArrayList<io.kubernetes.client.proto.V1.ObjectReference>();
                mutable_bitField0_ |= 0x00000001;
              }
              active_.add(
                  input.readMessage(io.kubernetes.client.proto.V1.ObjectReference.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = lastScheduleTime_.toBuilder();
              }
              lastScheduleTime_ = input.readMessage(io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(lastScheduleTime_);
                lastScheduleTime_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 42: {
              io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = lastSuccessfulTime_.toBuilder();
              }
              lastSuccessfulTime_ = input.readMessage(io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(lastSuccessfulTime_);
                lastSuccessfulTime_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          active_ = java.util.Collections.unmodifiableList(active_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.CronJobStatus.class, io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder.class);
    }

    private int bitField0_;
    public static final int ACTIVE_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1.ObjectReference> active_;
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1.ObjectReference> getActiveList() {
      return active_;
    }
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder> 
        getActiveOrBuilderList() {
      return active_;
    }
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    public int getActiveCount() {
      return active_.size();
    }
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    public io.kubernetes.client.proto.V1.ObjectReference getActive(int index) {
      return active_.get(index);
    }
    /**
     * <pre>
     * A list of pointers to currently running jobs.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
     */
    public io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder getActiveOrBuilder(
        int index) {
      return active_.get(index);
    }

    public static final int LASTSCHEDULETIME_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Meta.Time lastScheduleTime_;
    /**
     * <pre>
     * Information when was the last time the job was successfully scheduled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
     */
    public boolean hasLastScheduleTime() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Information when was the last time the job was successfully scheduled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastScheduleTime() {
      return lastScheduleTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastScheduleTime_;
    }
    /**
     * <pre>
     * Information when was the last time the job was successfully scheduled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastScheduleTimeOrBuilder() {
      return lastScheduleTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastScheduleTime_;
    }

    public static final int LASTSUCCESSFULTIME_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.Time lastSuccessfulTime_;
    /**
     * <pre>
     * Information when was the last time the job successfully completed.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
     */
    public boolean hasLastSuccessfulTime() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Information when was the last time the job successfully completed.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastSuccessfulTime() {
      return lastSuccessfulTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastSuccessfulTime_;
    }
    /**
     * <pre>
     * Information when was the last time the job successfully completed.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastSuccessfulTimeOrBuilder() {
      return lastSuccessfulTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastSuccessfulTime_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < active_.size(); i++) {
        output.writeMessage(1, active_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(4, getLastScheduleTime());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(5, getLastSuccessfulTime());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < active_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, active_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getLastScheduleTime());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getLastSuccessfulTime());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.CronJobStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.CronJobStatus other = (io.kubernetes.client.proto.V1Batch.CronJobStatus) obj;

      boolean result = true;
      result = result && getActiveList()
          .equals(other.getActiveList());
      result = result && (hasLastScheduleTime() == other.hasLastScheduleTime());
      if (hasLastScheduleTime()) {
        result = result && getLastScheduleTime()
            .equals(other.getLastScheduleTime());
      }
      result = result && (hasLastSuccessfulTime() == other.hasLastSuccessfulTime());
      if (hasLastSuccessfulTime()) {
        result = result && getLastSuccessfulTime()
            .equals(other.getLastSuccessfulTime());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getActiveCount() > 0) {
        hash = (37 * hash) + ACTIVE_FIELD_NUMBER;
        hash = (53 * hash) + getActiveList().hashCode();
      }
      if (hasLastScheduleTime()) {
        hash = (37 * hash) + LASTSCHEDULETIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastScheduleTime().hashCode();
      }
      if (hasLastSuccessfulTime()) {
        hash = (37 * hash) + LASTSUCCESSFULTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastSuccessfulTime().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.CronJobStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.CronJobStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CronJobStatus represents the current state of a cron job.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.CronJobStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.CronJobStatus)
        io.kubernetes.client.proto.V1Batch.CronJobStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.CronJobStatus.class, io.kubernetes.client.proto.V1Batch.CronJobStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.CronJobStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getActiveFieldBuilder();
          getLastScheduleTimeFieldBuilder();
          getLastSuccessfulTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (activeBuilder_ == null) {
          active_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          activeBuilder_.clear();
        }
        if (lastScheduleTimeBuilder_ == null) {
          lastScheduleTime_ = null;
        } else {
          lastScheduleTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (lastSuccessfulTimeBuilder_ == null) {
          lastSuccessfulTime_ = null;
        } else {
          lastSuccessfulTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_CronJobStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobStatus build() {
        io.kubernetes.client.proto.V1Batch.CronJobStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.CronJobStatus buildPartial() {
        io.kubernetes.client.proto.V1Batch.CronJobStatus result = new io.kubernetes.client.proto.V1Batch.CronJobStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (activeBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            active_ = java.util.Collections.unmodifiableList(active_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.active_ = active_;
        } else {
          result.active_ = activeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        if (lastScheduleTimeBuilder_ == null) {
          result.lastScheduleTime_ = lastScheduleTime_;
        } else {
          result.lastScheduleTime_ = lastScheduleTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000002;
        }
        if (lastSuccessfulTimeBuilder_ == null) {
          result.lastSuccessfulTime_ = lastSuccessfulTime_;
        } else {
          result.lastSuccessfulTime_ = lastSuccessfulTimeBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.CronJobStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.CronJobStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.CronJobStatus other) {
        if (other == io.kubernetes.client.proto.V1Batch.CronJobStatus.getDefaultInstance()) return this;
        if (activeBuilder_ == null) {
          if (!other.active_.isEmpty()) {
            if (active_.isEmpty()) {
              active_ = other.active_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureActiveIsMutable();
              active_.addAll(other.active_);
            }
            onChanged();
          }
        } else {
          if (!other.active_.isEmpty()) {
            if (activeBuilder_.isEmpty()) {
              activeBuilder_.dispose();
              activeBuilder_ = null;
              active_ = other.active_;
              bitField0_ = (bitField0_ & ~0x00000001);
              activeBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getActiveFieldBuilder() : null;
            } else {
              activeBuilder_.addAllMessages(other.active_);
            }
          }
        }
        if (other.hasLastScheduleTime()) {
          mergeLastScheduleTime(other.getLastScheduleTime());
        }
        if (other.hasLastSuccessfulTime()) {
          mergeLastSuccessfulTime(other.getLastSuccessfulTime());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.CronJobStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.CronJobStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1.ObjectReference> active_ =
        java.util.Collections.emptyList();
      private void ensureActiveIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          active_ = new java.util.ArrayList<io.kubernetes.client.proto.V1.ObjectReference>(active_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1.ObjectReference, io.kubernetes.client.proto.V1.ObjectReference.Builder, io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder> activeBuilder_;

      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1.ObjectReference> getActiveList() {
        if (activeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(active_);
        } else {
          return activeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public int getActiveCount() {
        if (activeBuilder_ == null) {
          return active_.size();
        } else {
          return activeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public io.kubernetes.client.proto.V1.ObjectReference getActive(int index) {
        if (activeBuilder_ == null) {
          return active_.get(index);
        } else {
          return activeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder setActive(
          int index, io.kubernetes.client.proto.V1.ObjectReference value) {
        if (activeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureActiveIsMutable();
          active_.set(index, value);
          onChanged();
        } else {
          activeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder setActive(
          int index, io.kubernetes.client.proto.V1.ObjectReference.Builder builderForValue) {
        if (activeBuilder_ == null) {
          ensureActiveIsMutable();
          active_.set(index, builderForValue.build());
          onChanged();
        } else {
          activeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder addActive(io.kubernetes.client.proto.V1.ObjectReference value) {
        if (activeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureActiveIsMutable();
          active_.add(value);
          onChanged();
        } else {
          activeBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder addActive(
          int index, io.kubernetes.client.proto.V1.ObjectReference value) {
        if (activeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureActiveIsMutable();
          active_.add(index, value);
          onChanged();
        } else {
          activeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder addActive(
          io.kubernetes.client.proto.V1.ObjectReference.Builder builderForValue) {
        if (activeBuilder_ == null) {
          ensureActiveIsMutable();
          active_.add(builderForValue.build());
          onChanged();
        } else {
          activeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder addActive(
          int index, io.kubernetes.client.proto.V1.ObjectReference.Builder builderForValue) {
        if (activeBuilder_ == null) {
          ensureActiveIsMutable();
          active_.add(index, builderForValue.build());
          onChanged();
        } else {
          activeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder addAllActive(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1.ObjectReference> values) {
        if (activeBuilder_ == null) {
          ensureActiveIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, active_);
          onChanged();
        } else {
          activeBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder clearActive() {
        if (activeBuilder_ == null) {
          active_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          activeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public Builder removeActive(int index) {
        if (activeBuilder_ == null) {
          ensureActiveIsMutable();
          active_.remove(index);
          onChanged();
        } else {
          activeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public io.kubernetes.client.proto.V1.ObjectReference.Builder getActiveBuilder(
          int index) {
        return getActiveFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder getActiveOrBuilder(
          int index) {
        if (activeBuilder_ == null) {
          return active_.get(index);  } else {
          return activeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder> 
           getActiveOrBuilderList() {
        if (activeBuilder_ != null) {
          return activeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(active_);
        }
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public io.kubernetes.client.proto.V1.ObjectReference.Builder addActiveBuilder() {
        return getActiveFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1.ObjectReference.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public io.kubernetes.client.proto.V1.ObjectReference.Builder addActiveBuilder(
          int index) {
        return getActiveFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1.ObjectReference.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of pointers to currently running jobs.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.core.v1.ObjectReference active = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1.ObjectReference.Builder> 
           getActiveBuilderList() {
        return getActiveFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1.ObjectReference, io.kubernetes.client.proto.V1.ObjectReference.Builder, io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder> 
          getActiveFieldBuilder() {
        if (activeBuilder_ == null) {
          activeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1.ObjectReference, io.kubernetes.client.proto.V1.ObjectReference.Builder, io.kubernetes.client.proto.V1.ObjectReferenceOrBuilder>(
                  active_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          active_ = null;
        }
        return activeBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time lastScheduleTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastScheduleTimeBuilder_;
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public boolean hasLastScheduleTime() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastScheduleTime() {
        if (lastScheduleTimeBuilder_ == null) {
          return lastScheduleTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastScheduleTime_;
        } else {
          return lastScheduleTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public Builder setLastScheduleTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastScheduleTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastScheduleTime_ = value;
          onChanged();
        } else {
          lastScheduleTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public Builder setLastScheduleTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastScheduleTimeBuilder_ == null) {
          lastScheduleTime_ = builderForValue.build();
          onChanged();
        } else {
          lastScheduleTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public Builder mergeLastScheduleTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastScheduleTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              lastScheduleTime_ != null &&
              lastScheduleTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastScheduleTime_ =
              io.kubernetes.client.proto.Meta.Time.newBuilder(lastScheduleTime_).mergeFrom(value).buildPartial();
          } else {
            lastScheduleTime_ = value;
          }
          onChanged();
        } else {
          lastScheduleTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public Builder clearLastScheduleTime() {
        if (lastScheduleTimeBuilder_ == null) {
          lastScheduleTime_ = null;
          onChanged();
        } else {
          lastScheduleTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastScheduleTimeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getLastScheduleTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastScheduleTimeOrBuilder() {
        if (lastScheduleTimeBuilder_ != null) {
          return lastScheduleTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastScheduleTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastScheduleTime_;
        }
      }
      /**
       * <pre>
       * Information when was the last time the job was successfully scheduled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduleTime = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastScheduleTimeFieldBuilder() {
        if (lastScheduleTimeBuilder_ == null) {
          lastScheduleTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastScheduleTime(),
                  getParentForChildren(),
                  isClean());
          lastScheduleTime_ = null;
        }
        return lastScheduleTimeBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time lastSuccessfulTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastSuccessfulTimeBuilder_;
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public boolean hasLastSuccessfulTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastSuccessfulTime() {
        if (lastSuccessfulTimeBuilder_ == null) {
          return lastSuccessfulTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastSuccessfulTime_;
        } else {
          return lastSuccessfulTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public Builder setLastSuccessfulTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastSuccessfulTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastSuccessfulTime_ = value;
          onChanged();
        } else {
          lastSuccessfulTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public Builder setLastSuccessfulTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastSuccessfulTimeBuilder_ == null) {
          lastSuccessfulTime_ = builderForValue.build();
          onChanged();
        } else {
          lastSuccessfulTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public Builder mergeLastSuccessfulTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastSuccessfulTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              lastSuccessfulTime_ != null &&
              lastSuccessfulTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastSuccessfulTime_ =
              io.kubernetes.client.proto.Meta.Time.newBuilder(lastSuccessfulTime_).mergeFrom(value).buildPartial();
          } else {
            lastSuccessfulTime_ = value;
          }
          onChanged();
        } else {
          lastSuccessfulTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public Builder clearLastSuccessfulTime() {
        if (lastSuccessfulTimeBuilder_ == null) {
          lastSuccessfulTime_ = null;
          onChanged();
        } else {
          lastSuccessfulTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastSuccessfulTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastSuccessfulTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastSuccessfulTimeOrBuilder() {
        if (lastSuccessfulTimeBuilder_ != null) {
          return lastSuccessfulTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastSuccessfulTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastSuccessfulTime_;
        }
      }
      /**
       * <pre>
       * Information when was the last time the job successfully completed.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastSuccessfulTime = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastSuccessfulTimeFieldBuilder() {
        if (lastSuccessfulTimeBuilder_ == null) {
          lastSuccessfulTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastSuccessfulTime(),
                  getParentForChildren(),
                  isClean());
          lastSuccessfulTime_ = null;
        }
        return lastSuccessfulTimeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.CronJobStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.CronJobStatus)
    private static final io.kubernetes.client.proto.V1Batch.CronJobStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.CronJobStatus();
    }

    public static io.kubernetes.client.proto.V1Batch.CronJobStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CronJobStatus>
        PARSER = new com.google.protobuf.AbstractParser<CronJobStatus>() {
      @java.lang.Override
      public CronJobStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CronJobStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CronJobStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CronJobStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.CronJobStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JobOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.Job)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * Current status of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * Current status of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobStatus getStatus();
    /**
     * <pre>
     * Current status of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * Job represents the configuration of a single job.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.Job}
   */
  public  static final class Job extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.Job)
      JobOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Job.newBuilder() to construct.
    private Job(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Job() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Job(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Batch.JobSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1Batch.JobSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1Batch.JobStatus.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = status_.toBuilder();
              }
              status_ = input.readMessage(io.kubernetes.client.proto.V1Batch.JobStatus.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(status_);
                status_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_Job_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_Job_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.Job.class, io.kubernetes.client.proto.V1Batch.Job.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Batch.JobSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Batch.JobStatus status_;
    /**
     * <pre>
     * Current status of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Current status of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * Current status of a job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.Job)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.Job other = (io.kubernetes.client.proto.V1Batch.Job) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.Job parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.Job prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Job represents the configuration of a single job.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.Job}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.Job)
        io.kubernetes.client.proto.V1Batch.JobOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_Job_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_Job_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.Job.class, io.kubernetes.client.proto.V1Batch.Job.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.Job.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_Job_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.Job getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.Job.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.Job build() {
        io.kubernetes.client.proto.V1Batch.Job result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.Job buildPartial() {
        io.kubernetes.client.proto.V1Batch.Job result = new io.kubernetes.client.proto.V1Batch.Job(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.Job) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.Job)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.Job other) {
        if (other == io.kubernetes.client.proto.V1Batch.Job.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.Job parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.Job) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Batch.JobSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobSpec, io.kubernetes.client.proto.V1Batch.JobSpec.Builder, io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Batch.JobSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Batch.JobSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Batch.JobSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1Batch.JobSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobSpec, io.kubernetes.client.proto.V1Batch.JobSpec.Builder, io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.JobSpec, io.kubernetes.client.proto.V1Batch.JobSpec.Builder, io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Batch.JobStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobStatus, io.kubernetes.client.proto.V1Batch.JobStatus.Builder, io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Batch.JobStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Batch.JobStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Batch.JobStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              status_ != null &&
              status_ != io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance()) {
            status_ =
              io.kubernetes.client.proto.V1Batch.JobStatus.newBuilder(status_).mergeFrom(value).buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * Current status of a job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobStatus, io.kubernetes.client.proto.V1Batch.JobStatus.Builder, io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.JobStatus, io.kubernetes.client.proto.V1Batch.JobStatus.Builder, io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.Job)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.Job)
    private static final io.kubernetes.client.proto.V1Batch.Job DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.Job();
    }

    public static io.kubernetes.client.proto.V1Batch.Job getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Job>
        PARSER = new com.google.protobuf.AbstractParser<Job>() {
      @java.lang.Override
      public Job parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Job(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Job> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Job> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.Job getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JobConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.JobCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of job condition, Complete or Failed.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * Type of job condition, Complete or Failed.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of job condition, Complete or Failed.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    com.google.protobuf.ByteString
        getStatusBytes();

    /**
     * <pre>
     * Last time the condition was checked.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
     */
    boolean hasLastProbeTime();
    /**
     * <pre>
     * Last time the condition was checked.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastProbeTime();
    /**
     * <pre>
     * Last time the condition was checked.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastProbeTimeOrBuilder();

    /**
     * <pre>
     * Last time the condition transit from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    boolean hasLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transit from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     * <pre>
     * Last time the condition transit from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     * <pre>
     * (brief) reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     */
    boolean hasReason();
    /**
     * <pre>
     * (brief) reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     */
    java.lang.String getReason();
    /**
     * <pre>
     * (brief) reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * Human readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6;</code>
     */
    boolean hasMessage();
    /**
     * <pre>
     * Human readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6;</code>
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Human readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6;</code>
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * <pre>
   * JobCondition describes current state of a job.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.JobCondition}
   */
  public  static final class JobCondition extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.JobCondition)
      JobConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use JobCondition.newBuilder() to construct.
    private JobCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private JobCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private JobCondition(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              status_ = bs;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = lastProbeTime_.toBuilder();
              }
              lastProbeTime_ = input.readMessage(io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(lastProbeTime_);
                lastProbeTime_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = lastTransitionTime_.toBuilder();
              }
              lastTransitionTime_ = input.readMessage(io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(lastTransitionTime_);
                lastTransitionTime_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000010;
              reason_ = bs;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000020;
              message_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.JobCondition.class, io.kubernetes.client.proto.V1Batch.JobCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * Type of job condition, Complete or Failed.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Type of job condition, Complete or Failed.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of job condition, Complete or Failed.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private volatile java.lang.Object status_;
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTPROBETIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time lastProbeTime_;
    /**
     * <pre>
     * Last time the condition was checked.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
     */
    public boolean hasLastProbeTime() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Last time the condition was checked.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastProbeTime() {
      return lastProbeTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastProbeTime_;
    }
    /**
     * <pre>
     * Last time the condition was checked.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastProbeTimeOrBuilder() {
      return lastProbeTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastProbeTime_;
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     * <pre>
     * Last time the condition transit from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Last time the condition transit from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }
    /**
     * <pre>
     * Last time the condition transit from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 5;
    private volatile java.lang.Object reason_;
    /**
     * <pre>
     * (brief) reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     */
    public boolean hasReason() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * (brief) reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     */
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * (brief) reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 5;</code>
     */
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 6;
    private volatile java.lang.Object message_;
    /**
     * <pre>
     * Human readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Human readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Human readable message indicating details about last transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 6;</code>
     */
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getLastProbeTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, reason_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, message_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getLastProbeTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, reason_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, message_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.JobCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.JobCondition other = (io.kubernetes.client.proto.V1Batch.JobCondition) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType()
            .equals(other.getType());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && (hasLastProbeTime() == other.hasLastProbeTime());
      if (hasLastProbeTime()) {
        result = result && getLastProbeTime()
            .equals(other.getLastProbeTime());
      }
      result = result && (hasLastTransitionTime() == other.hasLastTransitionTime());
      if (hasLastTransitionTime()) {
        result = result && getLastTransitionTime()
            .equals(other.getLastTransitionTime());
      }
      result = result && (hasReason() == other.hasReason());
      if (hasReason()) {
        result = result && getReason()
            .equals(other.getReason());
      }
      result = result && (hasMessage() == other.hasMessage());
      if (hasMessage()) {
        result = result && getMessage()
            .equals(other.getMessage());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastProbeTime()) {
        hash = (37 * hash) + LASTPROBETIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastProbeTime().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.JobCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * JobCondition describes current state of a job.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.JobCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.JobCondition)
        io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.JobCondition.class, io.kubernetes.client.proto.V1Batch.JobCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.JobCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getLastProbeTimeFieldBuilder();
          getLastTransitionTimeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        status_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (lastProbeTimeBuilder_ == null) {
          lastProbeTime_ = null;
        } else {
          lastProbeTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        reason_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.JobCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobCondition build() {
        io.kubernetes.client.proto.V1Batch.JobCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobCondition buildPartial() {
        io.kubernetes.client.proto.V1Batch.JobCondition result = new io.kubernetes.client.proto.V1Batch.JobCondition(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.status_ = status_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (lastProbeTimeBuilder_ == null) {
          result.lastProbeTime_ = lastProbeTime_;
        } else {
          result.lastProbeTime_ = lastProbeTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (lastTransitionTimeBuilder_ == null) {
          result.lastTransitionTime_ = lastTransitionTime_;
        } else {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.reason_ = reason_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.message_ = message_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.JobCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.JobCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.JobCondition other) {
        if (other == io.kubernetes.client.proto.V1Batch.JobCondition.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasStatus()) {
          bitField0_ |= 0x00000002;
          status_ = other.status_;
          onChanged();
        }
        if (other.hasLastProbeTime()) {
          mergeLastProbeTime(other.getLastProbeTime());
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          bitField0_ |= 0x00000010;
          reason_ = other.reason_;
          onChanged();
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000020;
          message_ = other.message_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.JobCondition parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.JobCondition) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of job condition, Complete or Failed.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Type of job condition, Complete or Failed.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of job condition, Complete or Failed.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of job condition, Complete or Failed.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of job condition, Complete or Failed.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of job condition, Complete or Failed.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = getDefaultInstance().getStatus();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastProbeTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastProbeTimeBuilder_;
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public boolean hasLastProbeTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastProbeTime() {
        if (lastProbeTimeBuilder_ == null) {
          return lastProbeTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastProbeTime_;
        } else {
          return lastProbeTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public Builder setLastProbeTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastProbeTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastProbeTime_ = value;
          onChanged();
        } else {
          lastProbeTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public Builder setLastProbeTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastProbeTimeBuilder_ == null) {
          lastProbeTime_ = builderForValue.build();
          onChanged();
        } else {
          lastProbeTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public Builder mergeLastProbeTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastProbeTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              lastProbeTime_ != null &&
              lastProbeTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastProbeTime_ =
              io.kubernetes.client.proto.Meta.Time.newBuilder(lastProbeTime_).mergeFrom(value).buildPartial();
          } else {
            lastProbeTime_ = value;
          }
          onChanged();
        } else {
          lastProbeTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public Builder clearLastProbeTime() {
        if (lastProbeTimeBuilder_ == null) {
          lastProbeTime_ = null;
          onChanged();
        } else {
          lastProbeTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastProbeTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastProbeTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastProbeTimeOrBuilder() {
        if (lastProbeTimeBuilder_ != null) {
          return lastProbeTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastProbeTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastProbeTime_;
        }
      }
      /**
       * <pre>
       * Last time the condition was checked.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastProbeTimeFieldBuilder() {
        if (lastProbeTimeBuilder_ == null) {
          lastProbeTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastProbeTime(),
                  getParentForChildren(),
                  isClean());
          lastProbeTime_ = null;
        }
        return lastProbeTimeBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> lastTransitionTimeBuilder_;
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008) &&
              lastTransitionTime_ != null &&
              lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastTransitionTime_ =
              io.kubernetes.client.proto.Meta.Time.newBuilder(lastTransitionTime_).mergeFrom(value).buildPartial();
          } else {
            lastTransitionTime_ = value;
          }
          onChanged();
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public Builder clearLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : lastTransitionTime_;
        }
      }
      /**
       * <pre>
       * Last time the condition transit from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(),
                  getParentForChildren(),
                  isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * (brief) reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * (brief) reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * (brief) reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * (brief) reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        reason_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (brief) reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000010);
        reason_ = getDefaultInstance().getReason();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (brief) reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 5;</code>
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        reason_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Human readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * Human readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Human readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6;</code>
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Human readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6;</code>
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000020);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human readable message indicating details about last transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 6;</code>
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        message_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.JobCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.JobCondition)
    private static final io.kubernetes.client.proto.V1Batch.JobCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.JobCondition();
    }

    public static io.kubernetes.client.proto.V1Batch.JobCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<JobCondition>
        PARSER = new com.google.protobuf.AbstractParser<JobCondition>() {
      @java.lang.Override
      public JobCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new JobCondition(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<JobCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<JobCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.JobCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JobListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.JobList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Batch.Job> 
        getItemsList();
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.Job getItems(int index);
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Batch.JobOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * JobList is a collection of jobs.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.JobList}
   */
  public  static final class JobList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.JobList)
      JobListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use JobList.newBuilder() to construct.
    private JobList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private JobList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private JobList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.Job>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Batch.Job.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.JobList.class, io.kubernetes.client.proto.V1Batch.JobList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Batch.Job> items_;
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Batch.Job> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Batch.JobOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.Job getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * items is the list of Jobs.
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.JobList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.JobList other = (io.kubernetes.client.proto.V1Batch.JobList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.JobList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * JobList is a collection of jobs.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.JobList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.JobList)
        io.kubernetes.client.proto.V1Batch.JobListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.JobList.class, io.kubernetes.client.proto.V1Batch.JobList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.JobList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.JobList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobList build() {
        io.kubernetes.client.proto.V1Batch.JobList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobList buildPartial() {
        io.kubernetes.client.proto.V1Batch.JobList result = new io.kubernetes.client.proto.V1Batch.JobList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.JobList) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.JobList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.JobList other) {
        if (other == io.kubernetes.client.proto.V1Batch.JobList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.JobList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.JobList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Batch.Job> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.Job>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.Job, io.kubernetes.client.proto.V1Batch.Job.Builder, io.kubernetes.client.proto.V1Batch.JobOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.Job> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.Job getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Batch.Job value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Batch.Job.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Batch.Job value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Batch.Job value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Batch.Job.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Batch.Job.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Batch.Job> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.Job.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Batch.JobOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.Job.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Batch.Job.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.Job.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Batch.Job.getDefaultInstance());
      }
      /**
       * <pre>
       * items is the list of Jobs.
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.Job items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.Job.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.Job, io.kubernetes.client.proto.V1Batch.Job.Builder, io.kubernetes.client.proto.V1Batch.JobOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.Job, io.kubernetes.client.proto.V1Batch.Job.Builder, io.kubernetes.client.proto.V1Batch.JobOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.JobList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.JobList)
    private static final io.kubernetes.client.proto.V1Batch.JobList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.JobList();
    }

    public static io.kubernetes.client.proto.V1Batch.JobList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<JobList>
        PARSER = new com.google.protobuf.AbstractParser<JobList>() {
      @java.lang.Override
      public JobList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new JobList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<JobList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<JobList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.JobList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JobSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.JobSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the maximum desired number of pods the job should
     * run at any given time. The actual number of pods running in steady state will
     * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
     * i.e. when the work left to do is less than max parallelism.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 parallelism = 1;</code>
     */
    boolean hasParallelism();
    /**
     * <pre>
     * Specifies the maximum desired number of pods the job should
     * run at any given time. The actual number of pods running in steady state will
     * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
     * i.e. when the work left to do is less than max parallelism.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 parallelism = 1;</code>
     */
    int getParallelism();

    /**
     * <pre>
     * Specifies the desired number of successfully finished pods the
     * job should be run with.  Setting to null means that the success of any
     * pod signals the success of all pods, and allows parallelism to have any positive
     * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
     * pod signals the success of the job.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 completions = 2;</code>
     */
    boolean hasCompletions();
    /**
     * <pre>
     * Specifies the desired number of successfully finished pods the
     * job should be run with.  Setting to null means that the success of any
     * pod signals the success of all pods, and allows parallelism to have any positive
     * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
     * pod signals the success of the job.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 completions = 2;</code>
     */
    int getCompletions();

    /**
     * <pre>
     * Specifies the duration in seconds relative to the startTime that the job
     * may be continuously active before the system tries to terminate it; value
     * must be positive integer. If a Job is suspended (at creation or through an
     * update), this timer will effectively be stopped and reset when the Job is
     * resumed again.
     * +optional
     * </pre>
     *
     * <code>optional int64 activeDeadlineSeconds = 3;</code>
     */
    boolean hasActiveDeadlineSeconds();
    /**
     * <pre>
     * Specifies the duration in seconds relative to the startTime that the job
     * may be continuously active before the system tries to terminate it; value
     * must be positive integer. If a Job is suspended (at creation or through an
     * update), this timer will effectively be stopped and reset when the Job is
     * resumed again.
     * +optional
     * </pre>
     *
     * <code>optional int64 activeDeadlineSeconds = 3;</code>
     */
    long getActiveDeadlineSeconds();

    /**
     * <pre>
     * Specifies the policy of handling failed pods. In particular, it allows to
     * specify the set of actions and conditions which need to be
     * satisfied to take the associated action.
     * If empty, the default behaviour applies - the counter of failed pods,
     * represented by the jobs's .status.failed field, is incremented and it is
     * checked against the backoffLimit. This field cannot be used in combination
     * with restartPolicy=OnFailure.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
     */
    boolean hasPodFailurePolicy();
    /**
     * <pre>
     * Specifies the policy of handling failed pods. In particular, it allows to
     * specify the set of actions and conditions which need to be
     * satisfied to take the associated action.
     * If empty, the default behaviour applies - the counter of failed pods,
     * represented by the jobs's .status.failed field, is incremented and it is
     * checked against the backoffLimit. This field cannot be used in combination
     * with restartPolicy=OnFailure.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicy getPodFailurePolicy();
    /**
     * <pre>
     * Specifies the policy of handling failed pods. In particular, it allows to
     * specify the set of actions and conditions which need to be
     * satisfied to take the associated action.
     * If empty, the default behaviour applies - the counter of failed pods,
     * represented by the jobs's .status.failed field, is incremented and it is
     * checked against the backoffLimit. This field cannot be used in combination
     * with restartPolicy=OnFailure.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder getPodFailurePolicyOrBuilder();

    /**
     * <pre>
     * successPolicy specifies the policy when the Job can be declared as succeeded.
     * If empty, the default behavior applies - the Job is declared as succeeded
     * only when the number of succeeded pods equals to the completions.
     * When the field is specified, it must be immutable and works only for the Indexed Jobs.
     * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
     */
    boolean hasSuccessPolicy();
    /**
     * <pre>
     * successPolicy specifies the policy when the Job can be declared as succeeded.
     * If empty, the default behavior applies - the Job is declared as succeeded
     * only when the number of succeeded pods equals to the completions.
     * When the field is specified, it must be immutable and works only for the Indexed Jobs.
     * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
     */
    io.kubernetes.client.proto.V1Batch.SuccessPolicy getSuccessPolicy();
    /**
     * <pre>
     * successPolicy specifies the policy when the Job can be declared as succeeded.
     * If empty, the default behavior applies - the Job is declared as succeeded
     * only when the number of succeeded pods equals to the completions.
     * When the field is specified, it must be immutable and works only for the Indexed Jobs.
     * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
     */
    io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder getSuccessPolicyOrBuilder();

    /**
     * <pre>
     * Specifies the number of retries before marking this job failed.
     * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
     * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimit = 7;</code>
     */
    boolean hasBackoffLimit();
    /**
     * <pre>
     * Specifies the number of retries before marking this job failed.
     * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
     * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimit = 7;</code>
     */
    int getBackoffLimit();

    /**
     * <pre>
     * Specifies the limit for the number of retries within an
     * index before marking this index as failed. When enabled the number of
     * failures per index is kept in the pod's
     * batch.kubernetes.io/job-index-failure-count annotation. It can only
     * be set when Job's completionMode=Indexed, and the Pod's restart
     * policy is Never. The field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimitPerIndex = 12;</code>
     */
    boolean hasBackoffLimitPerIndex();
    /**
     * <pre>
     * Specifies the limit for the number of retries within an
     * index before marking this index as failed. When enabled the number of
     * failures per index is kept in the pod's
     * batch.kubernetes.io/job-index-failure-count annotation. It can only
     * be set when Job's completionMode=Indexed, and the Pod's restart
     * policy is Never. The field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimitPerIndex = 12;</code>
     */
    int getBackoffLimitPerIndex();

    /**
     * <pre>
     * Specifies the maximal number of failed indexes before marking the Job as
     * failed, when backoffLimitPerIndex is set. Once the number of failed
     * indexes exceeds this number the entire Job is marked as Failed and its
     * execution is terminated. When left as null the job continues execution of
     * all of its indexes and is marked with the `Complete` Job condition.
     * It can only be specified when backoffLimitPerIndex is set.
     * It can be null or up to completions. It is required and must be
     * less than or equal to 10^4 when is completions greater than 10^5.
     * +optional
     * </pre>
     *
     * <code>optional int32 maxFailedIndexes = 13;</code>
     */
    boolean hasMaxFailedIndexes();
    /**
     * <pre>
     * Specifies the maximal number of failed indexes before marking the Job as
     * failed, when backoffLimitPerIndex is set. Once the number of failed
     * indexes exceeds this number the entire Job is marked as Failed and its
     * execution is terminated. When left as null the job continues execution of
     * all of its indexes and is marked with the `Complete` Job condition.
     * It can only be specified when backoffLimitPerIndex is set.
     * It can be null or up to completions. It is required and must be
     * less than or equal to 10^4 when is completions greater than 10^5.
     * +optional
     * </pre>
     *
     * <code>optional int32 maxFailedIndexes = 13;</code>
     */
    int getMaxFailedIndexes();

    /**
     * <pre>
     * A label query over pods that should match the pod count.
     * Normally, the system sets this field for you.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
     */
    boolean hasSelector();
    /**
     * <pre>
     * A label query over pods that should match the pod count.
     * Normally, the system sets this field for you.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * A label query over pods that should match the pod count.
     * Normally, the system sets this field for you.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * manualSelector controls generation of pod labels and pod selectors.
     * Leave `manualSelector` unset unless you are certain what you are doing.
     * When false or unset, the system pick labels unique to this job
     * and appends those labels to the pod template.  When true,
     * the user is responsible for picking unique labels and specifying
     * the selector.  Failure to pick a unique label may cause this
     * and other jobs to not function correctly.  However, You may see
     * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
     * API.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
     * +optional
     * </pre>
     *
     * <code>optional bool manualSelector = 5;</code>
     */
    boolean hasManualSelector();
    /**
     * <pre>
     * manualSelector controls generation of pod labels and pod selectors.
     * Leave `manualSelector` unset unless you are certain what you are doing.
     * When false or unset, the system pick labels unique to this job
     * and appends those labels to the pod template.  When true,
     * the user is responsible for picking unique labels and specifying
     * the selector.  Failure to pick a unique label may cause this
     * and other jobs to not function correctly.  However, You may see
     * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
     * API.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
     * +optional
     * </pre>
     *
     * <code>optional bool manualSelector = 5;</code>
     */
    boolean getManualSelector();

    /**
     * <pre>
     * Describes the pod that will be created when executing a job.
     * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
     */
    boolean hasTemplate();
    /**
     * <pre>
     * Describes the pod that will be created when executing a job.
     * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     * <pre>
     * Describes the pod that will be created when executing a job.
     * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     * <pre>
     * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
     * execution (either Complete or Failed). If this field is set,
     * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
     * automatically deleted. When the Job is being deleted, its lifecycle
     * guarantees (e.g. finalizers) will be honored. If this field is unset,
     * the Job won't be automatically deleted. If this field is set to zero,
     * the Job becomes eligible to be deleted immediately after it finishes.
     * +optional
     * </pre>
     *
     * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
     */
    boolean hasTtlSecondsAfterFinished();
    /**
     * <pre>
     * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
     * execution (either Complete or Failed). If this field is set,
     * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
     * automatically deleted. When the Job is being deleted, its lifecycle
     * guarantees (e.g. finalizers) will be honored. If this field is unset,
     * the Job won't be automatically deleted. If this field is set to zero,
     * the Job becomes eligible to be deleted immediately after it finishes.
     * +optional
     * </pre>
     *
     * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
     */
    int getTtlSecondsAfterFinished();

    /**
     * <pre>
     * completionMode specifies how Pod completions are tracked. It can be
     * `NonIndexed` (default) or `Indexed`.
     * `NonIndexed` means that the Job is considered complete when there have
     * been .spec.completions successfully completed Pods. Each Pod completion is
     * homologous to each other.
     * `Indexed` means that the Pods of a
     * Job get an associated completion index from 0 to (.spec.completions - 1),
     * available in the annotation batch.kubernetes.io/job-completion-index.
     * The Job is considered complete when there is one successfully completed Pod
     * for each index.
     * When value is `Indexed`, .spec.completions must be specified and
     * `.spec.parallelism` must be less than or equal to 10^5.
     * In addition, The Pod name takes the form
     * `$(job-name)-$(index)-$(random-string)`,
     * the Pod hostname takes the form `$(job-name)-$(index)`.
     * More completion modes can be added in the future.
     * If the Job controller observes a mode that it doesn't recognize, which
     * is possible during upgrades due to version skew, the controller
     * skips updates for the Job.
     * +optional
     * </pre>
     *
     * <code>optional string completionMode = 9;</code>
     */
    boolean hasCompletionMode();
    /**
     * <pre>
     * completionMode specifies how Pod completions are tracked. It can be
     * `NonIndexed` (default) or `Indexed`.
     * `NonIndexed` means that the Job is considered complete when there have
     * been .spec.completions successfully completed Pods. Each Pod completion is
     * homologous to each other.
     * `Indexed` means that the Pods of a
     * Job get an associated completion index from 0 to (.spec.completions - 1),
     * available in the annotation batch.kubernetes.io/job-completion-index.
     * The Job is considered complete when there is one successfully completed Pod
     * for each index.
     * When value is `Indexed`, .spec.completions must be specified and
     * `.spec.parallelism` must be less than or equal to 10^5.
     * In addition, The Pod name takes the form
     * `$(job-name)-$(index)-$(random-string)`,
     * the Pod hostname takes the form `$(job-name)-$(index)`.
     * More completion modes can be added in the future.
     * If the Job controller observes a mode that it doesn't recognize, which
     * is possible during upgrades due to version skew, the controller
     * skips updates for the Job.
     * +optional
     * </pre>
     *
     * <code>optional string completionMode = 9;</code>
     */
    java.lang.String getCompletionMode();
    /**
     * <pre>
     * completionMode specifies how Pod completions are tracked. It can be
     * `NonIndexed` (default) or `Indexed`.
     * `NonIndexed` means that the Job is considered complete when there have
     * been .spec.completions successfully completed Pods. Each Pod completion is
     * homologous to each other.
     * `Indexed` means that the Pods of a
     * Job get an associated completion index from 0 to (.spec.completions - 1),
     * available in the annotation batch.kubernetes.io/job-completion-index.
     * The Job is considered complete when there is one successfully completed Pod
     * for each index.
     * When value is `Indexed`, .spec.completions must be specified and
     * `.spec.parallelism` must be less than or equal to 10^5.
     * In addition, The Pod name takes the form
     * `$(job-name)-$(index)-$(random-string)`,
     * the Pod hostname takes the form `$(job-name)-$(index)`.
     * More completion modes can be added in the future.
     * If the Job controller observes a mode that it doesn't recognize, which
     * is possible during upgrades due to version skew, the controller
     * skips updates for the Job.
     * +optional
     * </pre>
     *
     * <code>optional string completionMode = 9;</code>
     */
    com.google.protobuf.ByteString
        getCompletionModeBytes();

    /**
     * <pre>
     * suspend specifies whether the Job controller should create Pods or not. If
     * a Job is created with suspend set to true, no Pods are created by the Job
     * controller. If a Job is suspended after creation (i.e. the flag goes from
     * false to true), the Job controller will delete all active Pods associated
     * with this Job. Users must design their workload to gracefully handle this.
     * Suspending a Job will reset the StartTime field of the Job, effectively
     * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 10;</code>
     */
    boolean hasSuspend();
    /**
     * <pre>
     * suspend specifies whether the Job controller should create Pods or not. If
     * a Job is created with suspend set to true, no Pods are created by the Job
     * controller. If a Job is suspended after creation (i.e. the flag goes from
     * false to true), the Job controller will delete all active Pods associated
     * with this Job. Users must design their workload to gracefully handle this.
     * Suspending a Job will reset the StartTime field of the Job, effectively
     * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 10;</code>
     */
    boolean getSuspend();

    /**
     * <pre>
     * podReplacementPolicy specifies when to create replacement Pods.
     * Possible values are:
     * - TerminatingOrFailed means that we recreate pods
     *   when they are terminating (has a metadata.deletionTimestamp) or failed.
     * - Failed means to wait until a previously created Pod is fully terminated (has phase
     *   Failed or Succeeded) before creating a replacement Pod.
     * When using podFailurePolicy, Failed is the the only allowed value.
     * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
     * +optional
     * </pre>
     *
     * <code>optional string podReplacementPolicy = 14;</code>
     */
    boolean hasPodReplacementPolicy();
    /**
     * <pre>
     * podReplacementPolicy specifies when to create replacement Pods.
     * Possible values are:
     * - TerminatingOrFailed means that we recreate pods
     *   when they are terminating (has a metadata.deletionTimestamp) or failed.
     * - Failed means to wait until a previously created Pod is fully terminated (has phase
     *   Failed or Succeeded) before creating a replacement Pod.
     * When using podFailurePolicy, Failed is the the only allowed value.
     * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
     * +optional
     * </pre>
     *
     * <code>optional string podReplacementPolicy = 14;</code>
     */
    java.lang.String getPodReplacementPolicy();
    /**
     * <pre>
     * podReplacementPolicy specifies when to create replacement Pods.
     * Possible values are:
     * - TerminatingOrFailed means that we recreate pods
     *   when they are terminating (has a metadata.deletionTimestamp) or failed.
     * - Failed means to wait until a previously created Pod is fully terminated (has phase
     *   Failed or Succeeded) before creating a replacement Pod.
     * When using podFailurePolicy, Failed is the the only allowed value.
     * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
     * +optional
     * </pre>
     *
     * <code>optional string podReplacementPolicy = 14;</code>
     */
    com.google.protobuf.ByteString
        getPodReplacementPolicyBytes();

    /**
     * <pre>
     * ManagedBy field indicates the controller that manages a Job. The k8s Job
     * controller reconciles jobs which don't have this field at all or the field
     * value is the reserved string `kubernetes.io/job-controller`, but skips
     * reconciling Jobs with a custom value for this field.
     * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
     * all characters before the first "/" must be a valid subdomain as defined
     * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
     * characters as defined by RFC 3986. The value cannot exceed 63 characters.
     * This field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional string managedBy = 15;</code>
     */
    boolean hasManagedBy();
    /**
     * <pre>
     * ManagedBy field indicates the controller that manages a Job. The k8s Job
     * controller reconciles jobs which don't have this field at all or the field
     * value is the reserved string `kubernetes.io/job-controller`, but skips
     * reconciling Jobs with a custom value for this field.
     * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
     * all characters before the first "/" must be a valid subdomain as defined
     * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
     * characters as defined by RFC 3986. The value cannot exceed 63 characters.
     * This field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional string managedBy = 15;</code>
     */
    java.lang.String getManagedBy();
    /**
     * <pre>
     * ManagedBy field indicates the controller that manages a Job. The k8s Job
     * controller reconciles jobs which don't have this field at all or the field
     * value is the reserved string `kubernetes.io/job-controller`, but skips
     * reconciling Jobs with a custom value for this field.
     * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
     * all characters before the first "/" must be a valid subdomain as defined
     * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
     * characters as defined by RFC 3986. The value cannot exceed 63 characters.
     * This field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional string managedBy = 15;</code>
     */
    com.google.protobuf.ByteString
        getManagedByBytes();
  }
  /**
   * <pre>
   * JobSpec describes how the job execution will look like.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.JobSpec}
   */
  public  static final class JobSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.JobSpec)
      JobSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use JobSpec.newBuilder() to construct.
    private JobSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private JobSpec() {
      parallelism_ = 0;
      completions_ = 0;
      activeDeadlineSeconds_ = 0L;
      backoffLimit_ = 0;
      backoffLimitPerIndex_ = 0;
      maxFailedIndexes_ = 0;
      manualSelector_ = false;
      ttlSecondsAfterFinished_ = 0;
      completionMode_ = "";
      suspend_ = false;
      podReplacementPolicy_ = "";
      managedBy_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private JobSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              parallelism_ = input.readInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              completions_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              activeDeadlineSeconds_ = input.readInt64();
              break;
            }
            case 34: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) == 0x00000100)) {
                subBuilder = selector_.toBuilder();
              }
              selector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(selector_);
                selector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 40: {
              bitField0_ |= 0x00000200;
              manualSelector_ = input.readBool();
              break;
            }
            case 50: {
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) == 0x00000400)) {
                subBuilder = template_.toBuilder();
              }
              template_ = input.readMessage(io.kubernetes.client.proto.V1.PodTemplateSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(template_);
                template_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000020;
              backoffLimit_ = input.readInt32();
              break;
            }
            case 64: {
              bitField0_ |= 0x00000800;
              ttlSecondsAfterFinished_ = input.readInt32();
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00001000;
              completionMode_ = bs;
              break;
            }
            case 80: {
              bitField0_ |= 0x00002000;
              suspend_ = input.readBool();
              break;
            }
            case 90: {
              io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = podFailurePolicy_.toBuilder();
              }
              podFailurePolicy_ = input.readMessage(io.kubernetes.client.proto.V1Batch.PodFailurePolicy.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(podFailurePolicy_);
                podFailurePolicy_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 96: {
              bitField0_ |= 0x00000040;
              backoffLimitPerIndex_ = input.readInt32();
              break;
            }
            case 104: {
              bitField0_ |= 0x00000080;
              maxFailedIndexes_ = input.readInt32();
              break;
            }
            case 114: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00004000;
              podReplacementPolicy_ = bs;
              break;
            }
            case 122: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00008000;
              managedBy_ = bs;
              break;
            }
            case 130: {
              io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = successPolicy_.toBuilder();
              }
              successPolicy_ = input.readMessage(io.kubernetes.client.proto.V1Batch.SuccessPolicy.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(successPolicy_);
                successPolicy_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.JobSpec.class, io.kubernetes.client.proto.V1Batch.JobSpec.Builder.class);
    }

    private int bitField0_;
    public static final int PARALLELISM_FIELD_NUMBER = 1;
    private int parallelism_;
    /**
     * <pre>
     * Specifies the maximum desired number of pods the job should
     * run at any given time. The actual number of pods running in steady state will
     * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
     * i.e. when the work left to do is less than max parallelism.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 parallelism = 1;</code>
     */
    public boolean hasParallelism() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Specifies the maximum desired number of pods the job should
     * run at any given time. The actual number of pods running in steady state will
     * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
     * i.e. when the work left to do is less than max parallelism.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 parallelism = 1;</code>
     */
    public int getParallelism() {
      return parallelism_;
    }

    public static final int COMPLETIONS_FIELD_NUMBER = 2;
    private int completions_;
    /**
     * <pre>
     * Specifies the desired number of successfully finished pods the
     * job should be run with.  Setting to null means that the success of any
     * pod signals the success of all pods, and allows parallelism to have any positive
     * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
     * pod signals the success of the job.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 completions = 2;</code>
     */
    public boolean hasCompletions() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specifies the desired number of successfully finished pods the
     * job should be run with.  Setting to null means that the success of any
     * pod signals the success of all pods, and allows parallelism to have any positive
     * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
     * pod signals the success of the job.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * </pre>
     *
     * <code>optional int32 completions = 2;</code>
     */
    public int getCompletions() {
      return completions_;
    }

    public static final int ACTIVEDEADLINESECONDS_FIELD_NUMBER = 3;
    private long activeDeadlineSeconds_;
    /**
     * <pre>
     * Specifies the duration in seconds relative to the startTime that the job
     * may be continuously active before the system tries to terminate it; value
     * must be positive integer. If a Job is suspended (at creation or through an
     * update), this timer will effectively be stopped and reset when the Job is
     * resumed again.
     * +optional
     * </pre>
     *
     * <code>optional int64 activeDeadlineSeconds = 3;</code>
     */
    public boolean hasActiveDeadlineSeconds() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Specifies the duration in seconds relative to the startTime that the job
     * may be continuously active before the system tries to terminate it; value
     * must be positive integer. If a Job is suspended (at creation or through an
     * update), this timer will effectively be stopped and reset when the Job is
     * resumed again.
     * +optional
     * </pre>
     *
     * <code>optional int64 activeDeadlineSeconds = 3;</code>
     */
    public long getActiveDeadlineSeconds() {
      return activeDeadlineSeconds_;
    }

    public static final int PODFAILUREPOLICY_FIELD_NUMBER = 11;
    private io.kubernetes.client.proto.V1Batch.PodFailurePolicy podFailurePolicy_;
    /**
     * <pre>
     * Specifies the policy of handling failed pods. In particular, it allows to
     * specify the set of actions and conditions which need to be
     * satisfied to take the associated action.
     * If empty, the default behaviour applies - the counter of failed pods,
     * represented by the jobs's .status.failed field, is incremented and it is
     * checked against the backoffLimit. This field cannot be used in combination
     * with restartPolicy=OnFailure.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
     */
    public boolean hasPodFailurePolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Specifies the policy of handling failed pods. In particular, it allows to
     * specify the set of actions and conditions which need to be
     * satisfied to take the associated action.
     * If empty, the default behaviour applies - the counter of failed pods,
     * represented by the jobs's .status.failed field, is incremented and it is
     * checked against the backoffLimit. This field cannot be used in combination
     * with restartPolicy=OnFailure.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicy getPodFailurePolicy() {
      return podFailurePolicy_ == null ? io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance() : podFailurePolicy_;
    }
    /**
     * <pre>
     * Specifies the policy of handling failed pods. In particular, it allows to
     * specify the set of actions and conditions which need to be
     * satisfied to take the associated action.
     * If empty, the default behaviour applies - the counter of failed pods,
     * represented by the jobs's .status.failed field, is incremented and it is
     * checked against the backoffLimit. This field cannot be used in combination
     * with restartPolicy=OnFailure.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder getPodFailurePolicyOrBuilder() {
      return podFailurePolicy_ == null ? io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance() : podFailurePolicy_;
    }

    public static final int SUCCESSPOLICY_FIELD_NUMBER = 16;
    private io.kubernetes.client.proto.V1Batch.SuccessPolicy successPolicy_;
    /**
     * <pre>
     * successPolicy specifies the policy when the Job can be declared as succeeded.
     * If empty, the default behavior applies - the Job is declared as succeeded
     * only when the number of succeeded pods equals to the completions.
     * When the field is specified, it must be immutable and works only for the Indexed Jobs.
     * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
     */
    public boolean hasSuccessPolicy() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * successPolicy specifies the policy when the Job can be declared as succeeded.
     * If empty, the default behavior applies - the Job is declared as succeeded
     * only when the number of succeeded pods equals to the completions.
     * When the field is specified, it must be immutable and works only for the Indexed Jobs.
     * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
     */
    public io.kubernetes.client.proto.V1Batch.SuccessPolicy getSuccessPolicy() {
      return successPolicy_ == null ? io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance() : successPolicy_;
    }
    /**
     * <pre>
     * successPolicy specifies the policy when the Job can be declared as succeeded.
     * If empty, the default behavior applies - the Job is declared as succeeded
     * only when the number of succeeded pods equals to the completions.
     * When the field is specified, it must be immutable and works only for the Indexed Jobs.
     * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
     */
    public io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder getSuccessPolicyOrBuilder() {
      return successPolicy_ == null ? io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance() : successPolicy_;
    }

    public static final int BACKOFFLIMIT_FIELD_NUMBER = 7;
    private int backoffLimit_;
    /**
     * <pre>
     * Specifies the number of retries before marking this job failed.
     * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
     * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimit = 7;</code>
     */
    public boolean hasBackoffLimit() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Specifies the number of retries before marking this job failed.
     * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
     * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimit = 7;</code>
     */
    public int getBackoffLimit() {
      return backoffLimit_;
    }

    public static final int BACKOFFLIMITPERINDEX_FIELD_NUMBER = 12;
    private int backoffLimitPerIndex_;
    /**
     * <pre>
     * Specifies the limit for the number of retries within an
     * index before marking this index as failed. When enabled the number of
     * failures per index is kept in the pod's
     * batch.kubernetes.io/job-index-failure-count annotation. It can only
     * be set when Job's completionMode=Indexed, and the Pod's restart
     * policy is Never. The field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimitPerIndex = 12;</code>
     */
    public boolean hasBackoffLimitPerIndex() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * Specifies the limit for the number of retries within an
     * index before marking this index as failed. When enabled the number of
     * failures per index is kept in the pod's
     * batch.kubernetes.io/job-index-failure-count annotation. It can only
     * be set when Job's completionMode=Indexed, and the Pod's restart
     * policy is Never. The field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional int32 backoffLimitPerIndex = 12;</code>
     */
    public int getBackoffLimitPerIndex() {
      return backoffLimitPerIndex_;
    }

    public static final int MAXFAILEDINDEXES_FIELD_NUMBER = 13;
    private int maxFailedIndexes_;
    /**
     * <pre>
     * Specifies the maximal number of failed indexes before marking the Job as
     * failed, when backoffLimitPerIndex is set. Once the number of failed
     * indexes exceeds this number the entire Job is marked as Failed and its
     * execution is terminated. When left as null the job continues execution of
     * all of its indexes and is marked with the `Complete` Job condition.
     * It can only be specified when backoffLimitPerIndex is set.
     * It can be null or up to completions. It is required and must be
     * less than or equal to 10^4 when is completions greater than 10^5.
     * +optional
     * </pre>
     *
     * <code>optional int32 maxFailedIndexes = 13;</code>
     */
    public boolean hasMaxFailedIndexes() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * Specifies the maximal number of failed indexes before marking the Job as
     * failed, when backoffLimitPerIndex is set. Once the number of failed
     * indexes exceeds this number the entire Job is marked as Failed and its
     * execution is terminated. When left as null the job continues execution of
     * all of its indexes and is marked with the `Complete` Job condition.
     * It can only be specified when backoffLimitPerIndex is set.
     * It can be null or up to completions. It is required and must be
     * less than or equal to 10^4 when is completions greater than 10^5.
     * +optional
     * </pre>
     *
     * <code>optional int32 maxFailedIndexes = 13;</code>
     */
    public int getMaxFailedIndexes() {
      return maxFailedIndexes_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * A label query over pods that should match the pod count.
     * Normally, the system sets this field for you.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * A label query over pods that should match the pod count.
     * Normally, the system sets this field for you.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * A label query over pods that should match the pod count.
     * Normally, the system sets this field for you.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int MANUALSELECTOR_FIELD_NUMBER = 5;
    private boolean manualSelector_;
    /**
     * <pre>
     * manualSelector controls generation of pod labels and pod selectors.
     * Leave `manualSelector` unset unless you are certain what you are doing.
     * When false or unset, the system pick labels unique to this job
     * and appends those labels to the pod template.  When true,
     * the user is responsible for picking unique labels and specifying
     * the selector.  Failure to pick a unique label may cause this
     * and other jobs to not function correctly.  However, You may see
     * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
     * API.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
     * +optional
     * </pre>
     *
     * <code>optional bool manualSelector = 5;</code>
     */
    public boolean hasManualSelector() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <pre>
     * manualSelector controls generation of pod labels and pod selectors.
     * Leave `manualSelector` unset unless you are certain what you are doing.
     * When false or unset, the system pick labels unique to this job
     * and appends those labels to the pod template.  When true,
     * the user is responsible for picking unique labels and specifying
     * the selector.  Failure to pick a unique label may cause this
     * and other jobs to not function correctly.  However, You may see
     * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
     * API.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
     * +optional
     * </pre>
     *
     * <code>optional bool manualSelector = 5;</code>
     */
    public boolean getManualSelector() {
      return manualSelector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 6;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     * <pre>
     * Describes the pod that will be created when executing a job.
     * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
     */
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <pre>
     * Describes the pod that will be created when executing a job.
     * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }
    /**
     * <pre>
     * Describes the pod that will be created when executing a job.
     * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }

    public static final int TTLSECONDSAFTERFINISHED_FIELD_NUMBER = 8;
    private int ttlSecondsAfterFinished_;
    /**
     * <pre>
     * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
     * execution (either Complete or Failed). If this field is set,
     * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
     * automatically deleted. When the Job is being deleted, its lifecycle
     * guarantees (e.g. finalizers) will be honored. If this field is unset,
     * the Job won't be automatically deleted. If this field is set to zero,
     * the Job becomes eligible to be deleted immediately after it finishes.
     * +optional
     * </pre>
     *
     * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
     */
    public boolean hasTtlSecondsAfterFinished() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <pre>
     * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
     * execution (either Complete or Failed). If this field is set,
     * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
     * automatically deleted. When the Job is being deleted, its lifecycle
     * guarantees (e.g. finalizers) will be honored. If this field is unset,
     * the Job won't be automatically deleted. If this field is set to zero,
     * the Job becomes eligible to be deleted immediately after it finishes.
     * +optional
     * </pre>
     *
     * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
     */
    public int getTtlSecondsAfterFinished() {
      return ttlSecondsAfterFinished_;
    }

    public static final int COMPLETIONMODE_FIELD_NUMBER = 9;
    private volatile java.lang.Object completionMode_;
    /**
     * <pre>
     * completionMode specifies how Pod completions are tracked. It can be
     * `NonIndexed` (default) or `Indexed`.
     * `NonIndexed` means that the Job is considered complete when there have
     * been .spec.completions successfully completed Pods. Each Pod completion is
     * homologous to each other.
     * `Indexed` means that the Pods of a
     * Job get an associated completion index from 0 to (.spec.completions - 1),
     * available in the annotation batch.kubernetes.io/job-completion-index.
     * The Job is considered complete when there is one successfully completed Pod
     * for each index.
     * When value is `Indexed`, .spec.completions must be specified and
     * `.spec.parallelism` must be less than or equal to 10^5.
     * In addition, The Pod name takes the form
     * `$(job-name)-$(index)-$(random-string)`,
     * the Pod hostname takes the form `$(job-name)-$(index)`.
     * More completion modes can be added in the future.
     * If the Job controller observes a mode that it doesn't recognize, which
     * is possible during upgrades due to version skew, the controller
     * skips updates for the Job.
     * +optional
     * </pre>
     *
     * <code>optional string completionMode = 9;</code>
     */
    public boolean hasCompletionMode() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <pre>
     * completionMode specifies how Pod completions are tracked. It can be
     * `NonIndexed` (default) or `Indexed`.
     * `NonIndexed` means that the Job is considered complete when there have
     * been .spec.completions successfully completed Pods. Each Pod completion is
     * homologous to each other.
     * `Indexed` means that the Pods of a
     * Job get an associated completion index from 0 to (.spec.completions - 1),
     * available in the annotation batch.kubernetes.io/job-completion-index.
     * The Job is considered complete when there is one successfully completed Pod
     * for each index.
     * When value is `Indexed`, .spec.completions must be specified and
     * `.spec.parallelism` must be less than or equal to 10^5.
     * In addition, The Pod name takes the form
     * `$(job-name)-$(index)-$(random-string)`,
     * the Pod hostname takes the form `$(job-name)-$(index)`.
     * More completion modes can be added in the future.
     * If the Job controller observes a mode that it doesn't recognize, which
     * is possible during upgrades due to version skew, the controller
     * skips updates for the Job.
     * +optional
     * </pre>
     *
     * <code>optional string completionMode = 9;</code>
     */
    public java.lang.String getCompletionMode() {
      java.lang.Object ref = completionMode_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          completionMode_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * completionMode specifies how Pod completions are tracked. It can be
     * `NonIndexed` (default) or `Indexed`.
     * `NonIndexed` means that the Job is considered complete when there have
     * been .spec.completions successfully completed Pods. Each Pod completion is
     * homologous to each other.
     * `Indexed` means that the Pods of a
     * Job get an associated completion index from 0 to (.spec.completions - 1),
     * available in the annotation batch.kubernetes.io/job-completion-index.
     * The Job is considered complete when there is one successfully completed Pod
     * for each index.
     * When value is `Indexed`, .spec.completions must be specified and
     * `.spec.parallelism` must be less than or equal to 10^5.
     * In addition, The Pod name takes the form
     * `$(job-name)-$(index)-$(random-string)`,
     * the Pod hostname takes the form `$(job-name)-$(index)`.
     * More completion modes can be added in the future.
     * If the Job controller observes a mode that it doesn't recognize, which
     * is possible during upgrades due to version skew, the controller
     * skips updates for the Job.
     * +optional
     * </pre>
     *
     * <code>optional string completionMode = 9;</code>
     */
    public com.google.protobuf.ByteString
        getCompletionModeBytes() {
      java.lang.Object ref = completionMode_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        completionMode_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SUSPEND_FIELD_NUMBER = 10;
    private boolean suspend_;
    /**
     * <pre>
     * suspend specifies whether the Job controller should create Pods or not. If
     * a Job is created with suspend set to true, no Pods are created by the Job
     * controller. If a Job is suspended after creation (i.e. the flag goes from
     * false to true), the Job controller will delete all active Pods associated
     * with this Job. Users must design their workload to gracefully handle this.
     * Suspending a Job will reset the StartTime field of the Job, effectively
     * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 10;</code>
     */
    public boolean hasSuspend() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <pre>
     * suspend specifies whether the Job controller should create Pods or not. If
     * a Job is created with suspend set to true, no Pods are created by the Job
     * controller. If a Job is suspended after creation (i.e. the flag goes from
     * false to true), the Job controller will delete all active Pods associated
     * with this Job. Users must design their workload to gracefully handle this.
     * Suspending a Job will reset the StartTime field of the Job, effectively
     * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
     * +optional
     * </pre>
     *
     * <code>optional bool suspend = 10;</code>
     */
    public boolean getSuspend() {
      return suspend_;
    }

    public static final int PODREPLACEMENTPOLICY_FIELD_NUMBER = 14;
    private volatile java.lang.Object podReplacementPolicy_;
    /**
     * <pre>
     * podReplacementPolicy specifies when to create replacement Pods.
     * Possible values are:
     * - TerminatingOrFailed means that we recreate pods
     *   when they are terminating (has a metadata.deletionTimestamp) or failed.
     * - Failed means to wait until a previously created Pod is fully terminated (has phase
     *   Failed or Succeeded) before creating a replacement Pod.
     * When using podFailurePolicy, Failed is the the only allowed value.
     * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
     * +optional
     * </pre>
     *
     * <code>optional string podReplacementPolicy = 14;</code>
     */
    public boolean hasPodReplacementPolicy() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <pre>
     * podReplacementPolicy specifies when to create replacement Pods.
     * Possible values are:
     * - TerminatingOrFailed means that we recreate pods
     *   when they are terminating (has a metadata.deletionTimestamp) or failed.
     * - Failed means to wait until a previously created Pod is fully terminated (has phase
     *   Failed or Succeeded) before creating a replacement Pod.
     * When using podFailurePolicy, Failed is the the only allowed value.
     * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
     * +optional
     * </pre>
     *
     * <code>optional string podReplacementPolicy = 14;</code>
     */
    public java.lang.String getPodReplacementPolicy() {
      java.lang.Object ref = podReplacementPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          podReplacementPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * podReplacementPolicy specifies when to create replacement Pods.
     * Possible values are:
     * - TerminatingOrFailed means that we recreate pods
     *   when they are terminating (has a metadata.deletionTimestamp) or failed.
     * - Failed means to wait until a previously created Pod is fully terminated (has phase
     *   Failed or Succeeded) before creating a replacement Pod.
     * When using podFailurePolicy, Failed is the the only allowed value.
     * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
     * +optional
     * </pre>
     *
     * <code>optional string podReplacementPolicy = 14;</code>
     */
    public com.google.protobuf.ByteString
        getPodReplacementPolicyBytes() {
      java.lang.Object ref = podReplacementPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        podReplacementPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MANAGEDBY_FIELD_NUMBER = 15;
    private volatile java.lang.Object managedBy_;
    /**
     * <pre>
     * ManagedBy field indicates the controller that manages a Job. The k8s Job
     * controller reconciles jobs which don't have this field at all or the field
     * value is the reserved string `kubernetes.io/job-controller`, but skips
     * reconciling Jobs with a custom value for this field.
     * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
     * all characters before the first "/" must be a valid subdomain as defined
     * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
     * characters as defined by RFC 3986. The value cannot exceed 63 characters.
     * This field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional string managedBy = 15;</code>
     */
    public boolean hasManagedBy() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <pre>
     * ManagedBy field indicates the controller that manages a Job. The k8s Job
     * controller reconciles jobs which don't have this field at all or the field
     * value is the reserved string `kubernetes.io/job-controller`, but skips
     * reconciling Jobs with a custom value for this field.
     * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
     * all characters before the first "/" must be a valid subdomain as defined
     * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
     * characters as defined by RFC 3986. The value cannot exceed 63 characters.
     * This field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional string managedBy = 15;</code>
     */
    public java.lang.String getManagedBy() {
      java.lang.Object ref = managedBy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          managedBy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * ManagedBy field indicates the controller that manages a Job. The k8s Job
     * controller reconciles jobs which don't have this field at all or the field
     * value is the reserved string `kubernetes.io/job-controller`, but skips
     * reconciling Jobs with a custom value for this field.
     * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
     * all characters before the first "/" must be a valid subdomain as defined
     * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
     * characters as defined by RFC 3986. The value cannot exceed 63 characters.
     * This field is immutable.
     * +optional
     * </pre>
     *
     * <code>optional string managedBy = 15;</code>
     */
    public com.google.protobuf.ByteString
        getManagedByBytes() {
      java.lang.Object ref = managedBy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        managedBy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, parallelism_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, completions_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt64(3, activeDeadlineSeconds_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(4, getSelector());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeBool(5, manualSelector_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeMessage(6, getTemplate());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(7, backoffLimit_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeInt32(8, ttlSecondsAfterFinished_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, completionMode_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeBool(10, suspend_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(11, getPodFailurePolicy());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(12, backoffLimitPerIndex_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(13, maxFailedIndexes_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, podReplacementPolicy_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 15, managedBy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(16, getSuccessPolicy());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, parallelism_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, completions_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, activeDeadlineSeconds_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getSelector());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, manualSelector_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getTemplate());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, backoffLimit_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, ttlSecondsAfterFinished_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, completionMode_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, suspend_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getPodFailurePolicy());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(12, backoffLimitPerIndex_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(13, maxFailedIndexes_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, podReplacementPolicy_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(15, managedBy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, getSuccessPolicy());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.JobSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.JobSpec other = (io.kubernetes.client.proto.V1Batch.JobSpec) obj;

      boolean result = true;
      result = result && (hasParallelism() == other.hasParallelism());
      if (hasParallelism()) {
        result = result && (getParallelism()
            == other.getParallelism());
      }
      result = result && (hasCompletions() == other.hasCompletions());
      if (hasCompletions()) {
        result = result && (getCompletions()
            == other.getCompletions());
      }
      result = result && (hasActiveDeadlineSeconds() == other.hasActiveDeadlineSeconds());
      if (hasActiveDeadlineSeconds()) {
        result = result && (getActiveDeadlineSeconds()
            == other.getActiveDeadlineSeconds());
      }
      result = result && (hasPodFailurePolicy() == other.hasPodFailurePolicy());
      if (hasPodFailurePolicy()) {
        result = result && getPodFailurePolicy()
            .equals(other.getPodFailurePolicy());
      }
      result = result && (hasSuccessPolicy() == other.hasSuccessPolicy());
      if (hasSuccessPolicy()) {
        result = result && getSuccessPolicy()
            .equals(other.getSuccessPolicy());
      }
      result = result && (hasBackoffLimit() == other.hasBackoffLimit());
      if (hasBackoffLimit()) {
        result = result && (getBackoffLimit()
            == other.getBackoffLimit());
      }
      result = result && (hasBackoffLimitPerIndex() == other.hasBackoffLimitPerIndex());
      if (hasBackoffLimitPerIndex()) {
        result = result && (getBackoffLimitPerIndex()
            == other.getBackoffLimitPerIndex());
      }
      result = result && (hasMaxFailedIndexes() == other.hasMaxFailedIndexes());
      if (hasMaxFailedIndexes()) {
        result = result && (getMaxFailedIndexes()
            == other.getMaxFailedIndexes());
      }
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector()
            .equals(other.getSelector());
      }
      result = result && (hasManualSelector() == other.hasManualSelector());
      if (hasManualSelector()) {
        result = result && (getManualSelector()
            == other.getManualSelector());
      }
      result = result && (hasTemplate() == other.hasTemplate());
      if (hasTemplate()) {
        result = result && getTemplate()
            .equals(other.getTemplate());
      }
      result = result && (hasTtlSecondsAfterFinished() == other.hasTtlSecondsAfterFinished());
      if (hasTtlSecondsAfterFinished()) {
        result = result && (getTtlSecondsAfterFinished()
            == other.getTtlSecondsAfterFinished());
      }
      result = result && (hasCompletionMode() == other.hasCompletionMode());
      if (hasCompletionMode()) {
        result = result && getCompletionMode()
            .equals(other.getCompletionMode());
      }
      result = result && (hasSuspend() == other.hasSuspend());
      if (hasSuspend()) {
        result = result && (getSuspend()
            == other.getSuspend());
      }
      result = result && (hasPodReplacementPolicy() == other.hasPodReplacementPolicy());
      if (hasPodReplacementPolicy()) {
        result = result && getPodReplacementPolicy()
            .equals(other.getPodReplacementPolicy());
      }
      result = result && (hasManagedBy() == other.hasManagedBy());
      if (hasManagedBy()) {
        result = result && getManagedBy()
            .equals(other.getManagedBy());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParallelism()) {
        hash = (37 * hash) + PARALLELISM_FIELD_NUMBER;
        hash = (53 * hash) + getParallelism();
      }
      if (hasCompletions()) {
        hash = (37 * hash) + COMPLETIONS_FIELD_NUMBER;
        hash = (53 * hash) + getCompletions();
      }
      if (hasActiveDeadlineSeconds()) {
        hash = (37 * hash) + ACTIVEDEADLINESECONDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getActiveDeadlineSeconds());
      }
      if (hasPodFailurePolicy()) {
        hash = (37 * hash) + PODFAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getPodFailurePolicy().hashCode();
      }
      if (hasSuccessPolicy()) {
        hash = (37 * hash) + SUCCESSPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getSuccessPolicy().hashCode();
      }
      if (hasBackoffLimit()) {
        hash = (37 * hash) + BACKOFFLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getBackoffLimit();
      }
      if (hasBackoffLimitPerIndex()) {
        hash = (37 * hash) + BACKOFFLIMITPERINDEX_FIELD_NUMBER;
        hash = (53 * hash) + getBackoffLimitPerIndex();
      }
      if (hasMaxFailedIndexes()) {
        hash = (37 * hash) + MAXFAILEDINDEXES_FIELD_NUMBER;
        hash = (53 * hash) + getMaxFailedIndexes();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasManualSelector()) {
        hash = (37 * hash) + MANUALSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getManualSelector());
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (hasTtlSecondsAfterFinished()) {
        hash = (37 * hash) + TTLSECONDSAFTERFINISHED_FIELD_NUMBER;
        hash = (53 * hash) + getTtlSecondsAfterFinished();
      }
      if (hasCompletionMode()) {
        hash = (37 * hash) + COMPLETIONMODE_FIELD_NUMBER;
        hash = (53 * hash) + getCompletionMode().hashCode();
      }
      if (hasSuspend()) {
        hash = (37 * hash) + SUSPEND_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSuspend());
      }
      if (hasPodReplacementPolicy()) {
        hash = (37 * hash) + PODREPLACEMENTPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getPodReplacementPolicy().hashCode();
      }
      if (hasManagedBy()) {
        hash = (37 * hash) + MANAGEDBY_FIELD_NUMBER;
        hash = (53 * hash) + getManagedBy().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.JobSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * JobSpec describes how the job execution will look like.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.JobSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.JobSpec)
        io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.JobSpec.class, io.kubernetes.client.proto.V1Batch.JobSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.JobSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getPodFailurePolicyFieldBuilder();
          getSuccessPolicyFieldBuilder();
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        parallelism_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        completions_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        activeDeadlineSeconds_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (podFailurePolicyBuilder_ == null) {
          podFailurePolicy_ = null;
        } else {
          podFailurePolicyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        if (successPolicyBuilder_ == null) {
          successPolicy_ = null;
        } else {
          successPolicyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        backoffLimit_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        backoffLimitPerIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000040);
        maxFailedIndexes_ = 0;
        bitField0_ = (bitField0_ & ~0x00000080);
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        manualSelector_ = false;
        bitField0_ = (bitField0_ & ~0x00000200);
        if (templateBuilder_ == null) {
          template_ = null;
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        ttlSecondsAfterFinished_ = 0;
        bitField0_ = (bitField0_ & ~0x00000800);
        completionMode_ = "";
        bitField0_ = (bitField0_ & ~0x00001000);
        suspend_ = false;
        bitField0_ = (bitField0_ & ~0x00002000);
        podReplacementPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00004000);
        managedBy_ = "";
        bitField0_ = (bitField0_ & ~0x00008000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobSpec build() {
        io.kubernetes.client.proto.V1Batch.JobSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobSpec buildPartial() {
        io.kubernetes.client.proto.V1Batch.JobSpec result = new io.kubernetes.client.proto.V1Batch.JobSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.parallelism_ = parallelism_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.completions_ = completions_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.activeDeadlineSeconds_ = activeDeadlineSeconds_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (podFailurePolicyBuilder_ == null) {
          result.podFailurePolicy_ = podFailurePolicy_;
        } else {
          result.podFailurePolicy_ = podFailurePolicyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        if (successPolicyBuilder_ == null) {
          result.successPolicy_ = successPolicy_;
        } else {
          result.successPolicy_ = successPolicyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.backoffLimit_ = backoffLimit_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.backoffLimitPerIndex_ = backoffLimitPerIndex_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.maxFailedIndexes_ = maxFailedIndexes_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.manualSelector_ = manualSelector_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        if (templateBuilder_ == null) {
          result.template_ = template_;
        } else {
          result.template_ = templateBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.ttlSecondsAfterFinished_ = ttlSecondsAfterFinished_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.completionMode_ = completionMode_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.suspend_ = suspend_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.podReplacementPolicy_ = podReplacementPolicy_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.managedBy_ = managedBy_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.JobSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.JobSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.JobSpec other) {
        if (other == io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance()) return this;
        if (other.hasParallelism()) {
          setParallelism(other.getParallelism());
        }
        if (other.hasCompletions()) {
          setCompletions(other.getCompletions());
        }
        if (other.hasActiveDeadlineSeconds()) {
          setActiveDeadlineSeconds(other.getActiveDeadlineSeconds());
        }
        if (other.hasPodFailurePolicy()) {
          mergePodFailurePolicy(other.getPodFailurePolicy());
        }
        if (other.hasSuccessPolicy()) {
          mergeSuccessPolicy(other.getSuccessPolicy());
        }
        if (other.hasBackoffLimit()) {
          setBackoffLimit(other.getBackoffLimit());
        }
        if (other.hasBackoffLimitPerIndex()) {
          setBackoffLimitPerIndex(other.getBackoffLimitPerIndex());
        }
        if (other.hasMaxFailedIndexes()) {
          setMaxFailedIndexes(other.getMaxFailedIndexes());
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasManualSelector()) {
          setManualSelector(other.getManualSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (other.hasTtlSecondsAfterFinished()) {
          setTtlSecondsAfterFinished(other.getTtlSecondsAfterFinished());
        }
        if (other.hasCompletionMode()) {
          bitField0_ |= 0x00001000;
          completionMode_ = other.completionMode_;
          onChanged();
        }
        if (other.hasSuspend()) {
          setSuspend(other.getSuspend());
        }
        if (other.hasPodReplacementPolicy()) {
          bitField0_ |= 0x00004000;
          podReplacementPolicy_ = other.podReplacementPolicy_;
          onChanged();
        }
        if (other.hasManagedBy()) {
          bitField0_ |= 0x00008000;
          managedBy_ = other.managedBy_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.JobSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.JobSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int parallelism_ ;
      /**
       * <pre>
       * Specifies the maximum desired number of pods the job should
       * run at any given time. The actual number of pods running in steady state will
       * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
       * i.e. when the work left to do is less than max parallelism.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 parallelism = 1;</code>
       */
      public boolean hasParallelism() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Specifies the maximum desired number of pods the job should
       * run at any given time. The actual number of pods running in steady state will
       * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
       * i.e. when the work left to do is less than max parallelism.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 parallelism = 1;</code>
       */
      public int getParallelism() {
        return parallelism_;
      }
      /**
       * <pre>
       * Specifies the maximum desired number of pods the job should
       * run at any given time. The actual number of pods running in steady state will
       * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
       * i.e. when the work left to do is less than max parallelism.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 parallelism = 1;</code>
       */
      public Builder setParallelism(int value) {
        bitField0_ |= 0x00000001;
        parallelism_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the maximum desired number of pods the job should
       * run at any given time. The actual number of pods running in steady state will
       * be less than this number when ((.spec.completions - .status.successful) &lt; .spec.parallelism),
       * i.e. when the work left to do is less than max parallelism.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 parallelism = 1;</code>
       */
      public Builder clearParallelism() {
        bitField0_ = (bitField0_ & ~0x00000001);
        parallelism_ = 0;
        onChanged();
        return this;
      }

      private int completions_ ;
      /**
       * <pre>
       * Specifies the desired number of successfully finished pods the
       * job should be run with.  Setting to null means that the success of any
       * pod signals the success of all pods, and allows parallelism to have any positive
       * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
       * pod signals the success of the job.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 completions = 2;</code>
       */
      public boolean hasCompletions() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specifies the desired number of successfully finished pods the
       * job should be run with.  Setting to null means that the success of any
       * pod signals the success of all pods, and allows parallelism to have any positive
       * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
       * pod signals the success of the job.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 completions = 2;</code>
       */
      public int getCompletions() {
        return completions_;
      }
      /**
       * <pre>
       * Specifies the desired number of successfully finished pods the
       * job should be run with.  Setting to null means that the success of any
       * pod signals the success of all pods, and allows parallelism to have any positive
       * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
       * pod signals the success of the job.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 completions = 2;</code>
       */
      public Builder setCompletions(int value) {
        bitField0_ |= 0x00000002;
        completions_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the desired number of successfully finished pods the
       * job should be run with.  Setting to null means that the success of any
       * pod signals the success of all pods, and allows parallelism to have any positive
       * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
       * pod signals the success of the job.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * </pre>
       *
       * <code>optional int32 completions = 2;</code>
       */
      public Builder clearCompletions() {
        bitField0_ = (bitField0_ & ~0x00000002);
        completions_ = 0;
        onChanged();
        return this;
      }

      private long activeDeadlineSeconds_ ;
      /**
       * <pre>
       * Specifies the duration in seconds relative to the startTime that the job
       * may be continuously active before the system tries to terminate it; value
       * must be positive integer. If a Job is suspended (at creation or through an
       * update), this timer will effectively be stopped and reset when the Job is
       * resumed again.
       * +optional
       * </pre>
       *
       * <code>optional int64 activeDeadlineSeconds = 3;</code>
       */
      public boolean hasActiveDeadlineSeconds() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Specifies the duration in seconds relative to the startTime that the job
       * may be continuously active before the system tries to terminate it; value
       * must be positive integer. If a Job is suspended (at creation or through an
       * update), this timer will effectively be stopped and reset when the Job is
       * resumed again.
       * +optional
       * </pre>
       *
       * <code>optional int64 activeDeadlineSeconds = 3;</code>
       */
      public long getActiveDeadlineSeconds() {
        return activeDeadlineSeconds_;
      }
      /**
       * <pre>
       * Specifies the duration in seconds relative to the startTime that the job
       * may be continuously active before the system tries to terminate it; value
       * must be positive integer. If a Job is suspended (at creation or through an
       * update), this timer will effectively be stopped and reset when the Job is
       * resumed again.
       * +optional
       * </pre>
       *
       * <code>optional int64 activeDeadlineSeconds = 3;</code>
       */
      public Builder setActiveDeadlineSeconds(long value) {
        bitField0_ |= 0x00000004;
        activeDeadlineSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the duration in seconds relative to the startTime that the job
       * may be continuously active before the system tries to terminate it; value
       * must be positive integer. If a Job is suspended (at creation or through an
       * update), this timer will effectively be stopped and reset when the Job is
       * resumed again.
       * +optional
       * </pre>
       *
       * <code>optional int64 activeDeadlineSeconds = 3;</code>
       */
      public Builder clearActiveDeadlineSeconds() {
        bitField0_ = (bitField0_ & ~0x00000004);
        activeDeadlineSeconds_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Batch.PodFailurePolicy podFailurePolicy_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicy, io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder> podFailurePolicyBuilder_;
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public boolean hasPodFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicy getPodFailurePolicy() {
        if (podFailurePolicyBuilder_ == null) {
          return podFailurePolicy_ == null ? io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance() : podFailurePolicy_;
        } else {
          return podFailurePolicyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public Builder setPodFailurePolicy(io.kubernetes.client.proto.V1Batch.PodFailurePolicy value) {
        if (podFailurePolicyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          podFailurePolicy_ = value;
          onChanged();
        } else {
          podFailurePolicyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public Builder setPodFailurePolicy(
          io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder builderForValue) {
        if (podFailurePolicyBuilder_ == null) {
          podFailurePolicy_ = builderForValue.build();
          onChanged();
        } else {
          podFailurePolicyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public Builder mergePodFailurePolicy(io.kubernetes.client.proto.V1Batch.PodFailurePolicy value) {
        if (podFailurePolicyBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008) &&
              podFailurePolicy_ != null &&
              podFailurePolicy_ != io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance()) {
            podFailurePolicy_ =
              io.kubernetes.client.proto.V1Batch.PodFailurePolicy.newBuilder(podFailurePolicy_).mergeFrom(value).buildPartial();
          } else {
            podFailurePolicy_ = value;
          }
          onChanged();
        } else {
          podFailurePolicyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public Builder clearPodFailurePolicy() {
        if (podFailurePolicyBuilder_ == null) {
          podFailurePolicy_ = null;
          onChanged();
        } else {
          podFailurePolicyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder getPodFailurePolicyBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getPodFailurePolicyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder getPodFailurePolicyOrBuilder() {
        if (podFailurePolicyBuilder_ != null) {
          return podFailurePolicyBuilder_.getMessageOrBuilder();
        } else {
          return podFailurePolicy_ == null ?
              io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance() : podFailurePolicy_;
        }
      }
      /**
       * <pre>
       * Specifies the policy of handling failed pods. In particular, it allows to
       * specify the set of actions and conditions which need to be
       * satisfied to take the associated action.
       * If empty, the default behaviour applies - the counter of failed pods,
       * represented by the jobs's .status.failed field, is incremented and it is
       * checked against the backoffLimit. This field cannot be used in combination
       * with restartPolicy=OnFailure.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicy podFailurePolicy = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicy, io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder> 
          getPodFailurePolicyFieldBuilder() {
        if (podFailurePolicyBuilder_ == null) {
          podFailurePolicyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.PodFailurePolicy, io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder>(
                  getPodFailurePolicy(),
                  getParentForChildren(),
                  isClean());
          podFailurePolicy_ = null;
        }
        return podFailurePolicyBuilder_;
      }

      private io.kubernetes.client.proto.V1Batch.SuccessPolicy successPolicy_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.SuccessPolicy, io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder, io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder> successPolicyBuilder_;
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public boolean hasSuccessPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicy getSuccessPolicy() {
        if (successPolicyBuilder_ == null) {
          return successPolicy_ == null ? io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance() : successPolicy_;
        } else {
          return successPolicyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public Builder setSuccessPolicy(io.kubernetes.client.proto.V1Batch.SuccessPolicy value) {
        if (successPolicyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          successPolicy_ = value;
          onChanged();
        } else {
          successPolicyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public Builder setSuccessPolicy(
          io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder builderForValue) {
        if (successPolicyBuilder_ == null) {
          successPolicy_ = builderForValue.build();
          onChanged();
        } else {
          successPolicyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public Builder mergeSuccessPolicy(io.kubernetes.client.proto.V1Batch.SuccessPolicy value) {
        if (successPolicyBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010) &&
              successPolicy_ != null &&
              successPolicy_ != io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance()) {
            successPolicy_ =
              io.kubernetes.client.proto.V1Batch.SuccessPolicy.newBuilder(successPolicy_).mergeFrom(value).buildPartial();
          } else {
            successPolicy_ = value;
          }
          onChanged();
        } else {
          successPolicyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public Builder clearSuccessPolicy() {
        if (successPolicyBuilder_ == null) {
          successPolicy_ = null;
          onChanged();
        } else {
          successPolicyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder getSuccessPolicyBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getSuccessPolicyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder getSuccessPolicyOrBuilder() {
        if (successPolicyBuilder_ != null) {
          return successPolicyBuilder_.getMessageOrBuilder();
        } else {
          return successPolicy_ == null ?
              io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance() : successPolicy_;
        }
      }
      /**
       * <pre>
       * successPolicy specifies the policy when the Job can be declared as succeeded.
       * If empty, the default behavior applies - the Job is declared as succeeded
       * only when the number of succeeded pods equals to the completions.
       * When the field is specified, it must be immutable and works only for the Indexed Jobs.
       * Once the Job meets the SuccessPolicy, the lingering pods are terminated.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.SuccessPolicy successPolicy = 16;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.SuccessPolicy, io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder, io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder> 
          getSuccessPolicyFieldBuilder() {
        if (successPolicyBuilder_ == null) {
          successPolicyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.SuccessPolicy, io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder, io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder>(
                  getSuccessPolicy(),
                  getParentForChildren(),
                  isClean());
          successPolicy_ = null;
        }
        return successPolicyBuilder_;
      }

      private int backoffLimit_ ;
      /**
       * <pre>
       * Specifies the number of retries before marking this job failed.
       * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
       * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimit = 7;</code>
       */
      public boolean hasBackoffLimit() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * Specifies the number of retries before marking this job failed.
       * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
       * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimit = 7;</code>
       */
      public int getBackoffLimit() {
        return backoffLimit_;
      }
      /**
       * <pre>
       * Specifies the number of retries before marking this job failed.
       * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
       * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimit = 7;</code>
       */
      public Builder setBackoffLimit(int value) {
        bitField0_ |= 0x00000020;
        backoffLimit_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the number of retries before marking this job failed.
       * Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified.
       * When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimit = 7;</code>
       */
      public Builder clearBackoffLimit() {
        bitField0_ = (bitField0_ & ~0x00000020);
        backoffLimit_ = 0;
        onChanged();
        return this;
      }

      private int backoffLimitPerIndex_ ;
      /**
       * <pre>
       * Specifies the limit for the number of retries within an
       * index before marking this index as failed. When enabled the number of
       * failures per index is kept in the pod's
       * batch.kubernetes.io/job-index-failure-count annotation. It can only
       * be set when Job's completionMode=Indexed, and the Pod's restart
       * policy is Never. The field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimitPerIndex = 12;</code>
       */
      public boolean hasBackoffLimitPerIndex() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * Specifies the limit for the number of retries within an
       * index before marking this index as failed. When enabled the number of
       * failures per index is kept in the pod's
       * batch.kubernetes.io/job-index-failure-count annotation. It can only
       * be set when Job's completionMode=Indexed, and the Pod's restart
       * policy is Never. The field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimitPerIndex = 12;</code>
       */
      public int getBackoffLimitPerIndex() {
        return backoffLimitPerIndex_;
      }
      /**
       * <pre>
       * Specifies the limit for the number of retries within an
       * index before marking this index as failed. When enabled the number of
       * failures per index is kept in the pod's
       * batch.kubernetes.io/job-index-failure-count annotation. It can only
       * be set when Job's completionMode=Indexed, and the Pod's restart
       * policy is Never. The field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimitPerIndex = 12;</code>
       */
      public Builder setBackoffLimitPerIndex(int value) {
        bitField0_ |= 0x00000040;
        backoffLimitPerIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the limit for the number of retries within an
       * index before marking this index as failed. When enabled the number of
       * failures per index is kept in the pod's
       * batch.kubernetes.io/job-index-failure-count annotation. It can only
       * be set when Job's completionMode=Indexed, and the Pod's restart
       * policy is Never. The field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional int32 backoffLimitPerIndex = 12;</code>
       */
      public Builder clearBackoffLimitPerIndex() {
        bitField0_ = (bitField0_ & ~0x00000040);
        backoffLimitPerIndex_ = 0;
        onChanged();
        return this;
      }

      private int maxFailedIndexes_ ;
      /**
       * <pre>
       * Specifies the maximal number of failed indexes before marking the Job as
       * failed, when backoffLimitPerIndex is set. Once the number of failed
       * indexes exceeds this number the entire Job is marked as Failed and its
       * execution is terminated. When left as null the job continues execution of
       * all of its indexes and is marked with the `Complete` Job condition.
       * It can only be specified when backoffLimitPerIndex is set.
       * It can be null or up to completions. It is required and must be
       * less than or equal to 10^4 when is completions greater than 10^5.
       * +optional
       * </pre>
       *
       * <code>optional int32 maxFailedIndexes = 13;</code>
       */
      public boolean hasMaxFailedIndexes() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * Specifies the maximal number of failed indexes before marking the Job as
       * failed, when backoffLimitPerIndex is set. Once the number of failed
       * indexes exceeds this number the entire Job is marked as Failed and its
       * execution is terminated. When left as null the job continues execution of
       * all of its indexes and is marked with the `Complete` Job condition.
       * It can only be specified when backoffLimitPerIndex is set.
       * It can be null or up to completions. It is required and must be
       * less than or equal to 10^4 when is completions greater than 10^5.
       * +optional
       * </pre>
       *
       * <code>optional int32 maxFailedIndexes = 13;</code>
       */
      public int getMaxFailedIndexes() {
        return maxFailedIndexes_;
      }
      /**
       * <pre>
       * Specifies the maximal number of failed indexes before marking the Job as
       * failed, when backoffLimitPerIndex is set. Once the number of failed
       * indexes exceeds this number the entire Job is marked as Failed and its
       * execution is terminated. When left as null the job continues execution of
       * all of its indexes and is marked with the `Complete` Job condition.
       * It can only be specified when backoffLimitPerIndex is set.
       * It can be null or up to completions. It is required and must be
       * less than or equal to 10^4 when is completions greater than 10^5.
       * +optional
       * </pre>
       *
       * <code>optional int32 maxFailedIndexes = 13;</code>
       */
      public Builder setMaxFailedIndexes(int value) {
        bitField0_ |= 0x00000080;
        maxFailedIndexes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the maximal number of failed indexes before marking the Job as
       * failed, when backoffLimitPerIndex is set. Once the number of failed
       * indexes exceeds this number the entire Job is marked as Failed and its
       * execution is terminated. When left as null the job continues execution of
       * all of its indexes and is marked with the `Complete` Job condition.
       * It can only be specified when backoffLimitPerIndex is set.
       * It can be null or up to completions. It is required and must be
       * less than or equal to 10^4 when is completions greater than 10^5.
       * +optional
       * </pre>
       *
       * <code>optional int32 maxFailedIndexes = 13;</code>
       */
      public Builder clearMaxFailedIndexes() {
        bitField0_ = (bitField0_ & ~0x00000080);
        maxFailedIndexes_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000100) == 0x00000100) &&
              selector_ != null &&
              selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_).mergeFrom(value).buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * A label query over pods that should match the pod count.
       * Normally, the system sets this field for you.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private boolean manualSelector_ ;
      /**
       * <pre>
       * manualSelector controls generation of pod labels and pod selectors.
       * Leave `manualSelector` unset unless you are certain what you are doing.
       * When false or unset, the system pick labels unique to this job
       * and appends those labels to the pod template.  When true,
       * the user is responsible for picking unique labels and specifying
       * the selector.  Failure to pick a unique label may cause this
       * and other jobs to not function correctly.  However, You may see
       * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
       * API.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
       * +optional
       * </pre>
       *
       * <code>optional bool manualSelector = 5;</code>
       */
      public boolean hasManualSelector() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <pre>
       * manualSelector controls generation of pod labels and pod selectors.
       * Leave `manualSelector` unset unless you are certain what you are doing.
       * When false or unset, the system pick labels unique to this job
       * and appends those labels to the pod template.  When true,
       * the user is responsible for picking unique labels and specifying
       * the selector.  Failure to pick a unique label may cause this
       * and other jobs to not function correctly.  However, You may see
       * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
       * API.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
       * +optional
       * </pre>
       *
       * <code>optional bool manualSelector = 5;</code>
       */
      public boolean getManualSelector() {
        return manualSelector_;
      }
      /**
       * <pre>
       * manualSelector controls generation of pod labels and pod selectors.
       * Leave `manualSelector` unset unless you are certain what you are doing.
       * When false or unset, the system pick labels unique to this job
       * and appends those labels to the pod template.  When true,
       * the user is responsible for picking unique labels and specifying
       * the selector.  Failure to pick a unique label may cause this
       * and other jobs to not function correctly.  However, You may see
       * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
       * API.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
       * +optional
       * </pre>
       *
       * <code>optional bool manualSelector = 5;</code>
       */
      public Builder setManualSelector(boolean value) {
        bitField0_ |= 0x00000200;
        manualSelector_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * manualSelector controls generation of pod labels and pod selectors.
       * Leave `manualSelector` unset unless you are certain what you are doing.
       * When false or unset, the system pick labels unique to this job
       * and appends those labels to the pod template.  When true,
       * the user is responsible for picking unique labels and specifying
       * the selector.  Failure to pick a unique label may cause this
       * and other jobs to not function correctly.  However, You may see
       * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
       * API.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
       * +optional
       * </pre>
       *
       * <code>optional bool manualSelector = 5;</code>
       */
      public Builder clearManualSelector() {
        bitField0_ = (bitField0_ & ~0x00000200);
        manualSelector_ = false;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> templateBuilder_;
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
          onChanged();
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
          onChanged();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000400) == 0x00000400) &&
              template_ != null &&
              template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            template_ =
              io.kubernetes.client.proto.V1.PodTemplateSpec.newBuilder(template_).mergeFrom(value).buildPartial();
          } else {
            template_ = value;
          }
          onChanged();
        } else {
          templateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public Builder clearTemplate() {
        if (templateBuilder_ == null) {
          template_ = null;
          onChanged();
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null ?
              io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        }
      }
      /**
       * <pre>
       * Describes the pod that will be created when executing a job.
       * The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> 
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(),
                  getParentForChildren(),
                  isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private int ttlSecondsAfterFinished_ ;
      /**
       * <pre>
       * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
       * execution (either Complete or Failed). If this field is set,
       * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
       * automatically deleted. When the Job is being deleted, its lifecycle
       * guarantees (e.g. finalizers) will be honored. If this field is unset,
       * the Job won't be automatically deleted. If this field is set to zero,
       * the Job becomes eligible to be deleted immediately after it finishes.
       * +optional
       * </pre>
       *
       * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
       */
      public boolean hasTtlSecondsAfterFinished() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <pre>
       * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
       * execution (either Complete or Failed). If this field is set,
       * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
       * automatically deleted. When the Job is being deleted, its lifecycle
       * guarantees (e.g. finalizers) will be honored. If this field is unset,
       * the Job won't be automatically deleted. If this field is set to zero,
       * the Job becomes eligible to be deleted immediately after it finishes.
       * +optional
       * </pre>
       *
       * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
       */
      public int getTtlSecondsAfterFinished() {
        return ttlSecondsAfterFinished_;
      }
      /**
       * <pre>
       * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
       * execution (either Complete or Failed). If this field is set,
       * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
       * automatically deleted. When the Job is being deleted, its lifecycle
       * guarantees (e.g. finalizers) will be honored. If this field is unset,
       * the Job won't be automatically deleted. If this field is set to zero,
       * the Job becomes eligible to be deleted immediately after it finishes.
       * +optional
       * </pre>
       *
       * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
       */
      public Builder setTtlSecondsAfterFinished(int value) {
        bitField0_ |= 0x00000800;
        ttlSecondsAfterFinished_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
       * execution (either Complete or Failed). If this field is set,
       * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
       * automatically deleted. When the Job is being deleted, its lifecycle
       * guarantees (e.g. finalizers) will be honored. If this field is unset,
       * the Job won't be automatically deleted. If this field is set to zero,
       * the Job becomes eligible to be deleted immediately after it finishes.
       * +optional
       * </pre>
       *
       * <code>optional int32 ttlSecondsAfterFinished = 8;</code>
       */
      public Builder clearTtlSecondsAfterFinished() {
        bitField0_ = (bitField0_ & ~0x00000800);
        ttlSecondsAfterFinished_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object completionMode_ = "";
      /**
       * <pre>
       * completionMode specifies how Pod completions are tracked. It can be
       * `NonIndexed` (default) or `Indexed`.
       * `NonIndexed` means that the Job is considered complete when there have
       * been .spec.completions successfully completed Pods. Each Pod completion is
       * homologous to each other.
       * `Indexed` means that the Pods of a
       * Job get an associated completion index from 0 to (.spec.completions - 1),
       * available in the annotation batch.kubernetes.io/job-completion-index.
       * The Job is considered complete when there is one successfully completed Pod
       * for each index.
       * When value is `Indexed`, .spec.completions must be specified and
       * `.spec.parallelism` must be less than or equal to 10^5.
       * In addition, The Pod name takes the form
       * `$(job-name)-$(index)-$(random-string)`,
       * the Pod hostname takes the form `$(job-name)-$(index)`.
       * More completion modes can be added in the future.
       * If the Job controller observes a mode that it doesn't recognize, which
       * is possible during upgrades due to version skew, the controller
       * skips updates for the Job.
       * +optional
       * </pre>
       *
       * <code>optional string completionMode = 9;</code>
       */
      public boolean hasCompletionMode() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <pre>
       * completionMode specifies how Pod completions are tracked. It can be
       * `NonIndexed` (default) or `Indexed`.
       * `NonIndexed` means that the Job is considered complete when there have
       * been .spec.completions successfully completed Pods. Each Pod completion is
       * homologous to each other.
       * `Indexed` means that the Pods of a
       * Job get an associated completion index from 0 to (.spec.completions - 1),
       * available in the annotation batch.kubernetes.io/job-completion-index.
       * The Job is considered complete when there is one successfully completed Pod
       * for each index.
       * When value is `Indexed`, .spec.completions must be specified and
       * `.spec.parallelism` must be less than or equal to 10^5.
       * In addition, The Pod name takes the form
       * `$(job-name)-$(index)-$(random-string)`,
       * the Pod hostname takes the form `$(job-name)-$(index)`.
       * More completion modes can be added in the future.
       * If the Job controller observes a mode that it doesn't recognize, which
       * is possible during upgrades due to version skew, the controller
       * skips updates for the Job.
       * +optional
       * </pre>
       *
       * <code>optional string completionMode = 9;</code>
       */
      public java.lang.String getCompletionMode() {
        java.lang.Object ref = completionMode_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            completionMode_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * completionMode specifies how Pod completions are tracked. It can be
       * `NonIndexed` (default) or `Indexed`.
       * `NonIndexed` means that the Job is considered complete when there have
       * been .spec.completions successfully completed Pods. Each Pod completion is
       * homologous to each other.
       * `Indexed` means that the Pods of a
       * Job get an associated completion index from 0 to (.spec.completions - 1),
       * available in the annotation batch.kubernetes.io/job-completion-index.
       * The Job is considered complete when there is one successfully completed Pod
       * for each index.
       * When value is `Indexed`, .spec.completions must be specified and
       * `.spec.parallelism` must be less than or equal to 10^5.
       * In addition, The Pod name takes the form
       * `$(job-name)-$(index)-$(random-string)`,
       * the Pod hostname takes the form `$(job-name)-$(index)`.
       * More completion modes can be added in the future.
       * If the Job controller observes a mode that it doesn't recognize, which
       * is possible during upgrades due to version skew, the controller
       * skips updates for the Job.
       * +optional
       * </pre>
       *
       * <code>optional string completionMode = 9;</code>
       */
      public com.google.protobuf.ByteString
          getCompletionModeBytes() {
        java.lang.Object ref = completionMode_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          completionMode_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * completionMode specifies how Pod completions are tracked. It can be
       * `NonIndexed` (default) or `Indexed`.
       * `NonIndexed` means that the Job is considered complete when there have
       * been .spec.completions successfully completed Pods. Each Pod completion is
       * homologous to each other.
       * `Indexed` means that the Pods of a
       * Job get an associated completion index from 0 to (.spec.completions - 1),
       * available in the annotation batch.kubernetes.io/job-completion-index.
       * The Job is considered complete when there is one successfully completed Pod
       * for each index.
       * When value is `Indexed`, .spec.completions must be specified and
       * `.spec.parallelism` must be less than or equal to 10^5.
       * In addition, The Pod name takes the form
       * `$(job-name)-$(index)-$(random-string)`,
       * the Pod hostname takes the form `$(job-name)-$(index)`.
       * More completion modes can be added in the future.
       * If the Job controller observes a mode that it doesn't recognize, which
       * is possible during upgrades due to version skew, the controller
       * skips updates for the Job.
       * +optional
       * </pre>
       *
       * <code>optional string completionMode = 9;</code>
       */
      public Builder setCompletionMode(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00001000;
        completionMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * completionMode specifies how Pod completions are tracked. It can be
       * `NonIndexed` (default) or `Indexed`.
       * `NonIndexed` means that the Job is considered complete when there have
       * been .spec.completions successfully completed Pods. Each Pod completion is
       * homologous to each other.
       * `Indexed` means that the Pods of a
       * Job get an associated completion index from 0 to (.spec.completions - 1),
       * available in the annotation batch.kubernetes.io/job-completion-index.
       * The Job is considered complete when there is one successfully completed Pod
       * for each index.
       * When value is `Indexed`, .spec.completions must be specified and
       * `.spec.parallelism` must be less than or equal to 10^5.
       * In addition, The Pod name takes the form
       * `$(job-name)-$(index)-$(random-string)`,
       * the Pod hostname takes the form `$(job-name)-$(index)`.
       * More completion modes can be added in the future.
       * If the Job controller observes a mode that it doesn't recognize, which
       * is possible during upgrades due to version skew, the controller
       * skips updates for the Job.
       * +optional
       * </pre>
       *
       * <code>optional string completionMode = 9;</code>
       */
      public Builder clearCompletionMode() {
        bitField0_ = (bitField0_ & ~0x00001000);
        completionMode_ = getDefaultInstance().getCompletionMode();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * completionMode specifies how Pod completions are tracked. It can be
       * `NonIndexed` (default) or `Indexed`.
       * `NonIndexed` means that the Job is considered complete when there have
       * been .spec.completions successfully completed Pods. Each Pod completion is
       * homologous to each other.
       * `Indexed` means that the Pods of a
       * Job get an associated completion index from 0 to (.spec.completions - 1),
       * available in the annotation batch.kubernetes.io/job-completion-index.
       * The Job is considered complete when there is one successfully completed Pod
       * for each index.
       * When value is `Indexed`, .spec.completions must be specified and
       * `.spec.parallelism` must be less than or equal to 10^5.
       * In addition, The Pod name takes the form
       * `$(job-name)-$(index)-$(random-string)`,
       * the Pod hostname takes the form `$(job-name)-$(index)`.
       * More completion modes can be added in the future.
       * If the Job controller observes a mode that it doesn't recognize, which
       * is possible during upgrades due to version skew, the controller
       * skips updates for the Job.
       * +optional
       * </pre>
       *
       * <code>optional string completionMode = 9;</code>
       */
      public Builder setCompletionModeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00001000;
        completionMode_ = value;
        onChanged();
        return this;
      }

      private boolean suspend_ ;
      /**
       * <pre>
       * suspend specifies whether the Job controller should create Pods or not. If
       * a Job is created with suspend set to true, no Pods are created by the Job
       * controller. If a Job is suspended after creation (i.e. the flag goes from
       * false to true), the Job controller will delete all active Pods associated
       * with this Job. Users must design their workload to gracefully handle this.
       * Suspending a Job will reset the StartTime field of the Job, effectively
       * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 10;</code>
       */
      public boolean hasSuspend() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <pre>
       * suspend specifies whether the Job controller should create Pods or not. If
       * a Job is created with suspend set to true, no Pods are created by the Job
       * controller. If a Job is suspended after creation (i.e. the flag goes from
       * false to true), the Job controller will delete all active Pods associated
       * with this Job. Users must design their workload to gracefully handle this.
       * Suspending a Job will reset the StartTime field of the Job, effectively
       * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 10;</code>
       */
      public boolean getSuspend() {
        return suspend_;
      }
      /**
       * <pre>
       * suspend specifies whether the Job controller should create Pods or not. If
       * a Job is created with suspend set to true, no Pods are created by the Job
       * controller. If a Job is suspended after creation (i.e. the flag goes from
       * false to true), the Job controller will delete all active Pods associated
       * with this Job. Users must design their workload to gracefully handle this.
       * Suspending a Job will reset the StartTime field of the Job, effectively
       * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 10;</code>
       */
      public Builder setSuspend(boolean value) {
        bitField0_ |= 0x00002000;
        suspend_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * suspend specifies whether the Job controller should create Pods or not. If
       * a Job is created with suspend set to true, no Pods are created by the Job
       * controller. If a Job is suspended after creation (i.e. the flag goes from
       * false to true), the Job controller will delete all active Pods associated
       * with this Job. Users must design their workload to gracefully handle this.
       * Suspending a Job will reset the StartTime field of the Job, effectively
       * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
       * +optional
       * </pre>
       *
       * <code>optional bool suspend = 10;</code>
       */
      public Builder clearSuspend() {
        bitField0_ = (bitField0_ & ~0x00002000);
        suspend_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object podReplacementPolicy_ = "";
      /**
       * <pre>
       * podReplacementPolicy specifies when to create replacement Pods.
       * Possible values are:
       * - TerminatingOrFailed means that we recreate pods
       *   when they are terminating (has a metadata.deletionTimestamp) or failed.
       * - Failed means to wait until a previously created Pod is fully terminated (has phase
       *   Failed or Succeeded) before creating a replacement Pod.
       * When using podFailurePolicy, Failed is the the only allowed value.
       * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
       * +optional
       * </pre>
       *
       * <code>optional string podReplacementPolicy = 14;</code>
       */
      public boolean hasPodReplacementPolicy() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <pre>
       * podReplacementPolicy specifies when to create replacement Pods.
       * Possible values are:
       * - TerminatingOrFailed means that we recreate pods
       *   when they are terminating (has a metadata.deletionTimestamp) or failed.
       * - Failed means to wait until a previously created Pod is fully terminated (has phase
       *   Failed or Succeeded) before creating a replacement Pod.
       * When using podFailurePolicy, Failed is the the only allowed value.
       * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
       * +optional
       * </pre>
       *
       * <code>optional string podReplacementPolicy = 14;</code>
       */
      public java.lang.String getPodReplacementPolicy() {
        java.lang.Object ref = podReplacementPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            podReplacementPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * podReplacementPolicy specifies when to create replacement Pods.
       * Possible values are:
       * - TerminatingOrFailed means that we recreate pods
       *   when they are terminating (has a metadata.deletionTimestamp) or failed.
       * - Failed means to wait until a previously created Pod is fully terminated (has phase
       *   Failed or Succeeded) before creating a replacement Pod.
       * When using podFailurePolicy, Failed is the the only allowed value.
       * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
       * +optional
       * </pre>
       *
       * <code>optional string podReplacementPolicy = 14;</code>
       */
      public com.google.protobuf.ByteString
          getPodReplacementPolicyBytes() {
        java.lang.Object ref = podReplacementPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          podReplacementPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * podReplacementPolicy specifies when to create replacement Pods.
       * Possible values are:
       * - TerminatingOrFailed means that we recreate pods
       *   when they are terminating (has a metadata.deletionTimestamp) or failed.
       * - Failed means to wait until a previously created Pod is fully terminated (has phase
       *   Failed or Succeeded) before creating a replacement Pod.
       * When using podFailurePolicy, Failed is the the only allowed value.
       * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
       * +optional
       * </pre>
       *
       * <code>optional string podReplacementPolicy = 14;</code>
       */
      public Builder setPodReplacementPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00004000;
        podReplacementPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podReplacementPolicy specifies when to create replacement Pods.
       * Possible values are:
       * - TerminatingOrFailed means that we recreate pods
       *   when they are terminating (has a metadata.deletionTimestamp) or failed.
       * - Failed means to wait until a previously created Pod is fully terminated (has phase
       *   Failed or Succeeded) before creating a replacement Pod.
       * When using podFailurePolicy, Failed is the the only allowed value.
       * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
       * +optional
       * </pre>
       *
       * <code>optional string podReplacementPolicy = 14;</code>
       */
      public Builder clearPodReplacementPolicy() {
        bitField0_ = (bitField0_ & ~0x00004000);
        podReplacementPolicy_ = getDefaultInstance().getPodReplacementPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * podReplacementPolicy specifies when to create replacement Pods.
       * Possible values are:
       * - TerminatingOrFailed means that we recreate pods
       *   when they are terminating (has a metadata.deletionTimestamp) or failed.
       * - Failed means to wait until a previously created Pod is fully terminated (has phase
       *   Failed or Succeeded) before creating a replacement Pod.
       * When using podFailurePolicy, Failed is the the only allowed value.
       * TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.
       * +optional
       * </pre>
       *
       * <code>optional string podReplacementPolicy = 14;</code>
       */
      public Builder setPodReplacementPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00004000;
        podReplacementPolicy_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object managedBy_ = "";
      /**
       * <pre>
       * ManagedBy field indicates the controller that manages a Job. The k8s Job
       * controller reconciles jobs which don't have this field at all or the field
       * value is the reserved string `kubernetes.io/job-controller`, but skips
       * reconciling Jobs with a custom value for this field.
       * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
       * all characters before the first "/" must be a valid subdomain as defined
       * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
       * characters as defined by RFC 3986. The value cannot exceed 63 characters.
       * This field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional string managedBy = 15;</code>
       */
      public boolean hasManagedBy() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <pre>
       * ManagedBy field indicates the controller that manages a Job. The k8s Job
       * controller reconciles jobs which don't have this field at all or the field
       * value is the reserved string `kubernetes.io/job-controller`, but skips
       * reconciling Jobs with a custom value for this field.
       * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
       * all characters before the first "/" must be a valid subdomain as defined
       * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
       * characters as defined by RFC 3986. The value cannot exceed 63 characters.
       * This field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional string managedBy = 15;</code>
       */
      public java.lang.String getManagedBy() {
        java.lang.Object ref = managedBy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            managedBy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * ManagedBy field indicates the controller that manages a Job. The k8s Job
       * controller reconciles jobs which don't have this field at all or the field
       * value is the reserved string `kubernetes.io/job-controller`, but skips
       * reconciling Jobs with a custom value for this field.
       * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
       * all characters before the first "/" must be a valid subdomain as defined
       * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
       * characters as defined by RFC 3986. The value cannot exceed 63 characters.
       * This field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional string managedBy = 15;</code>
       */
      public com.google.protobuf.ByteString
          getManagedByBytes() {
        java.lang.Object ref = managedBy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          managedBy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * ManagedBy field indicates the controller that manages a Job. The k8s Job
       * controller reconciles jobs which don't have this field at all or the field
       * value is the reserved string `kubernetes.io/job-controller`, but skips
       * reconciling Jobs with a custom value for this field.
       * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
       * all characters before the first "/" must be a valid subdomain as defined
       * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
       * characters as defined by RFC 3986. The value cannot exceed 63 characters.
       * This field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional string managedBy = 15;</code>
       */
      public Builder setManagedBy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
        managedBy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ManagedBy field indicates the controller that manages a Job. The k8s Job
       * controller reconciles jobs which don't have this field at all or the field
       * value is the reserved string `kubernetes.io/job-controller`, but skips
       * reconciling Jobs with a custom value for this field.
       * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
       * all characters before the first "/" must be a valid subdomain as defined
       * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
       * characters as defined by RFC 3986. The value cannot exceed 63 characters.
       * This field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional string managedBy = 15;</code>
       */
      public Builder clearManagedBy() {
        bitField0_ = (bitField0_ & ~0x00008000);
        managedBy_ = getDefaultInstance().getManagedBy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ManagedBy field indicates the controller that manages a Job. The k8s Job
       * controller reconciles jobs which don't have this field at all or the field
       * value is the reserved string `kubernetes.io/job-controller`, but skips
       * reconciling Jobs with a custom value for this field.
       * The value must be a valid domain-prefixed path (e.g. acme.io/foo) -
       * all characters before the first "/" must be a valid subdomain as defined
       * by RFC 1123. All characters trailing the first "/" must be valid HTTP Path
       * characters as defined by RFC 3986. The value cannot exceed 63 characters.
       * This field is immutable.
       * +optional
       * </pre>
       *
       * <code>optional string managedBy = 15;</code>
       */
      public Builder setManagedByBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
        managedBy_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.JobSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.JobSpec)
    private static final io.kubernetes.client.proto.V1Batch.JobSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.JobSpec();
    }

    public static io.kubernetes.client.proto.V1Batch.JobSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<JobSpec>
        PARSER = new com.google.protobuf.AbstractParser<JobSpec>() {
      @java.lang.Override
      public JobSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new JobSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<JobSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<JobSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.JobSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JobStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.JobStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Batch.JobCondition> 
        getConditionsList();
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobCondition getConditions(int index);
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder getConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * Represents time when the job controller started processing a job. When a
     * Job is created in the suspended state, this field is not set until the
     * first time it is resumed. This field is reset every time a Job is resumed
     * from suspension. It is represented in RFC3339 form and is in UTC.
     * Once set, the field can only be removed when the job is suspended.
     * The field cannot be modified while the job is unsuspended or finished.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
     */
    boolean hasStartTime();
    /**
     * <pre>
     * Represents time when the job controller started processing a job. When a
     * Job is created in the suspended state, this field is not set until the
     * first time it is resumed. This field is reset every time a Job is resumed
     * from suspension. It is represented in RFC3339 form and is in UTC.
     * Once set, the field can only be removed when the job is suspended.
     * The field cannot be modified while the job is unsuspended or finished.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
     */
    io.kubernetes.client.proto.Meta.Time getStartTime();
    /**
     * <pre>
     * Represents time when the job controller started processing a job. When a
     * Job is created in the suspended state, this field is not set until the
     * first time it is resumed. This field is reset every time a Job is resumed
     * from suspension. It is represented in RFC3339 form and is in UTC.
     * Once set, the field can only be removed when the job is suspended.
     * The field cannot be modified while the job is unsuspended or finished.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getStartTimeOrBuilder();

    /**
     * <pre>
     * Represents time when the job was completed. It is not guaranteed to
     * be set in happens-before order across separate operations.
     * It is represented in RFC3339 form and is in UTC.
     * The completion time is set when the job finishes successfully, and only then.
     * The value cannot be updated or removed. The value indicates the same or
     * later point in time as the startTime field.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
     */
    boolean hasCompletionTime();
    /**
     * <pre>
     * Represents time when the job was completed. It is not guaranteed to
     * be set in happens-before order across separate operations.
     * It is represented in RFC3339 form and is in UTC.
     * The completion time is set when the job finishes successfully, and only then.
     * The value cannot be updated or removed. The value indicates the same or
     * later point in time as the startTime field.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Time getCompletionTime();
    /**
     * <pre>
     * Represents time when the job was completed. It is not guaranteed to
     * be set in happens-before order across separate operations.
     * It is represented in RFC3339 form and is in UTC.
     * The completion time is set when the job finishes successfully, and only then.
     * The value cannot be updated or removed. The value indicates the same or
     * later point in time as the startTime field.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getCompletionTimeOrBuilder();

    /**
     * <pre>
     * The number of pending and running pods which are not terminating (without
     * a deletionTimestamp).
     * The value is zero for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 active = 4;</code>
     */
    boolean hasActive();
    /**
     * <pre>
     * The number of pending and running pods which are not terminating (without
     * a deletionTimestamp).
     * The value is zero for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 active = 4;</code>
     */
    int getActive();

    /**
     * <pre>
     * The number of pods which reached phase Succeeded.
     * The value increases monotonically for a given spec. However, it may
     * decrease in reaction to scale down of elastic indexed jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeeded = 5;</code>
     */
    boolean hasSucceeded();
    /**
     * <pre>
     * The number of pods which reached phase Succeeded.
     * The value increases monotonically for a given spec. However, it may
     * decrease in reaction to scale down of elastic indexed jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeeded = 5;</code>
     */
    int getSucceeded();

    /**
     * <pre>
     * The number of pods which reached phase Failed.
     * The value increases monotonically.
     * +optional
     * </pre>
     *
     * <code>optional int32 failed = 6;</code>
     */
    boolean hasFailed();
    /**
     * <pre>
     * The number of pods which reached phase Failed.
     * The value increases monotonically.
     * +optional
     * </pre>
     *
     * <code>optional int32 failed = 6;</code>
     */
    int getFailed();

    /**
     * <pre>
     * The number of pods which are terminating (in phase Pending or Running
     * and have a deletionTimestamp).
     * This field is beta-level. The job controller populates the field when
     * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
     * +optional
     * </pre>
     *
     * <code>optional int32 terminating = 11;</code>
     */
    boolean hasTerminating();
    /**
     * <pre>
     * The number of pods which are terminating (in phase Pending or Running
     * and have a deletionTimestamp).
     * This field is beta-level. The job controller populates the field when
     * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
     * +optional
     * </pre>
     *
     * <code>optional int32 terminating = 11;</code>
     */
    int getTerminating();

    /**
     * <pre>
     * completedIndexes holds the completed indexes when .spec.completionMode =
     * "Indexed" in a text format. The indexes are represented as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * +optional
     * </pre>
     *
     * <code>optional string completedIndexes = 7;</code>
     */
    boolean hasCompletedIndexes();
    /**
     * <pre>
     * completedIndexes holds the completed indexes when .spec.completionMode =
     * "Indexed" in a text format. The indexes are represented as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * +optional
     * </pre>
     *
     * <code>optional string completedIndexes = 7;</code>
     */
    java.lang.String getCompletedIndexes();
    /**
     * <pre>
     * completedIndexes holds the completed indexes when .spec.completionMode =
     * "Indexed" in a text format. The indexes are represented as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * +optional
     * </pre>
     *
     * <code>optional string completedIndexes = 7;</code>
     */
    com.google.protobuf.ByteString
        getCompletedIndexesBytes();

    /**
     * <pre>
     * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
     * The indexes are represented in the text format analogous as for the
     * `completedIndexes` field, ie. they are kept as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * The set of failed indexes cannot overlap with the set of completed indexes.
     * +optional
     * </pre>
     *
     * <code>optional string failedIndexes = 10;</code>
     */
    boolean hasFailedIndexes();
    /**
     * <pre>
     * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
     * The indexes are represented in the text format analogous as for the
     * `completedIndexes` field, ie. they are kept as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * The set of failed indexes cannot overlap with the set of completed indexes.
     * +optional
     * </pre>
     *
     * <code>optional string failedIndexes = 10;</code>
     */
    java.lang.String getFailedIndexes();
    /**
     * <pre>
     * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
     * The indexes are represented in the text format analogous as for the
     * `completedIndexes` field, ie. they are kept as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * The set of failed indexes cannot overlap with the set of completed indexes.
     * +optional
     * </pre>
     *
     * <code>optional string failedIndexes = 10;</code>
     */
    com.google.protobuf.ByteString
        getFailedIndexesBytes();

    /**
     * <pre>
     * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
     * the job controller hasn't yet accounted for in the status counters.
     * The job controller creates pods with a finalizer. When a pod terminates
     * (succeeded or failed), the controller does three steps to account for it
     * in the job status:
     * 1. Add the pod UID to the arrays in this field.
     * 2. Remove the pod finalizer.
     * 3. Remove the pod UID from the arrays while increasing the corresponding
     *     counter.
     * Old jobs might not be tracked using this field, in which case the field
     * remains null.
     * The structure is empty for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
     */
    boolean hasUncountedTerminatedPods();
    /**
     * <pre>
     * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
     * the job controller hasn't yet accounted for in the status counters.
     * The job controller creates pods with a finalizer. When a pod terminates
     * (succeeded or failed), the controller does three steps to account for it
     * in the job status:
     * 1. Add the pod UID to the arrays in this field.
     * 2. Remove the pod finalizer.
     * 3. Remove the pod UID from the arrays while increasing the corresponding
     *     counter.
     * Old jobs might not be tracked using this field, in which case the field
     * remains null.
     * The structure is empty for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
     */
    io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods getUncountedTerminatedPods();
    /**
     * <pre>
     * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
     * the job controller hasn't yet accounted for in the status counters.
     * The job controller creates pods with a finalizer. When a pod terminates
     * (succeeded or failed), the controller does three steps to account for it
     * in the job status:
     * 1. Add the pod UID to the arrays in this field.
     * 2. Remove the pod finalizer.
     * 3. Remove the pod UID from the arrays while increasing the corresponding
     *     counter.
     * Old jobs might not be tracked using this field, in which case the field
     * remains null.
     * The structure is empty for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
     */
    io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder getUncountedTerminatedPodsOrBuilder();

    /**
     * <pre>
     * The number of active pods which have a Ready condition and are not
     * terminating (without a deletionTimestamp).
     * </pre>
     *
     * <code>optional int32 ready = 9;</code>
     */
    boolean hasReady();
    /**
     * <pre>
     * The number of active pods which have a Ready condition and are not
     * terminating (without a deletionTimestamp).
     * </pre>
     *
     * <code>optional int32 ready = 9;</code>
     */
    int getReady();
  }
  /**
   * <pre>
   * JobStatus represents the current state of a Job.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.JobStatus}
   */
  public  static final class JobStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.JobStatus)
      JobStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use JobStatus.newBuilder() to construct.
    private JobStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private JobStatus() {
      conditions_ = java.util.Collections.emptyList();
      active_ = 0;
      succeeded_ = 0;
      failed_ = 0;
      terminating_ = 0;
      completedIndexes_ = "";
      failedIndexes_ = "";
      ready_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private JobStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.JobCondition>();
                mutable_bitField0_ |= 0x00000001;
              }
              conditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Batch.JobCondition.PARSER, extensionRegistry));
              break;
            }
            case 18: {
              io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = startTime_.toBuilder();
              }
              startTime_ = input.readMessage(io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(startTime_);
                startTime_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = completionTime_.toBuilder();
              }
              completionTime_ = input.readMessage(io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(completionTime_);
                completionTime_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 32: {
              bitField0_ |= 0x00000004;
              active_ = input.readInt32();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000008;
              succeeded_ = input.readInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000010;
              failed_ = input.readInt32();
              break;
            }
            case 58: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              completedIndexes_ = bs;
              break;
            }
            case 66: {
              io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) == 0x00000100)) {
                subBuilder = uncountedTerminatedPods_.toBuilder();
              }
              uncountedTerminatedPods_ = input.readMessage(io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(uncountedTerminatedPods_);
                uncountedTerminatedPods_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 72: {
              bitField0_ |= 0x00000200;
              ready_ = input.readInt32();
              break;
            }
            case 82: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000080;
              failedIndexes_ = bs;
              break;
            }
            case 88: {
              bitField0_ |= 0x00000020;
              terminating_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          conditions_ = java.util.Collections.unmodifiableList(conditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.JobStatus.class, io.kubernetes.client.proto.V1Batch.JobStatus.Builder.class);
    }

    private int bitField0_;
    public static final int CONDITIONS_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1Batch.JobCondition> conditions_;
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Batch.JobCondition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobCondition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * The latest available observations of an object's current state. When a Job
     * fails, one of the conditions will have type "Failed" and status true. When
     * a Job is suspended, one of the conditions will have type "Suspended" and
     * status true; when the Job is resumed, the status of this condition will
     * become false. When a Job is completed, one of the conditions will have
     * type "Complete" and status true.
     * A job is considered finished when it is in a terminal condition, either
     * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
     * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
     * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    public static final int STARTTIME_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.Time startTime_;
    /**
     * <pre>
     * Represents time when the job controller started processing a job. When a
     * Job is created in the suspended state, this field is not set until the
     * first time it is resumed. This field is reset every time a Job is resumed
     * from suspension. It is represented in RFC3339 form and is in UTC.
     * Once set, the field can only be removed when the job is suspended.
     * The field cannot be modified while the job is unsuspended or finished.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
     */
    public boolean hasStartTime() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Represents time when the job controller started processing a job. When a
     * Job is created in the suspended state, this field is not set until the
     * first time it is resumed. This field is reset every time a Job is resumed
     * from suspension. It is represented in RFC3339 form and is in UTC.
     * Once set, the field can only be removed when the job is suspended.
     * The field cannot be modified while the job is unsuspended or finished.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getStartTime() {
      return startTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : startTime_;
    }
    /**
     * <pre>
     * Represents time when the job controller started processing a job. When a
     * Job is created in the suspended state, this field is not set until the
     * first time it is resumed. This field is reset every time a Job is resumed
     * from suspension. It is represented in RFC3339 form and is in UTC.
     * Once set, the field can only be removed when the job is suspended.
     * The field cannot be modified while the job is unsuspended or finished.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getStartTimeOrBuilder() {
      return startTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : startTime_;
    }

    public static final int COMPLETIONTIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time completionTime_;
    /**
     * <pre>
     * Represents time when the job was completed. It is not guaranteed to
     * be set in happens-before order across separate operations.
     * It is represented in RFC3339 form and is in UTC.
     * The completion time is set when the job finishes successfully, and only then.
     * The value cannot be updated or removed. The value indicates the same or
     * later point in time as the startTime field.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
     */
    public boolean hasCompletionTime() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Represents time when the job was completed. It is not guaranteed to
     * be set in happens-before order across separate operations.
     * It is represented in RFC3339 form and is in UTC.
     * The completion time is set when the job finishes successfully, and only then.
     * The value cannot be updated or removed. The value indicates the same or
     * later point in time as the startTime field.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getCompletionTime() {
      return completionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : completionTime_;
    }
    /**
     * <pre>
     * Represents time when the job was completed. It is not guaranteed to
     * be set in happens-before order across separate operations.
     * It is represented in RFC3339 form and is in UTC.
     * The completion time is set when the job finishes successfully, and only then.
     * The value cannot be updated or removed. The value indicates the same or
     * later point in time as the startTime field.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getCompletionTimeOrBuilder() {
      return completionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : completionTime_;
    }

    public static final int ACTIVE_FIELD_NUMBER = 4;
    private int active_;
    /**
     * <pre>
     * The number of pending and running pods which are not terminating (without
     * a deletionTimestamp).
     * The value is zero for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 active = 4;</code>
     */
    public boolean hasActive() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The number of pending and running pods which are not terminating (without
     * a deletionTimestamp).
     * The value is zero for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 active = 4;</code>
     */
    public int getActive() {
      return active_;
    }

    public static final int SUCCEEDED_FIELD_NUMBER = 5;
    private int succeeded_;
    /**
     * <pre>
     * The number of pods which reached phase Succeeded.
     * The value increases monotonically for a given spec. However, it may
     * decrease in reaction to scale down of elastic indexed jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeeded = 5;</code>
     */
    public boolean hasSucceeded() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The number of pods which reached phase Succeeded.
     * The value increases monotonically for a given spec. However, it may
     * decrease in reaction to scale down of elastic indexed jobs.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeeded = 5;</code>
     */
    public int getSucceeded() {
      return succeeded_;
    }

    public static final int FAILED_FIELD_NUMBER = 6;
    private int failed_;
    /**
     * <pre>
     * The number of pods which reached phase Failed.
     * The value increases monotonically.
     * +optional
     * </pre>
     *
     * <code>optional int32 failed = 6;</code>
     */
    public boolean hasFailed() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * The number of pods which reached phase Failed.
     * The value increases monotonically.
     * +optional
     * </pre>
     *
     * <code>optional int32 failed = 6;</code>
     */
    public int getFailed() {
      return failed_;
    }

    public static final int TERMINATING_FIELD_NUMBER = 11;
    private int terminating_;
    /**
     * <pre>
     * The number of pods which are terminating (in phase Pending or Running
     * and have a deletionTimestamp).
     * This field is beta-level. The job controller populates the field when
     * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
     * +optional
     * </pre>
     *
     * <code>optional int32 terminating = 11;</code>
     */
    public boolean hasTerminating() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * The number of pods which are terminating (in phase Pending or Running
     * and have a deletionTimestamp).
     * This field is beta-level. The job controller populates the field when
     * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
     * +optional
     * </pre>
     *
     * <code>optional int32 terminating = 11;</code>
     */
    public int getTerminating() {
      return terminating_;
    }

    public static final int COMPLETEDINDEXES_FIELD_NUMBER = 7;
    private volatile java.lang.Object completedIndexes_;
    /**
     * <pre>
     * completedIndexes holds the completed indexes when .spec.completionMode =
     * "Indexed" in a text format. The indexes are represented as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * +optional
     * </pre>
     *
     * <code>optional string completedIndexes = 7;</code>
     */
    public boolean hasCompletedIndexes() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * completedIndexes holds the completed indexes when .spec.completionMode =
     * "Indexed" in a text format. The indexes are represented as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * +optional
     * </pre>
     *
     * <code>optional string completedIndexes = 7;</code>
     */
    public java.lang.String getCompletedIndexes() {
      java.lang.Object ref = completedIndexes_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          completedIndexes_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * completedIndexes holds the completed indexes when .spec.completionMode =
     * "Indexed" in a text format. The indexes are represented as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * +optional
     * </pre>
     *
     * <code>optional string completedIndexes = 7;</code>
     */
    public com.google.protobuf.ByteString
        getCompletedIndexesBytes() {
      java.lang.Object ref = completedIndexes_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        completedIndexes_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FAILEDINDEXES_FIELD_NUMBER = 10;
    private volatile java.lang.Object failedIndexes_;
    /**
     * <pre>
     * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
     * The indexes are represented in the text format analogous as for the
     * `completedIndexes` field, ie. they are kept as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * The set of failed indexes cannot overlap with the set of completed indexes.
     * +optional
     * </pre>
     *
     * <code>optional string failedIndexes = 10;</code>
     */
    public boolean hasFailedIndexes() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
     * The indexes are represented in the text format analogous as for the
     * `completedIndexes` field, ie. they are kept as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * The set of failed indexes cannot overlap with the set of completed indexes.
     * +optional
     * </pre>
     *
     * <code>optional string failedIndexes = 10;</code>
     */
    public java.lang.String getFailedIndexes() {
      java.lang.Object ref = failedIndexes_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failedIndexes_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
     * The indexes are represented in the text format analogous as for the
     * `completedIndexes` field, ie. they are kept as decimal integers
     * separated by commas. The numbers are listed in increasing order. Three or
     * more consecutive numbers are compressed and represented by the first and
     * last element of the series, separated by a hyphen.
     * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * The set of failed indexes cannot overlap with the set of completed indexes.
     * +optional
     * </pre>
     *
     * <code>optional string failedIndexes = 10;</code>
     */
    public com.google.protobuf.ByteString
        getFailedIndexesBytes() {
      java.lang.Object ref = failedIndexes_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failedIndexes_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UNCOUNTEDTERMINATEDPODS_FIELD_NUMBER = 8;
    private io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods uncountedTerminatedPods_;
    /**
     * <pre>
     * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
     * the job controller hasn't yet accounted for in the status counters.
     * The job controller creates pods with a finalizer. When a pod terminates
     * (succeeded or failed), the controller does three steps to account for it
     * in the job status:
     * 1. Add the pod UID to the arrays in this field.
     * 2. Remove the pod finalizer.
     * 3. Remove the pod UID from the arrays while increasing the corresponding
     *     counter.
     * Old jobs might not be tracked using this field, in which case the field
     * remains null.
     * The structure is empty for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
     */
    public boolean hasUncountedTerminatedPods() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
     * the job controller hasn't yet accounted for in the status counters.
     * The job controller creates pods with a finalizer. When a pod terminates
     * (succeeded or failed), the controller does three steps to account for it
     * in the job status:
     * 1. Add the pod UID to the arrays in this field.
     * 2. Remove the pod finalizer.
     * 3. Remove the pod UID from the arrays while increasing the corresponding
     *     counter.
     * Old jobs might not be tracked using this field, in which case the field
     * remains null.
     * The structure is empty for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
     */
    public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods getUncountedTerminatedPods() {
      return uncountedTerminatedPods_ == null ? io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance() : uncountedTerminatedPods_;
    }
    /**
     * <pre>
     * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
     * the job controller hasn't yet accounted for in the status counters.
     * The job controller creates pods with a finalizer. When a pod terminates
     * (succeeded or failed), the controller does three steps to account for it
     * in the job status:
     * 1. Add the pod UID to the arrays in this field.
     * 2. Remove the pod finalizer.
     * 3. Remove the pod UID from the arrays while increasing the corresponding
     *     counter.
     * Old jobs might not be tracked using this field, in which case the field
     * remains null.
     * The structure is empty for finished jobs.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
     */
    public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder getUncountedTerminatedPodsOrBuilder() {
      return uncountedTerminatedPods_ == null ? io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance() : uncountedTerminatedPods_;
    }

    public static final int READY_FIELD_NUMBER = 9;
    private int ready_;
    /**
     * <pre>
     * The number of active pods which have a Ready condition and are not
     * terminating (without a deletionTimestamp).
     * </pre>
     *
     * <code>optional int32 ready = 9;</code>
     */
    public boolean hasReady() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <pre>
     * The number of active pods which have a Ready condition and are not
     * terminating (without a deletionTimestamp).
     * </pre>
     *
     * <code>optional int32 ready = 9;</code>
     */
    public int getReady() {
      return ready_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(1, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(2, getStartTime());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(3, getCompletionTime());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(4, active_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(5, succeeded_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt32(6, failed_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, completedIndexes_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(8, getUncountedTerminatedPods());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt32(9, ready_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, failedIndexes_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(11, terminating_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getStartTime());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getCompletionTime());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, active_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, succeeded_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, failed_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, completedIndexes_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getUncountedTerminatedPods());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, ready_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, failedIndexes_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, terminating_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.JobStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.JobStatus other = (io.kubernetes.client.proto.V1Batch.JobStatus) obj;

      boolean result = true;
      result = result && getConditionsList()
          .equals(other.getConditionsList());
      result = result && (hasStartTime() == other.hasStartTime());
      if (hasStartTime()) {
        result = result && getStartTime()
            .equals(other.getStartTime());
      }
      result = result && (hasCompletionTime() == other.hasCompletionTime());
      if (hasCompletionTime()) {
        result = result && getCompletionTime()
            .equals(other.getCompletionTime());
      }
      result = result && (hasActive() == other.hasActive());
      if (hasActive()) {
        result = result && (getActive()
            == other.getActive());
      }
      result = result && (hasSucceeded() == other.hasSucceeded());
      if (hasSucceeded()) {
        result = result && (getSucceeded()
            == other.getSucceeded());
      }
      result = result && (hasFailed() == other.hasFailed());
      if (hasFailed()) {
        result = result && (getFailed()
            == other.getFailed());
      }
      result = result && (hasTerminating() == other.hasTerminating());
      if (hasTerminating()) {
        result = result && (getTerminating()
            == other.getTerminating());
      }
      result = result && (hasCompletedIndexes() == other.hasCompletedIndexes());
      if (hasCompletedIndexes()) {
        result = result && getCompletedIndexes()
            .equals(other.getCompletedIndexes());
      }
      result = result && (hasFailedIndexes() == other.hasFailedIndexes());
      if (hasFailedIndexes()) {
        result = result && getFailedIndexes()
            .equals(other.getFailedIndexes());
      }
      result = result && (hasUncountedTerminatedPods() == other.hasUncountedTerminatedPods());
      if (hasUncountedTerminatedPods()) {
        result = result && getUncountedTerminatedPods()
            .equals(other.getUncountedTerminatedPods());
      }
      result = result && (hasReady() == other.hasReady());
      if (hasReady()) {
        result = result && (getReady()
            == other.getReady());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      if (hasStartTime()) {
        hash = (37 * hash) + STARTTIME_FIELD_NUMBER;
        hash = (53 * hash) + getStartTime().hashCode();
      }
      if (hasCompletionTime()) {
        hash = (37 * hash) + COMPLETIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getCompletionTime().hashCode();
      }
      if (hasActive()) {
        hash = (37 * hash) + ACTIVE_FIELD_NUMBER;
        hash = (53 * hash) + getActive();
      }
      if (hasSucceeded()) {
        hash = (37 * hash) + SUCCEEDED_FIELD_NUMBER;
        hash = (53 * hash) + getSucceeded();
      }
      if (hasFailed()) {
        hash = (37 * hash) + FAILED_FIELD_NUMBER;
        hash = (53 * hash) + getFailed();
      }
      if (hasTerminating()) {
        hash = (37 * hash) + TERMINATING_FIELD_NUMBER;
        hash = (53 * hash) + getTerminating();
      }
      if (hasCompletedIndexes()) {
        hash = (37 * hash) + COMPLETEDINDEXES_FIELD_NUMBER;
        hash = (53 * hash) + getCompletedIndexes().hashCode();
      }
      if (hasFailedIndexes()) {
        hash = (37 * hash) + FAILEDINDEXES_FIELD_NUMBER;
        hash = (53 * hash) + getFailedIndexes().hashCode();
      }
      if (hasUncountedTerminatedPods()) {
        hash = (37 * hash) + UNCOUNTEDTERMINATEDPODS_FIELD_NUMBER;
        hash = (53 * hash) + getUncountedTerminatedPods().hashCode();
      }
      if (hasReady()) {
        hash = (37 * hash) + READY_FIELD_NUMBER;
        hash = (53 * hash) + getReady();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.JobStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * JobStatus represents the current state of a Job.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.JobStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.JobStatus)
        io.kubernetes.client.proto.V1Batch.JobStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.JobStatus.class, io.kubernetes.client.proto.V1Batch.JobStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.JobStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getConditionsFieldBuilder();
          getStartTimeFieldBuilder();
          getCompletionTimeFieldBuilder();
          getUncountedTerminatedPodsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          conditionsBuilder_.clear();
        }
        if (startTimeBuilder_ == null) {
          startTime_ = null;
        } else {
          startTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (completionTimeBuilder_ == null) {
          completionTime_ = null;
        } else {
          completionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        active_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        succeeded_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        failed_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        terminating_ = 0;
        bitField0_ = (bitField0_ & ~0x00000040);
        completedIndexes_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        failedIndexes_ = "";
        bitField0_ = (bitField0_ & ~0x00000100);
        if (uncountedTerminatedPodsBuilder_ == null) {
          uncountedTerminatedPods_ = null;
        } else {
          uncountedTerminatedPodsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        ready_ = 0;
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobStatus build() {
        io.kubernetes.client.proto.V1Batch.JobStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobStatus buildPartial() {
        io.kubernetes.client.proto.V1Batch.JobStatus result = new io.kubernetes.client.proto.V1Batch.JobStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        if (startTimeBuilder_ == null) {
          result.startTime_ = startTime_;
        } else {
          result.startTime_ = startTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000002;
        }
        if (completionTimeBuilder_ == null) {
          result.completionTime_ = completionTime_;
        } else {
          result.completionTime_ = completionTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.active_ = active_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000008;
        }
        result.succeeded_ = succeeded_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        result.failed_ = failed_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000020;
        }
        result.terminating_ = terminating_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000040;
        }
        result.completedIndexes_ = completedIndexes_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000080;
        }
        result.failedIndexes_ = failedIndexes_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000100;
        }
        if (uncountedTerminatedPodsBuilder_ == null) {
          result.uncountedTerminatedPods_ = uncountedTerminatedPods_;
        } else {
          result.uncountedTerminatedPods_ = uncountedTerminatedPodsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000200;
        }
        result.ready_ = ready_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.JobStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.JobStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.JobStatus other) {
        if (other == io.kubernetes.client.proto.V1Batch.JobStatus.getDefaultInstance()) return this;
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000001);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        if (other.hasStartTime()) {
          mergeStartTime(other.getStartTime());
        }
        if (other.hasCompletionTime()) {
          mergeCompletionTime(other.getCompletionTime());
        }
        if (other.hasActive()) {
          setActive(other.getActive());
        }
        if (other.hasSucceeded()) {
          setSucceeded(other.getSucceeded());
        }
        if (other.hasFailed()) {
          setFailed(other.getFailed());
        }
        if (other.hasTerminating()) {
          setTerminating(other.getTerminating());
        }
        if (other.hasCompletedIndexes()) {
          bitField0_ |= 0x00000080;
          completedIndexes_ = other.completedIndexes_;
          onChanged();
        }
        if (other.hasFailedIndexes()) {
          bitField0_ |= 0x00000100;
          failedIndexes_ = other.failedIndexes_;
          onChanged();
        }
        if (other.hasUncountedTerminatedPods()) {
          mergeUncountedTerminatedPods(other.getUncountedTerminatedPods());
        }
        if (other.hasReady()) {
          setReady(other.getReady());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.JobStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.JobStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1Batch.JobCondition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.JobCondition>(conditions_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobCondition, io.kubernetes.client.proto.V1Batch.JobCondition.Builder, io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.JobCondition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobCondition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Batch.JobCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1Batch.JobCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.V1Batch.JobCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Batch.JobCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1Batch.JobCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1Batch.JobCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Batch.JobCondition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobCondition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobCondition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Batch.JobCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobCondition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Batch.JobCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * The latest available observations of an object's current state. When a Job
       * fails, one of the conditions will have type "Failed" and status true. When
       * a Job is suspended, one of the conditions will have type "Suspended" and
       * status true; when the Job is resumed, the status of this condition will
       * become false. When a Job is completed, one of the conditions will have
       * type "Complete" and status true.
       * A job is considered finished when it is in a terminal condition, either
       * "Complete" or "Failed". A Job cannot have both the "Complete" and "Failed" conditions.
       * Additionally, it cannot be in the "Complete" and "FailureTarget" conditions.
       * The "Complete", "Failed" and "FailureTarget" conditions cannot be disabled.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.JobCondition conditions = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.JobCondition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobCondition, io.kubernetes.client.proto.V1Batch.JobCondition.Builder, io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.JobCondition, io.kubernetes.client.proto.V1Batch.JobCondition.Builder, io.kubernetes.client.proto.V1Batch.JobConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time startTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> startTimeBuilder_;
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public boolean hasStartTime() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getStartTime() {
        if (startTimeBuilder_ == null) {
          return startTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : startTime_;
        } else {
          return startTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public Builder setStartTime(io.kubernetes.client.proto.Meta.Time value) {
        if (startTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          startTime_ = value;
          onChanged();
        } else {
          startTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public Builder setStartTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (startTimeBuilder_ == null) {
          startTime_ = builderForValue.build();
          onChanged();
        } else {
          startTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public Builder mergeStartTime(io.kubernetes.client.proto.Meta.Time value) {
        if (startTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              startTime_ != null &&
              startTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            startTime_ =
              io.kubernetes.client.proto.Meta.Time.newBuilder(startTime_).mergeFrom(value).buildPartial();
          } else {
            startTime_ = value;
          }
          onChanged();
        } else {
          startTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public Builder clearStartTime() {
        if (startTimeBuilder_ == null) {
          startTime_ = null;
          onChanged();
        } else {
          startTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getStartTimeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getStartTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getStartTimeOrBuilder() {
        if (startTimeBuilder_ != null) {
          return startTimeBuilder_.getMessageOrBuilder();
        } else {
          return startTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : startTime_;
        }
      }
      /**
       * <pre>
       * Represents time when the job controller started processing a job. When a
       * Job is created in the suspended state, this field is not set until the
       * first time it is resumed. This field is reset every time a Job is resumed
       * from suspension. It is represented in RFC3339 form and is in UTC.
       * Once set, the field can only be removed when the job is suspended.
       * The field cannot be modified while the job is unsuspended or finished.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getStartTimeFieldBuilder() {
        if (startTimeBuilder_ == null) {
          startTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getStartTime(),
                  getParentForChildren(),
                  isClean());
          startTime_ = null;
        }
        return startTimeBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time completionTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> completionTimeBuilder_;
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public boolean hasCompletionTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getCompletionTime() {
        if (completionTimeBuilder_ == null) {
          return completionTime_ == null ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : completionTime_;
        } else {
          return completionTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public Builder setCompletionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (completionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          completionTime_ = value;
          onChanged();
        } else {
          completionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public Builder setCompletionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (completionTimeBuilder_ == null) {
          completionTime_ = builderForValue.build();
          onChanged();
        } else {
          completionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public Builder mergeCompletionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (completionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              completionTime_ != null &&
              completionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            completionTime_ =
              io.kubernetes.client.proto.Meta.Time.newBuilder(completionTime_).mergeFrom(value).buildPartial();
          } else {
            completionTime_ = value;
          }
          onChanged();
        } else {
          completionTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public Builder clearCompletionTime() {
        if (completionTimeBuilder_ == null) {
          completionTime_ = null;
          onChanged();
        } else {
          completionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getCompletionTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getCompletionTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getCompletionTimeOrBuilder() {
        if (completionTimeBuilder_ != null) {
          return completionTimeBuilder_.getMessageOrBuilder();
        } else {
          return completionTime_ == null ?
              io.kubernetes.client.proto.Meta.Time.getDefaultInstance() : completionTime_;
        }
      }
      /**
       * <pre>
       * Represents time when the job was completed. It is not guaranteed to
       * be set in happens-before order across separate operations.
       * It is represented in RFC3339 form and is in UTC.
       * The completion time is set when the job finishes successfully, and only then.
       * The value cannot be updated or removed. The value indicates the same or
       * later point in time as the startTime field.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder> 
          getCompletionTimeFieldBuilder() {
        if (completionTimeBuilder_ == null) {
          completionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time, io.kubernetes.client.proto.Meta.Time.Builder, io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getCompletionTime(),
                  getParentForChildren(),
                  isClean());
          completionTime_ = null;
        }
        return completionTimeBuilder_;
      }

      private int active_ ;
      /**
       * <pre>
       * The number of pending and running pods which are not terminating (without
       * a deletionTimestamp).
       * The value is zero for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 active = 4;</code>
       */
      public boolean hasActive() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * The number of pending and running pods which are not terminating (without
       * a deletionTimestamp).
       * The value is zero for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 active = 4;</code>
       */
      public int getActive() {
        return active_;
      }
      /**
       * <pre>
       * The number of pending and running pods which are not terminating (without
       * a deletionTimestamp).
       * The value is zero for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 active = 4;</code>
       */
      public Builder setActive(int value) {
        bitField0_ |= 0x00000008;
        active_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of pending and running pods which are not terminating (without
       * a deletionTimestamp).
       * The value is zero for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 active = 4;</code>
       */
      public Builder clearActive() {
        bitField0_ = (bitField0_ & ~0x00000008);
        active_ = 0;
        onChanged();
        return this;
      }

      private int succeeded_ ;
      /**
       * <pre>
       * The number of pods which reached phase Succeeded.
       * The value increases monotonically for a given spec. However, it may
       * decrease in reaction to scale down of elastic indexed jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeeded = 5;</code>
       */
      public boolean hasSucceeded() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * The number of pods which reached phase Succeeded.
       * The value increases monotonically for a given spec. However, it may
       * decrease in reaction to scale down of elastic indexed jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeeded = 5;</code>
       */
      public int getSucceeded() {
        return succeeded_;
      }
      /**
       * <pre>
       * The number of pods which reached phase Succeeded.
       * The value increases monotonically for a given spec. However, it may
       * decrease in reaction to scale down of elastic indexed jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeeded = 5;</code>
       */
      public Builder setSucceeded(int value) {
        bitField0_ |= 0x00000010;
        succeeded_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of pods which reached phase Succeeded.
       * The value increases monotonically for a given spec. However, it may
       * decrease in reaction to scale down of elastic indexed jobs.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeeded = 5;</code>
       */
      public Builder clearSucceeded() {
        bitField0_ = (bitField0_ & ~0x00000010);
        succeeded_ = 0;
        onChanged();
        return this;
      }

      private int failed_ ;
      /**
       * <pre>
       * The number of pods which reached phase Failed.
       * The value increases monotonically.
       * +optional
       * </pre>
       *
       * <code>optional int32 failed = 6;</code>
       */
      public boolean hasFailed() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * The number of pods which reached phase Failed.
       * The value increases monotonically.
       * +optional
       * </pre>
       *
       * <code>optional int32 failed = 6;</code>
       */
      public int getFailed() {
        return failed_;
      }
      /**
       * <pre>
       * The number of pods which reached phase Failed.
       * The value increases monotonically.
       * +optional
       * </pre>
       *
       * <code>optional int32 failed = 6;</code>
       */
      public Builder setFailed(int value) {
        bitField0_ |= 0x00000020;
        failed_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of pods which reached phase Failed.
       * The value increases monotonically.
       * +optional
       * </pre>
       *
       * <code>optional int32 failed = 6;</code>
       */
      public Builder clearFailed() {
        bitField0_ = (bitField0_ & ~0x00000020);
        failed_ = 0;
        onChanged();
        return this;
      }

      private int terminating_ ;
      /**
       * <pre>
       * The number of pods which are terminating (in phase Pending or Running
       * and have a deletionTimestamp).
       * This field is beta-level. The job controller populates the field when
       * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
       * +optional
       * </pre>
       *
       * <code>optional int32 terminating = 11;</code>
       */
      public boolean hasTerminating() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * The number of pods which are terminating (in phase Pending or Running
       * and have a deletionTimestamp).
       * This field is beta-level. The job controller populates the field when
       * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
       * +optional
       * </pre>
       *
       * <code>optional int32 terminating = 11;</code>
       */
      public int getTerminating() {
        return terminating_;
      }
      /**
       * <pre>
       * The number of pods which are terminating (in phase Pending or Running
       * and have a deletionTimestamp).
       * This field is beta-level. The job controller populates the field when
       * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
       * +optional
       * </pre>
       *
       * <code>optional int32 terminating = 11;</code>
       */
      public Builder setTerminating(int value) {
        bitField0_ |= 0x00000040;
        terminating_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of pods which are terminating (in phase Pending or Running
       * and have a deletionTimestamp).
       * This field is beta-level. The job controller populates the field when
       * the feature gate JobPodReplacementPolicy is enabled (enabled by default).
       * +optional
       * </pre>
       *
       * <code>optional int32 terminating = 11;</code>
       */
      public Builder clearTerminating() {
        bitField0_ = (bitField0_ & ~0x00000040);
        terminating_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object completedIndexes_ = "";
      /**
       * <pre>
       * completedIndexes holds the completed indexes when .spec.completionMode =
       * "Indexed" in a text format. The indexes are represented as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * +optional
       * </pre>
       *
       * <code>optional string completedIndexes = 7;</code>
       */
      public boolean hasCompletedIndexes() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * completedIndexes holds the completed indexes when .spec.completionMode =
       * "Indexed" in a text format. The indexes are represented as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * +optional
       * </pre>
       *
       * <code>optional string completedIndexes = 7;</code>
       */
      public java.lang.String getCompletedIndexes() {
        java.lang.Object ref = completedIndexes_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            completedIndexes_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * completedIndexes holds the completed indexes when .spec.completionMode =
       * "Indexed" in a text format. The indexes are represented as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * +optional
       * </pre>
       *
       * <code>optional string completedIndexes = 7;</code>
       */
      public com.google.protobuf.ByteString
          getCompletedIndexesBytes() {
        java.lang.Object ref = completedIndexes_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          completedIndexes_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * completedIndexes holds the completed indexes when .spec.completionMode =
       * "Indexed" in a text format. The indexes are represented as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * +optional
       * </pre>
       *
       * <code>optional string completedIndexes = 7;</code>
       */
      public Builder setCompletedIndexes(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        completedIndexes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * completedIndexes holds the completed indexes when .spec.completionMode =
       * "Indexed" in a text format. The indexes are represented as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * +optional
       * </pre>
       *
       * <code>optional string completedIndexes = 7;</code>
       */
      public Builder clearCompletedIndexes() {
        bitField0_ = (bitField0_ & ~0x00000080);
        completedIndexes_ = getDefaultInstance().getCompletedIndexes();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * completedIndexes holds the completed indexes when .spec.completionMode =
       * "Indexed" in a text format. The indexes are represented as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * +optional
       * </pre>
       *
       * <code>optional string completedIndexes = 7;</code>
       */
      public Builder setCompletedIndexesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        completedIndexes_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object failedIndexes_ = "";
      /**
       * <pre>
       * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
       * The indexes are represented in the text format analogous as for the
       * `completedIndexes` field, ie. they are kept as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * The set of failed indexes cannot overlap with the set of completed indexes.
       * +optional
       * </pre>
       *
       * <code>optional string failedIndexes = 10;</code>
       */
      public boolean hasFailedIndexes() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
       * The indexes are represented in the text format analogous as for the
       * `completedIndexes` field, ie. they are kept as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * The set of failed indexes cannot overlap with the set of completed indexes.
       * +optional
       * </pre>
       *
       * <code>optional string failedIndexes = 10;</code>
       */
      public java.lang.String getFailedIndexes() {
        java.lang.Object ref = failedIndexes_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failedIndexes_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
       * The indexes are represented in the text format analogous as for the
       * `completedIndexes` field, ie. they are kept as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * The set of failed indexes cannot overlap with the set of completed indexes.
       * +optional
       * </pre>
       *
       * <code>optional string failedIndexes = 10;</code>
       */
      public com.google.protobuf.ByteString
          getFailedIndexesBytes() {
        java.lang.Object ref = failedIndexes_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failedIndexes_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
       * The indexes are represented in the text format analogous as for the
       * `completedIndexes` field, ie. they are kept as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * The set of failed indexes cannot overlap with the set of completed indexes.
       * +optional
       * </pre>
       *
       * <code>optional string failedIndexes = 10;</code>
       */
      public Builder setFailedIndexes(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
        failedIndexes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
       * The indexes are represented in the text format analogous as for the
       * `completedIndexes` field, ie. they are kept as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * The set of failed indexes cannot overlap with the set of completed indexes.
       * +optional
       * </pre>
       *
       * <code>optional string failedIndexes = 10;</code>
       */
      public Builder clearFailedIndexes() {
        bitField0_ = (bitField0_ & ~0x00000100);
        failedIndexes_ = getDefaultInstance().getFailedIndexes();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set.
       * The indexes are represented in the text format analogous as for the
       * `completedIndexes` field, ie. they are kept as decimal integers
       * separated by commas. The numbers are listed in increasing order. Three or
       * more consecutive numbers are compressed and represented by the first and
       * last element of the series, separated by a hyphen.
       * For example, if the failed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * The set of failed indexes cannot overlap with the set of completed indexes.
       * +optional
       * </pre>
       *
       * <code>optional string failedIndexes = 10;</code>
       */
      public Builder setFailedIndexesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
        failedIndexes_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods uncountedTerminatedPods_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder> uncountedTerminatedPodsBuilder_;
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public boolean hasUncountedTerminatedPods() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods getUncountedTerminatedPods() {
        if (uncountedTerminatedPodsBuilder_ == null) {
          return uncountedTerminatedPods_ == null ? io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance() : uncountedTerminatedPods_;
        } else {
          return uncountedTerminatedPodsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public Builder setUncountedTerminatedPods(io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods value) {
        if (uncountedTerminatedPodsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          uncountedTerminatedPods_ = value;
          onChanged();
        } else {
          uncountedTerminatedPodsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public Builder setUncountedTerminatedPods(
          io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder builderForValue) {
        if (uncountedTerminatedPodsBuilder_ == null) {
          uncountedTerminatedPods_ = builderForValue.build();
          onChanged();
        } else {
          uncountedTerminatedPodsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public Builder mergeUncountedTerminatedPods(io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods value) {
        if (uncountedTerminatedPodsBuilder_ == null) {
          if (((bitField0_ & 0x00000200) == 0x00000200) &&
              uncountedTerminatedPods_ != null &&
              uncountedTerminatedPods_ != io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance()) {
            uncountedTerminatedPods_ =
              io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.newBuilder(uncountedTerminatedPods_).mergeFrom(value).buildPartial();
          } else {
            uncountedTerminatedPods_ = value;
          }
          onChanged();
        } else {
          uncountedTerminatedPodsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public Builder clearUncountedTerminatedPods() {
        if (uncountedTerminatedPodsBuilder_ == null) {
          uncountedTerminatedPods_ = null;
          onChanged();
        } else {
          uncountedTerminatedPodsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder getUncountedTerminatedPodsBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getUncountedTerminatedPodsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder getUncountedTerminatedPodsOrBuilder() {
        if (uncountedTerminatedPodsBuilder_ != null) {
          return uncountedTerminatedPodsBuilder_.getMessageOrBuilder();
        } else {
          return uncountedTerminatedPods_ == null ?
              io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance() : uncountedTerminatedPods_;
        }
      }
      /**
       * <pre>
       * uncountedTerminatedPods holds the UIDs of Pods that have terminated but
       * the job controller hasn't yet accounted for in the status counters.
       * The job controller creates pods with a finalizer. When a pod terminates
       * (succeeded or failed), the controller does three steps to account for it
       * in the job status:
       * 1. Add the pod UID to the arrays in this field.
       * 2. Remove the pod finalizer.
       * 3. Remove the pod UID from the arrays while increasing the corresponding
       *     counter.
       * Old jobs might not be tracked using this field, in which case the field
       * remains null.
       * The structure is empty for finished jobs.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.UncountedTerminatedPods uncountedTerminatedPods = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder> 
          getUncountedTerminatedPodsFieldBuilder() {
        if (uncountedTerminatedPodsBuilder_ == null) {
          uncountedTerminatedPodsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder>(
                  getUncountedTerminatedPods(),
                  getParentForChildren(),
                  isClean());
          uncountedTerminatedPods_ = null;
        }
        return uncountedTerminatedPodsBuilder_;
      }

      private int ready_ ;
      /**
       * <pre>
       * The number of active pods which have a Ready condition and are not
       * terminating (without a deletionTimestamp).
       * </pre>
       *
       * <code>optional int32 ready = 9;</code>
       */
      public boolean hasReady() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * The number of active pods which have a Ready condition and are not
       * terminating (without a deletionTimestamp).
       * </pre>
       *
       * <code>optional int32 ready = 9;</code>
       */
      public int getReady() {
        return ready_;
      }
      /**
       * <pre>
       * The number of active pods which have a Ready condition and are not
       * terminating (without a deletionTimestamp).
       * </pre>
       *
       * <code>optional int32 ready = 9;</code>
       */
      public Builder setReady(int value) {
        bitField0_ |= 0x00000400;
        ready_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of active pods which have a Ready condition and are not
       * terminating (without a deletionTimestamp).
       * </pre>
       *
       * <code>optional int32 ready = 9;</code>
       */
      public Builder clearReady() {
        bitField0_ = (bitField0_ & ~0x00000400);
        ready_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.JobStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.JobStatus)
    private static final io.kubernetes.client.proto.V1Batch.JobStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.JobStatus();
    }

    public static io.kubernetes.client.proto.V1Batch.JobStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<JobStatus>
        PARSER = new com.google.protobuf.AbstractParser<JobStatus>() {
      @java.lang.Override
      public JobStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new JobStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<JobStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<JobStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.JobStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JobTemplateSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.JobTemplateSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata of the jobs created from this template.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata of the jobs created from this template.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata of the jobs created from this template.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * JobTemplateSpec describes the data a Job should have when created from a template
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.JobTemplateSpec}
   */
  public  static final class JobTemplateSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.JobTemplateSpec)
      JobTemplateSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use JobTemplateSpec.newBuilder() to construct.
    private JobTemplateSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private JobTemplateSpec() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private JobTemplateSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Batch.JobSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1Batch.JobSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobTemplateSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobTemplateSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.JobTemplateSpec.class, io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata of the jobs created from this template.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object's metadata of the jobs created from this template.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata of the jobs created from this template.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Batch.JobSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the job.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.JobTemplateSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.JobTemplateSpec other = (io.kubernetes.client.proto.V1Batch.JobTemplateSpec) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.JobTemplateSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * JobTemplateSpec describes the data a Job should have when created from a template
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.JobTemplateSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.JobTemplateSpec)
        io.kubernetes.client.proto.V1Batch.JobTemplateSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobTemplateSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobTemplateSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.JobTemplateSpec.class, io.kubernetes.client.proto.V1Batch.JobTemplateSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.JobTemplateSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_JobTemplateSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobTemplateSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobTemplateSpec build() {
        io.kubernetes.client.proto.V1Batch.JobTemplateSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.JobTemplateSpec buildPartial() {
        io.kubernetes.client.proto.V1Batch.JobTemplateSpec result = new io.kubernetes.client.proto.V1Batch.JobTemplateSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.JobTemplateSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.JobTemplateSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.JobTemplateSpec other) {
        if (other == io.kubernetes.client.proto.V1Batch.JobTemplateSpec.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.JobTemplateSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.JobTemplateSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata of the jobs created from this template.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Batch.JobSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobSpec, io.kubernetes.client.proto.V1Batch.JobSpec.Builder, io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Batch.JobSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Batch.JobSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Batch.JobSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1Batch.JobSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Batch.JobSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the job.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.JobSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.JobSpec, io.kubernetes.client.proto.V1Batch.JobSpec.Builder, io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.JobSpec, io.kubernetes.client.proto.V1Batch.JobSpec.Builder, io.kubernetes.client.proto.V1Batch.JobSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.JobTemplateSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.JobTemplateSpec)
    private static final io.kubernetes.client.proto.V1Batch.JobTemplateSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.JobTemplateSpec();
    }

    public static io.kubernetes.client.proto.V1Batch.JobTemplateSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<JobTemplateSpec>
        PARSER = new com.google.protobuf.AbstractParser<JobTemplateSpec>() {
      @java.lang.Override
      public JobTemplateSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new JobTemplateSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<JobTemplateSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<JobTemplateSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.JobTemplateSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodFailurePolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.PodFailurePolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule> 
        getRulesList();
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule getRules(int index);
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder getRulesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * PodFailurePolicy describes how failed pods influence the backoffLimit.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicy}
   */
  public  static final class PodFailurePolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.PodFailurePolicy)
      PodFailurePolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodFailurePolicy.newBuilder() to construct.
    private PodFailurePolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodFailurePolicy() {
      rules_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PodFailurePolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule>();
                mutable_bitField0_ |= 0x00000001;
              }
              rules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.PodFailurePolicy.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder.class);
    }

    public static final int RULES_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule> rules_;
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * A list of pod failure policy rules. The rules are evaluated in order.
     * Once a rule matches a Pod failure, the remaining of the rules are ignored.
     * When no rule matches the Pod failure, the default handling applies - the
     * counter of pod failures is incremented and it is checked against
     * the backoffLimit. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(1, rules_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, rules_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.PodFailurePolicy other = (io.kubernetes.client.proto.V1Batch.PodFailurePolicy) obj;

      boolean result = true;
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.PodFailurePolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodFailurePolicy describes how failed pods influence the backoffLimit.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.PodFailurePolicy)
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.PodFailurePolicy.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.PodFailurePolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRulesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicy build() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicy buildPartial() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicy result = new io.kubernetes.client.proto.V1Batch.PodFailurePolicy(this);
        int from_bitField0_ = bitField0_;
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.PodFailurePolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.PodFailurePolicy other) {
        if (other == io.kubernetes.client.proto.V1Batch.PodFailurePolicy.getDefaultInstance()) return this;
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.PodFailurePolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule>(rules_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of pod failure policy rules. The rules are evaluated in order.
       * Once a rule matches a Pod failure, the remaining of the rules are ignored.
       * When no rule matches the Pod failure, the default handling applies - the
       * counter of pod failures is incremented and it is checked against
       * the backoffLimit. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyRule rules = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.PodFailurePolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.PodFailurePolicy)
    private static final io.kubernetes.client.proto.V1Batch.PodFailurePolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.PodFailurePolicy();
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PodFailurePolicy>
        PARSER = new com.google.protobuf.AbstractParser<PodFailurePolicy>() {
      @java.lang.Override
      public PodFailurePolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PodFailurePolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PodFailurePolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodFailurePolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodFailurePolicyOnExitCodesRequirementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Restricts the check for exit codes to the container with the
     * specified name. When null, the rule applies to all containers.
     * When specified, it should match one the container or initContainer
     * names in the pod template.
     * +optional
     * </pre>
     *
     * <code>optional string containerName = 1;</code>
     */
    boolean hasContainerName();
    /**
     * <pre>
     * Restricts the check for exit codes to the container with the
     * specified name. When null, the rule applies to all containers.
     * When specified, it should match one the container or initContainer
     * names in the pod template.
     * +optional
     * </pre>
     *
     * <code>optional string containerName = 1;</code>
     */
    java.lang.String getContainerName();
    /**
     * <pre>
     * Restricts the check for exit codes to the container with the
     * specified name. When null, the rule applies to all containers.
     * When specified, it should match one the container or initContainer
     * names in the pod template.
     * +optional
     * </pre>
     *
     * <code>optional string containerName = 1;</code>
     */
    com.google.protobuf.ByteString
        getContainerNameBytes();

    /**
     * <pre>
     * Represents the relationship between the container exit code(s) and the
     * specified values. Containers completed with success (exit code 0) are
     * excluded from the requirement check. Possible values are:
     * - In: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is in the set of specified values.
     * - NotIn: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is not in the set of specified values.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown operator by assuming the requirement is not satisfied.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     */
    boolean hasOperator();
    /**
     * <pre>
     * Represents the relationship between the container exit code(s) and the
     * specified values. Containers completed with success (exit code 0) are
     * excluded from the requirement check. Possible values are:
     * - In: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is in the set of specified values.
     * - NotIn: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is not in the set of specified values.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown operator by assuming the requirement is not satisfied.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     */
    java.lang.String getOperator();
    /**
     * <pre>
     * Represents the relationship between the container exit code(s) and the
     * specified values. Containers completed with success (exit code 0) are
     * excluded from the requirement check. Possible values are:
     * - In: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is in the set of specified values.
     * - NotIn: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is not in the set of specified values.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown operator by assuming the requirement is not satisfied.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     */
    com.google.protobuf.ByteString
        getOperatorBytes();

    /**
     * <pre>
     * Specifies the set of values. Each returned container exit code (might be
     * multiple in case of multiple containers) is checked against this set of
     * values with respect to the operator. The list of values must be ordered
     * and must not contain duplicates. Value '0' cannot be used for the In operator.
     * At least one element is required. At most 255 elements are allowed.
     * +listType=set
     * </pre>
     *
     * <code>repeated int32 values = 3;</code>
     */
    java.util.List<java.lang.Integer> getValuesList();
    /**
     * <pre>
     * Specifies the set of values. Each returned container exit code (might be
     * multiple in case of multiple containers) is checked against this set of
     * values with respect to the operator. The list of values must be ordered
     * and must not contain duplicates. Value '0' cannot be used for the In operator.
     * At least one element is required. At most 255 elements are allowed.
     * +listType=set
     * </pre>
     *
     * <code>repeated int32 values = 3;</code>
     */
    int getValuesCount();
    /**
     * <pre>
     * Specifies the set of values. Each returned container exit code (might be
     * multiple in case of multiple containers) is checked against this set of
     * values with respect to the operator. The list of values must be ordered
     * and must not contain duplicates. Value '0' cannot be used for the In operator.
     * At least one element is required. At most 255 elements are allowed.
     * +listType=set
     * </pre>
     *
     * <code>repeated int32 values = 3;</code>
     */
    int getValues(int index);
  }
  /**
   * <pre>
   * PodFailurePolicyOnExitCodesRequirement describes the requirement for handling
   * a failed pod based on its container exit codes. In particular, it lookups the
   * .state.terminated.exitCode for each app container and init container status,
   * represented by the .status.containerStatuses and .status.initContainerStatuses
   * fields in the Pod status, respectively. Containers completed with success
   * (exit code 0) are excluded from the requirement check.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement}
   */
  public  static final class PodFailurePolicyOnExitCodesRequirement extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement)
      PodFailurePolicyOnExitCodesRequirementOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodFailurePolicyOnExitCodesRequirement.newBuilder() to construct.
    private PodFailurePolicyOnExitCodesRequirement(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodFailurePolicyOnExitCodesRequirement() {
      containerName_ = "";
      operator_ = "";
      values_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PodFailurePolicyOnExitCodesRequirement(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              containerName_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              operator_ = bs;
              break;
            }
            case 24: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                values_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000004;
              }
              values_.add(input.readInt32());
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004) && input.getBytesUntilLimit() > 0) {
                values_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000004;
              }
              while (input.getBytesUntilLimit() > 0) {
                values_.add(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          values_ = java.util.Collections.unmodifiableList(values_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder.class);
    }

    private int bitField0_;
    public static final int CONTAINERNAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object containerName_;
    /**
     * <pre>
     * Restricts the check for exit codes to the container with the
     * specified name. When null, the rule applies to all containers.
     * When specified, it should match one the container or initContainer
     * names in the pod template.
     * +optional
     * </pre>
     *
     * <code>optional string containerName = 1;</code>
     */
    public boolean hasContainerName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Restricts the check for exit codes to the container with the
     * specified name. When null, the rule applies to all containers.
     * When specified, it should match one the container or initContainer
     * names in the pod template.
     * +optional
     * </pre>
     *
     * <code>optional string containerName = 1;</code>
     */
    public java.lang.String getContainerName() {
      java.lang.Object ref = containerName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          containerName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Restricts the check for exit codes to the container with the
     * specified name. When null, the rule applies to all containers.
     * When specified, it should match one the container or initContainer
     * names in the pod template.
     * +optional
     * </pre>
     *
     * <code>optional string containerName = 1;</code>
     */
    public com.google.protobuf.ByteString
        getContainerNameBytes() {
      java.lang.Object ref = containerName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        containerName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OPERATOR_FIELD_NUMBER = 2;
    private volatile java.lang.Object operator_;
    /**
     * <pre>
     * Represents the relationship between the container exit code(s) and the
     * specified values. Containers completed with success (exit code 0) are
     * excluded from the requirement check. Possible values are:
     * - In: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is in the set of specified values.
     * - NotIn: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is not in the set of specified values.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown operator by assuming the requirement is not satisfied.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     */
    public boolean hasOperator() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Represents the relationship between the container exit code(s) and the
     * specified values. Containers completed with success (exit code 0) are
     * excluded from the requirement check. Possible values are:
     * - In: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is in the set of specified values.
     * - NotIn: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is not in the set of specified values.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown operator by assuming the requirement is not satisfied.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     */
    public java.lang.String getOperator() {
      java.lang.Object ref = operator_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          operator_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Represents the relationship between the container exit code(s) and the
     * specified values. Containers completed with success (exit code 0) are
     * excluded from the requirement check. Possible values are:
     * - In: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is in the set of specified values.
     * - NotIn: the requirement is satisfied if at least one container exit code
     *   (might be multiple if there are multiple containers not restricted
     *   by the 'containerName' field) is not in the set of specified values.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown operator by assuming the requirement is not satisfied.
     * </pre>
     *
     * <code>optional string operator = 2;</code>
     */
    public com.google.protobuf.ByteString
        getOperatorBytes() {
      java.lang.Object ref = operator_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        operator_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUES_FIELD_NUMBER = 3;
    private java.util.List<java.lang.Integer> values_;
    /**
     * <pre>
     * Specifies the set of values. Each returned container exit code (might be
     * multiple in case of multiple containers) is checked against this set of
     * values with respect to the operator. The list of values must be ordered
     * and must not contain duplicates. Value '0' cannot be used for the In operator.
     * At least one element is required. At most 255 elements are allowed.
     * +listType=set
     * </pre>
     *
     * <code>repeated int32 values = 3;</code>
     */
    public java.util.List<java.lang.Integer>
        getValuesList() {
      return values_;
    }
    /**
     * <pre>
     * Specifies the set of values. Each returned container exit code (might be
     * multiple in case of multiple containers) is checked against this set of
     * values with respect to the operator. The list of values must be ordered
     * and must not contain duplicates. Value '0' cannot be used for the In operator.
     * At least one element is required. At most 255 elements are allowed.
     * +listType=set
     * </pre>
     *
     * <code>repeated int32 values = 3;</code>
     */
    public int getValuesCount() {
      return values_.size();
    }
    /**
     * <pre>
     * Specifies the set of values. Each returned container exit code (might be
     * multiple in case of multiple containers) is checked against this set of
     * values with respect to the operator. The list of values must be ordered
     * and must not contain duplicates. Value '0' cannot be used for the In operator.
     * At least one element is required. At most 255 elements are allowed.
     * +listType=set
     * </pre>
     *
     * <code>repeated int32 values = 3;</code>
     */
    public int getValues(int index) {
      return values_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, containerName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, operator_);
      }
      for (int i = 0; i < values_.size(); i++) {
        output.writeInt32(3, values_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, containerName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, operator_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < values_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(values_.get(i));
        }
        size += dataSize;
        size += 1 * getValuesList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement other = (io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement) obj;

      boolean result = true;
      result = result && (hasContainerName() == other.hasContainerName());
      if (hasContainerName()) {
        result = result && getContainerName()
            .equals(other.getContainerName());
      }
      result = result && (hasOperator() == other.hasOperator());
      if (hasOperator()) {
        result = result && getOperator()
            .equals(other.getOperator());
      }
      result = result && getValuesList()
          .equals(other.getValuesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasContainerName()) {
        hash = (37 * hash) + CONTAINERNAME_FIELD_NUMBER;
        hash = (53 * hash) + getContainerName().hashCode();
      }
      if (hasOperator()) {
        hash = (37 * hash) + OPERATOR_FIELD_NUMBER;
        hash = (53 * hash) + getOperator().hashCode();
      }
      if (getValuesCount() > 0) {
        hash = (37 * hash) + VALUES_FIELD_NUMBER;
        hash = (53 * hash) + getValuesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodFailurePolicyOnExitCodesRequirement describes the requirement for handling
     * a failed pod based on its container exit codes. In particular, it lookups the
     * .state.terminated.exitCode for each app container and init container status,
     * represented by the .status.containerStatuses and .status.initContainerStatuses
     * fields in the Pod status, respectively. Containers completed with success
     * (exit code 0) are excluded from the requirement check.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement)
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        containerName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        operator_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        values_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement build() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement buildPartial() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement result = new io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.containerName_ = containerName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.operator_ = operator_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          values_ = java.util.Collections.unmodifiableList(values_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.values_ = values_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement other) {
        if (other == io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance()) return this;
        if (other.hasContainerName()) {
          bitField0_ |= 0x00000001;
          containerName_ = other.containerName_;
          onChanged();
        }
        if (other.hasOperator()) {
          bitField0_ |= 0x00000002;
          operator_ = other.operator_;
          onChanged();
        }
        if (!other.values_.isEmpty()) {
          if (values_.isEmpty()) {
            values_ = other.values_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureValuesIsMutable();
            values_.addAll(other.values_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object containerName_ = "";
      /**
       * <pre>
       * Restricts the check for exit codes to the container with the
       * specified name. When null, the rule applies to all containers.
       * When specified, it should match one the container or initContainer
       * names in the pod template.
       * +optional
       * </pre>
       *
       * <code>optional string containerName = 1;</code>
       */
      public boolean hasContainerName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Restricts the check for exit codes to the container with the
       * specified name. When null, the rule applies to all containers.
       * When specified, it should match one the container or initContainer
       * names in the pod template.
       * +optional
       * </pre>
       *
       * <code>optional string containerName = 1;</code>
       */
      public java.lang.String getContainerName() {
        java.lang.Object ref = containerName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            containerName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Restricts the check for exit codes to the container with the
       * specified name. When null, the rule applies to all containers.
       * When specified, it should match one the container or initContainer
       * names in the pod template.
       * +optional
       * </pre>
       *
       * <code>optional string containerName = 1;</code>
       */
      public com.google.protobuf.ByteString
          getContainerNameBytes() {
        java.lang.Object ref = containerName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          containerName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Restricts the check for exit codes to the container with the
       * specified name. When null, the rule applies to all containers.
       * When specified, it should match one the container or initContainer
       * names in the pod template.
       * +optional
       * </pre>
       *
       * <code>optional string containerName = 1;</code>
       */
      public Builder setContainerName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        containerName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Restricts the check for exit codes to the container with the
       * specified name. When null, the rule applies to all containers.
       * When specified, it should match one the container or initContainer
       * names in the pod template.
       * +optional
       * </pre>
       *
       * <code>optional string containerName = 1;</code>
       */
      public Builder clearContainerName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        containerName_ = getDefaultInstance().getContainerName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Restricts the check for exit codes to the container with the
       * specified name. When null, the rule applies to all containers.
       * When specified, it should match one the container or initContainer
       * names in the pod template.
       * +optional
       * </pre>
       *
       * <code>optional string containerName = 1;</code>
       */
      public Builder setContainerNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        containerName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object operator_ = "";
      /**
       * <pre>
       * Represents the relationship between the container exit code(s) and the
       * specified values. Containers completed with success (exit code 0) are
       * excluded from the requirement check. Possible values are:
       * - In: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is in the set of specified values.
       * - NotIn: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is not in the set of specified values.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown operator by assuming the requirement is not satisfied.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       */
      public boolean hasOperator() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Represents the relationship between the container exit code(s) and the
       * specified values. Containers completed with success (exit code 0) are
       * excluded from the requirement check. Possible values are:
       * - In: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is in the set of specified values.
       * - NotIn: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is not in the set of specified values.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown operator by assuming the requirement is not satisfied.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       */
      public java.lang.String getOperator() {
        java.lang.Object ref = operator_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            operator_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Represents the relationship between the container exit code(s) and the
       * specified values. Containers completed with success (exit code 0) are
       * excluded from the requirement check. Possible values are:
       * - In: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is in the set of specified values.
       * - NotIn: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is not in the set of specified values.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown operator by assuming the requirement is not satisfied.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       */
      public com.google.protobuf.ByteString
          getOperatorBytes() {
        java.lang.Object ref = operator_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          operator_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Represents the relationship between the container exit code(s) and the
       * specified values. Containers completed with success (exit code 0) are
       * excluded from the requirement check. Possible values are:
       * - In: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is in the set of specified values.
       * - NotIn: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is not in the set of specified values.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown operator by assuming the requirement is not satisfied.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       */
      public Builder setOperator(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        operator_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Represents the relationship between the container exit code(s) and the
       * specified values. Containers completed with success (exit code 0) are
       * excluded from the requirement check. Possible values are:
       * - In: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is in the set of specified values.
       * - NotIn: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is not in the set of specified values.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown operator by assuming the requirement is not satisfied.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       */
      public Builder clearOperator() {
        bitField0_ = (bitField0_ & ~0x00000002);
        operator_ = getDefaultInstance().getOperator();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Represents the relationship between the container exit code(s) and the
       * specified values. Containers completed with success (exit code 0) are
       * excluded from the requirement check. Possible values are:
       * - In: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is in the set of specified values.
       * - NotIn: the requirement is satisfied if at least one container exit code
       *   (might be multiple if there are multiple containers not restricted
       *   by the 'containerName' field) is not in the set of specified values.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown operator by assuming the requirement is not satisfied.
       * </pre>
       *
       * <code>optional string operator = 2;</code>
       */
      public Builder setOperatorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        operator_ = value;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> values_ = java.util.Collections.emptyList();
      private void ensureValuesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          values_ = new java.util.ArrayList<java.lang.Integer>(values_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public java.util.List<java.lang.Integer>
          getValuesList() {
        return java.util.Collections.unmodifiableList(values_);
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public int getValuesCount() {
        return values_.size();
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public int getValues(int index) {
        return values_.get(index);
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public Builder setValues(
          int index, int value) {
        ensureValuesIsMutable();
        values_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public Builder addValues(int value) {
        ensureValuesIsMutable();
        values_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public Builder addAllValues(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureValuesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, values_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the set of values. Each returned container exit code (might be
       * multiple in case of multiple containers) is checked against this set of
       * values with respect to the operator. The list of values must be ordered
       * and must not contain duplicates. Value '0' cannot be used for the In operator.
       * At least one element is required. At most 255 elements are allowed.
       * +listType=set
       * </pre>
       *
       * <code>repeated int32 values = 3;</code>
       */
      public Builder clearValues() {
        values_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement)
    private static final io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement();
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PodFailurePolicyOnExitCodesRequirement>
        PARSER = new com.google.protobuf.AbstractParser<PodFailurePolicyOnExitCodesRequirement>() {
      @java.lang.Override
      public PodFailurePolicyOnExitCodesRequirement parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PodFailurePolicyOnExitCodesRequirement(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PodFailurePolicyOnExitCodesRequirement> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodFailurePolicyOnExitCodesRequirement> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodFailurePolicyOnPodConditionsPatternOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the required Pod condition type. To match a pod condition
     * it is required that specified type equals the pod condition type.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * Specifies the required Pod condition type. To match a pod condition
     * it is required that specified type equals the pod condition type.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     * <pre>
     * Specifies the required Pod condition type. To match a pod condition
     * it is required that specified type equals the pod condition type.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Specifies the required Pod condition status. To match a pod condition
     * it is required that the specified status equals the pod condition status.
     * Defaults to True.
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * Specifies the required Pod condition status. To match a pod condition
     * it is required that the specified status equals the pod condition status.
     * Defaults to True.
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    java.lang.String getStatus();
    /**
     * <pre>
     * Specifies the required Pod condition status. To match a pod condition
     * it is required that the specified status equals the pod condition status.
     * Defaults to True.
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    com.google.protobuf.ByteString
        getStatusBytes();
  }
  /**
   * <pre>
   * PodFailurePolicyOnPodConditionsPattern describes a pattern for matching
   * an actual pod condition type.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern}
   */
  public  static final class PodFailurePolicyOnPodConditionsPattern extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern)
      PodFailurePolicyOnPodConditionsPatternOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodFailurePolicyOnPodConditionsPattern.newBuilder() to construct.
    private PodFailurePolicyOnPodConditionsPattern(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodFailurePolicyOnPodConditionsPattern() {
      type_ = "";
      status_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PodFailurePolicyOnPodConditionsPattern(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              status_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * Specifies the required Pod condition type. To match a pod condition
     * it is required that specified type equals the pod condition type.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Specifies the required Pod condition type. To match a pod condition
     * it is required that specified type equals the pod condition type.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the required Pod condition type. To match a pod condition
     * it is required that specified type equals the pod condition type.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private volatile java.lang.Object status_;
    /**
     * <pre>
     * Specifies the required Pod condition status. To match a pod condition
     * it is required that the specified status equals the pod condition status.
     * Defaults to True.
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specifies the required Pod condition status. To match a pod condition
     * it is required that the specified status equals the pod condition status.
     * Defaults to True.
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the required Pod condition status. To match a pod condition
     * it is required that the specified status equals the pod condition status.
     * Defaults to True.
     * +optional
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, status_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, status_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern other = (io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType()
            .equals(other.getType());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodFailurePolicyOnPodConditionsPattern describes a pattern for matching
     * an actual pod condition type.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern)
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        status_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern build() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern buildPartial() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern result = new io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.status_ = status_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern other) {
        if (other == io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasStatus()) {
          bitField0_ |= 0x00000002;
          status_ = other.status_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Specifies the required Pod condition type. To match a pod condition
       * it is required that specified type equals the pod condition type.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Specifies the required Pod condition type. To match a pod condition
       * it is required that specified type equals the pod condition type.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the required Pod condition type. To match a pod condition
       * it is required that specified type equals the pod condition type.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the required Pod condition type. To match a pod condition
       * it is required that specified type equals the pod condition type.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the required Pod condition type. To match a pod condition
       * it is required that specified type equals the pod condition type.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the required Pod condition type. To match a pod condition
       * it is required that specified type equals the pod condition type.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       * <pre>
       * Specifies the required Pod condition status. To match a pod condition
       * it is required that the specified status equals the pod condition status.
       * Defaults to True.
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specifies the required Pod condition status. To match a pod condition
       * it is required that the specified status equals the pod condition status.
       * Defaults to True.
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the required Pod condition status. To match a pod condition
       * it is required that the specified status equals the pod condition status.
       * Defaults to True.
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the required Pod condition status. To match a pod condition
       * it is required that the specified status equals the pod condition status.
       * Defaults to True.
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatus(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the required Pod condition status. To match a pod condition
       * it is required that the specified status equals the pod condition status.
       * Defaults to True.
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = getDefaultInstance().getStatus();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the required Pod condition status. To match a pod condition
       * it is required that the specified status equals the pod condition status.
       * Defaults to True.
       * +optional
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatusBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern)
    private static final io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern();
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PodFailurePolicyOnPodConditionsPattern>
        PARSER = new com.google.protobuf.AbstractParser<PodFailurePolicyOnPodConditionsPattern>() {
      @java.lang.Override
      public PodFailurePolicyOnPodConditionsPattern parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PodFailurePolicyOnPodConditionsPattern(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PodFailurePolicyOnPodConditionsPattern> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodFailurePolicyOnPodConditionsPattern> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PodFailurePolicyRuleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.PodFailurePolicyRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the action taken on a pod failure when the requirements are satisfied.
     * Possible values are:
     * - FailJob: indicates that the pod's job is marked as Failed and all
     *   running pods are terminated.
     * - FailIndex: indicates that the pod's index is marked as Failed and will
     *   not be restarted.
     * - Ignore: indicates that the counter towards the .backoffLimit is not
     *   incremented and a replacement pod is created.
     * - Count: indicates that the pod is handled in the default way - the
     *   counter towards the .backoffLimit is incremented.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown action by skipping the rule.
     * </pre>
     *
     * <code>optional string action = 1;</code>
     */
    boolean hasAction();
    /**
     * <pre>
     * Specifies the action taken on a pod failure when the requirements are satisfied.
     * Possible values are:
     * - FailJob: indicates that the pod's job is marked as Failed and all
     *   running pods are terminated.
     * - FailIndex: indicates that the pod's index is marked as Failed and will
     *   not be restarted.
     * - Ignore: indicates that the counter towards the .backoffLimit is not
     *   incremented and a replacement pod is created.
     * - Count: indicates that the pod is handled in the default way - the
     *   counter towards the .backoffLimit is incremented.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown action by skipping the rule.
     * </pre>
     *
     * <code>optional string action = 1;</code>
     */
    java.lang.String getAction();
    /**
     * <pre>
     * Specifies the action taken on a pod failure when the requirements are satisfied.
     * Possible values are:
     * - FailJob: indicates that the pod's job is marked as Failed and all
     *   running pods are terminated.
     * - FailIndex: indicates that the pod's index is marked as Failed and will
     *   not be restarted.
     * - Ignore: indicates that the counter towards the .backoffLimit is not
     *   incremented and a replacement pod is created.
     * - Count: indicates that the pod is handled in the default way - the
     *   counter towards the .backoffLimit is incremented.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown action by skipping the rule.
     * </pre>
     *
     * <code>optional string action = 1;</code>
     */
    com.google.protobuf.ByteString
        getActionBytes();

    /**
     * <pre>
     * Represents the requirement on the container exit codes.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
     */
    boolean hasOnExitCodes();
    /**
     * <pre>
     * Represents the requirement on the container exit codes.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement getOnExitCodes();
    /**
     * <pre>
     * Represents the requirement on the container exit codes.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder getOnExitCodesOrBuilder();

    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern> 
        getOnPodConditionsList();
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern getOnPodConditions(int index);
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    int getOnPodConditionsCount();
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder> 
        getOnPodConditionsOrBuilderList();
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder getOnPodConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * PodFailurePolicyRule describes how a pod failure is handled when the requirements are met.
   * One of onExitCodes and onPodConditions, but not both, can be used in each rule.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicyRule}
   */
  public  static final class PodFailurePolicyRule extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.PodFailurePolicyRule)
      PodFailurePolicyRuleOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PodFailurePolicyRule.newBuilder() to construct.
    private PodFailurePolicyRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PodFailurePolicyRule() {
      action_ = "";
      onPodConditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PodFailurePolicyRule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              action_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = onExitCodes_.toBuilder();
              }
              onExitCodes_ = input.readMessage(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(onExitCodes_);
                onExitCodes_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                onPodConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern>();
                mutable_bitField0_ |= 0x00000004;
              }
              onPodConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          onPodConditions_ = java.util.Collections.unmodifiableList(onPodConditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder.class);
    }

    private int bitField0_;
    public static final int ACTION_FIELD_NUMBER = 1;
    private volatile java.lang.Object action_;
    /**
     * <pre>
     * Specifies the action taken on a pod failure when the requirements are satisfied.
     * Possible values are:
     * - FailJob: indicates that the pod's job is marked as Failed and all
     *   running pods are terminated.
     * - FailIndex: indicates that the pod's index is marked as Failed and will
     *   not be restarted.
     * - Ignore: indicates that the counter towards the .backoffLimit is not
     *   incremented and a replacement pod is created.
     * - Count: indicates that the pod is handled in the default way - the
     *   counter towards the .backoffLimit is incremented.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown action by skipping the rule.
     * </pre>
     *
     * <code>optional string action = 1;</code>
     */
    public boolean hasAction() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Specifies the action taken on a pod failure when the requirements are satisfied.
     * Possible values are:
     * - FailJob: indicates that the pod's job is marked as Failed and all
     *   running pods are terminated.
     * - FailIndex: indicates that the pod's index is marked as Failed and will
     *   not be restarted.
     * - Ignore: indicates that the counter towards the .backoffLimit is not
     *   incremented and a replacement pod is created.
     * - Count: indicates that the pod is handled in the default way - the
     *   counter towards the .backoffLimit is incremented.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown action by skipping the rule.
     * </pre>
     *
     * <code>optional string action = 1;</code>
     */
    public java.lang.String getAction() {
      java.lang.Object ref = action_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          action_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the action taken on a pod failure when the requirements are satisfied.
     * Possible values are:
     * - FailJob: indicates that the pod's job is marked as Failed and all
     *   running pods are terminated.
     * - FailIndex: indicates that the pod's index is marked as Failed and will
     *   not be restarted.
     * - Ignore: indicates that the counter towards the .backoffLimit is not
     *   incremented and a replacement pod is created.
     * - Count: indicates that the pod is handled in the default way - the
     *   counter towards the .backoffLimit is incremented.
     * Additional values are considered to be added in the future. Clients should
     * react to an unknown action by skipping the rule.
     * </pre>
     *
     * <code>optional string action = 1;</code>
     */
    public com.google.protobuf.ByteString
        getActionBytes() {
      java.lang.Object ref = action_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        action_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ONEXITCODES_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement onExitCodes_;
    /**
     * <pre>
     * Represents the requirement on the container exit codes.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
     */
    public boolean hasOnExitCodes() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Represents the requirement on the container exit codes.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement getOnExitCodes() {
      return onExitCodes_ == null ? io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance() : onExitCodes_;
    }
    /**
     * <pre>
     * Represents the requirement on the container exit codes.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder getOnExitCodesOrBuilder() {
      return onExitCodes_ == null ? io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance() : onExitCodes_;
    }

    public static final int ONPODCONDITIONS_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern> onPodConditions_;
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern> getOnPodConditionsList() {
      return onPodConditions_;
    }
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder> 
        getOnPodConditionsOrBuilderList() {
      return onPodConditions_;
    }
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    public int getOnPodConditionsCount() {
      return onPodConditions_.size();
    }
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern getOnPodConditions(int index) {
      return onPodConditions_.get(index);
    }
    /**
     * <pre>
     * Represents the requirement on the pod conditions. The requirement is represented
     * as a list of pod condition patterns. The requirement is satisfied if at
     * least one pattern matches an actual pod condition. At most 20 elements are allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
     */
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder getOnPodConditionsOrBuilder(
        int index) {
      return onPodConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, action_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getOnExitCodes());
      }
      for (int i = 0; i < onPodConditions_.size(); i++) {
        output.writeMessage(3, onPodConditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, action_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getOnExitCodes());
      }
      for (int i = 0; i < onPodConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, onPodConditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule other = (io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule) obj;

      boolean result = true;
      result = result && (hasAction() == other.hasAction());
      if (hasAction()) {
        result = result && getAction()
            .equals(other.getAction());
      }
      result = result && (hasOnExitCodes() == other.hasOnExitCodes());
      if (hasOnExitCodes()) {
        result = result && getOnExitCodes()
            .equals(other.getOnExitCodes());
      }
      result = result && getOnPodConditionsList()
          .equals(other.getOnPodConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAction()) {
        hash = (37 * hash) + ACTION_FIELD_NUMBER;
        hash = (53 * hash) + getAction().hashCode();
      }
      if (hasOnExitCodes()) {
        hash = (37 * hash) + ONEXITCODES_FIELD_NUMBER;
        hash = (53 * hash) + getOnExitCodes().hashCode();
      }
      if (getOnPodConditionsCount() > 0) {
        hash = (37 * hash) + ONPODCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOnPodConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PodFailurePolicyRule describes how a pod failure is handled when the requirements are met.
     * One of onExitCodes and onPodConditions, but not both, can be used in each rule.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.PodFailurePolicyRule}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.PodFailurePolicyRule)
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.class, io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getOnExitCodesFieldBuilder();
          getOnPodConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        action_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (onExitCodesBuilder_ == null) {
          onExitCodes_ = null;
        } else {
          onExitCodesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (onPodConditionsBuilder_ == null) {
          onPodConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          onPodConditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule build() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule buildPartial() {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule result = new io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.action_ = action_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (onExitCodesBuilder_ == null) {
          result.onExitCodes_ = onExitCodes_;
        } else {
          result.onExitCodes_ = onExitCodesBuilder_.build();
        }
        if (onPodConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            onPodConditions_ = java.util.Collections.unmodifiableList(onPodConditions_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.onPodConditions_ = onPodConditions_;
        } else {
          result.onPodConditions_ = onPodConditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule other) {
        if (other == io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule.getDefaultInstance()) return this;
        if (other.hasAction()) {
          bitField0_ |= 0x00000001;
          action_ = other.action_;
          onChanged();
        }
        if (other.hasOnExitCodes()) {
          mergeOnExitCodes(other.getOnExitCodes());
        }
        if (onPodConditionsBuilder_ == null) {
          if (!other.onPodConditions_.isEmpty()) {
            if (onPodConditions_.isEmpty()) {
              onPodConditions_ = other.onPodConditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureOnPodConditionsIsMutable();
              onPodConditions_.addAll(other.onPodConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.onPodConditions_.isEmpty()) {
            if (onPodConditionsBuilder_.isEmpty()) {
              onPodConditionsBuilder_.dispose();
              onPodConditionsBuilder_ = null;
              onPodConditions_ = other.onPodConditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
              onPodConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getOnPodConditionsFieldBuilder() : null;
            } else {
              onPodConditionsBuilder_.addAllMessages(other.onPodConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object action_ = "";
      /**
       * <pre>
       * Specifies the action taken on a pod failure when the requirements are satisfied.
       * Possible values are:
       * - FailJob: indicates that the pod's job is marked as Failed and all
       *   running pods are terminated.
       * - FailIndex: indicates that the pod's index is marked as Failed and will
       *   not be restarted.
       * - Ignore: indicates that the counter towards the .backoffLimit is not
       *   incremented and a replacement pod is created.
       * - Count: indicates that the pod is handled in the default way - the
       *   counter towards the .backoffLimit is incremented.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown action by skipping the rule.
       * </pre>
       *
       * <code>optional string action = 1;</code>
       */
      public boolean hasAction() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Specifies the action taken on a pod failure when the requirements are satisfied.
       * Possible values are:
       * - FailJob: indicates that the pod's job is marked as Failed and all
       *   running pods are terminated.
       * - FailIndex: indicates that the pod's index is marked as Failed and will
       *   not be restarted.
       * - Ignore: indicates that the counter towards the .backoffLimit is not
       *   incremented and a replacement pod is created.
       * - Count: indicates that the pod is handled in the default way - the
       *   counter towards the .backoffLimit is incremented.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown action by skipping the rule.
       * </pre>
       *
       * <code>optional string action = 1;</code>
       */
      public java.lang.String getAction() {
        java.lang.Object ref = action_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            action_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the action taken on a pod failure when the requirements are satisfied.
       * Possible values are:
       * - FailJob: indicates that the pod's job is marked as Failed and all
       *   running pods are terminated.
       * - FailIndex: indicates that the pod's index is marked as Failed and will
       *   not be restarted.
       * - Ignore: indicates that the counter towards the .backoffLimit is not
       *   incremented and a replacement pod is created.
       * - Count: indicates that the pod is handled in the default way - the
       *   counter towards the .backoffLimit is incremented.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown action by skipping the rule.
       * </pre>
       *
       * <code>optional string action = 1;</code>
       */
      public com.google.protobuf.ByteString
          getActionBytes() {
        java.lang.Object ref = action_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          action_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the action taken on a pod failure when the requirements are satisfied.
       * Possible values are:
       * - FailJob: indicates that the pod's job is marked as Failed and all
       *   running pods are terminated.
       * - FailIndex: indicates that the pod's index is marked as Failed and will
       *   not be restarted.
       * - Ignore: indicates that the counter towards the .backoffLimit is not
       *   incremented and a replacement pod is created.
       * - Count: indicates that the pod is handled in the default way - the
       *   counter towards the .backoffLimit is incremented.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown action by skipping the rule.
       * </pre>
       *
       * <code>optional string action = 1;</code>
       */
      public Builder setAction(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        action_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the action taken on a pod failure when the requirements are satisfied.
       * Possible values are:
       * - FailJob: indicates that the pod's job is marked as Failed and all
       *   running pods are terminated.
       * - FailIndex: indicates that the pod's index is marked as Failed and will
       *   not be restarted.
       * - Ignore: indicates that the counter towards the .backoffLimit is not
       *   incremented and a replacement pod is created.
       * - Count: indicates that the pod is handled in the default way - the
       *   counter towards the .backoffLimit is incremented.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown action by skipping the rule.
       * </pre>
       *
       * <code>optional string action = 1;</code>
       */
      public Builder clearAction() {
        bitField0_ = (bitField0_ & ~0x00000001);
        action_ = getDefaultInstance().getAction();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the action taken on a pod failure when the requirements are satisfied.
       * Possible values are:
       * - FailJob: indicates that the pod's job is marked as Failed and all
       *   running pods are terminated.
       * - FailIndex: indicates that the pod's index is marked as Failed and will
       *   not be restarted.
       * - Ignore: indicates that the counter towards the .backoffLimit is not
       *   incremented and a replacement pod is created.
       * - Count: indicates that the pod is handled in the default way - the
       *   counter towards the .backoffLimit is incremented.
       * Additional values are considered to be added in the future. Clients should
       * react to an unknown action by skipping the rule.
       * </pre>
       *
       * <code>optional string action = 1;</code>
       */
      public Builder setActionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        action_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement onExitCodes_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder> onExitCodesBuilder_;
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public boolean hasOnExitCodes() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement getOnExitCodes() {
        if (onExitCodesBuilder_ == null) {
          return onExitCodes_ == null ? io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance() : onExitCodes_;
        } else {
          return onExitCodesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public Builder setOnExitCodes(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement value) {
        if (onExitCodesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          onExitCodes_ = value;
          onChanged();
        } else {
          onExitCodesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public Builder setOnExitCodes(
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder builderForValue) {
        if (onExitCodesBuilder_ == null) {
          onExitCodes_ = builderForValue.build();
          onChanged();
        } else {
          onExitCodesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public Builder mergeOnExitCodes(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement value) {
        if (onExitCodesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              onExitCodes_ != null &&
              onExitCodes_ != io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance()) {
            onExitCodes_ =
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.newBuilder(onExitCodes_).mergeFrom(value).buildPartial();
          } else {
            onExitCodes_ = value;
          }
          onChanged();
        } else {
          onExitCodesBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public Builder clearOnExitCodes() {
        if (onExitCodesBuilder_ == null) {
          onExitCodes_ = null;
          onChanged();
        } else {
          onExitCodesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder getOnExitCodesBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getOnExitCodesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder getOnExitCodesOrBuilder() {
        if (onExitCodesBuilder_ != null) {
          return onExitCodesBuilder_.getMessageOrBuilder();
        } else {
          return onExitCodes_ == null ?
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.getDefaultInstance() : onExitCodes_;
        }
      }
      /**
       * <pre>
       * Represents the requirement on the container exit codes.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.batch.v1.PodFailurePolicyOnExitCodesRequirement onExitCodes = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder> 
          getOnExitCodesFieldBuilder() {
        if (onExitCodesBuilder_ == null) {
          onExitCodesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirement.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnExitCodesRequirementOrBuilder>(
                  getOnExitCodes(),
                  getParentForChildren(),
                  isClean());
          onExitCodes_ = null;
        }
        return onExitCodesBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern> onPodConditions_ =
        java.util.Collections.emptyList();
      private void ensureOnPodConditionsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          onPodConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern>(onPodConditions_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder> onPodConditionsBuilder_;

      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern> getOnPodConditionsList() {
        if (onPodConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(onPodConditions_);
        } else {
          return onPodConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public int getOnPodConditionsCount() {
        if (onPodConditionsBuilder_ == null) {
          return onPodConditions_.size();
        } else {
          return onPodConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern getOnPodConditions(int index) {
        if (onPodConditionsBuilder_ == null) {
          return onPodConditions_.get(index);
        } else {
          return onPodConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder setOnPodConditions(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern value) {
        if (onPodConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOnPodConditionsIsMutable();
          onPodConditions_.set(index, value);
          onChanged();
        } else {
          onPodConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder setOnPodConditions(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder builderForValue) {
        if (onPodConditionsBuilder_ == null) {
          ensureOnPodConditionsIsMutable();
          onPodConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          onPodConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder addOnPodConditions(io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern value) {
        if (onPodConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOnPodConditionsIsMutable();
          onPodConditions_.add(value);
          onChanged();
        } else {
          onPodConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder addOnPodConditions(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern value) {
        if (onPodConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOnPodConditionsIsMutable();
          onPodConditions_.add(index, value);
          onChanged();
        } else {
          onPodConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder addOnPodConditions(
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder builderForValue) {
        if (onPodConditionsBuilder_ == null) {
          ensureOnPodConditionsIsMutable();
          onPodConditions_.add(builderForValue.build());
          onChanged();
        } else {
          onPodConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder addOnPodConditions(
          int index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder builderForValue) {
        if (onPodConditionsBuilder_ == null) {
          ensureOnPodConditionsIsMutable();
          onPodConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          onPodConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder addAllOnPodConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern> values) {
        if (onPodConditionsBuilder_ == null) {
          ensureOnPodConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, onPodConditions_);
          onChanged();
        } else {
          onPodConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder clearOnPodConditions() {
        if (onPodConditionsBuilder_ == null) {
          onPodConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          onPodConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public Builder removeOnPodConditions(int index) {
        if (onPodConditionsBuilder_ == null) {
          ensureOnPodConditionsIsMutable();
          onPodConditions_.remove(index);
          onChanged();
        } else {
          onPodConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder getOnPodConditionsBuilder(
          int index) {
        return getOnPodConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder getOnPodConditionsOrBuilder(
          int index) {
        if (onPodConditionsBuilder_ == null) {
          return onPodConditions_.get(index);  } else {
          return onPodConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder> 
           getOnPodConditionsOrBuilderList() {
        if (onPodConditionsBuilder_ != null) {
          return onPodConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(onPodConditions_);
        }
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder addOnPodConditionsBuilder() {
        return getOnPodConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder addOnPodConditionsBuilder(
          int index) {
        return getOnPodConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.getDefaultInstance());
      }
      /**
       * <pre>
       * Represents the requirement on the pod conditions. The requirement is represented
       * as a list of pod condition patterns. The requirement is satisfied if at
       * least one pattern matches an actual pod condition. At most 20 elements are allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.PodFailurePolicyOnPodConditionsPattern onPodConditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder> 
           getOnPodConditionsBuilderList() {
        return getOnPodConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder> 
          getOnPodConditionsFieldBuilder() {
        if (onPodConditionsBuilder_ == null) {
          onPodConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPattern.Builder, io.kubernetes.client.proto.V1Batch.PodFailurePolicyOnPodConditionsPatternOrBuilder>(
                  onPodConditions_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          onPodConditions_ = null;
        }
        return onPodConditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.PodFailurePolicyRule)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.PodFailurePolicyRule)
    private static final io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule();
    }

    public static io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PodFailurePolicyRule>
        PARSER = new com.google.protobuf.AbstractParser<PodFailurePolicyRule>() {
      @java.lang.Override
      public PodFailurePolicyRule parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PodFailurePolicyRule(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PodFailurePolicyRule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodFailurePolicyRule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.PodFailurePolicyRule getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SuccessPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.SuccessPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule> 
        getRulesList();
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    io.kubernetes.client.proto.V1Batch.SuccessPolicyRule getRules(int index);
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder getRulesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * SuccessPolicy describes when a Job can be declared as succeeded based on the success of some indexes.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.SuccessPolicy}
   */
  public  static final class SuccessPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.SuccessPolicy)
      SuccessPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SuccessPolicy.newBuilder() to construct.
    private SuccessPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SuccessPolicy() {
      rules_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SuccessPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule>();
                mutable_bitField0_ |= 0x00000001;
              }
              rules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.SuccessPolicy.class, io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder.class);
    }

    public static final int RULES_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule> rules_;
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * rules represents the list of alternative rules for the declaring the Jobs
     * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
     * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
     * The terminal state for such a Job has the "Complete" condition.
     * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
     * other rules are ignored. At most 20 elements are allowed.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
     */
    public io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(1, rules_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, rules_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.SuccessPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.SuccessPolicy other = (io.kubernetes.client.proto.V1Batch.SuccessPolicy) obj;

      boolean result = true;
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.SuccessPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * SuccessPolicy describes when a Job can be declared as succeeded based on the success of some indexes.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.SuccessPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.SuccessPolicy)
        io.kubernetes.client.proto.V1Batch.SuccessPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.SuccessPolicy.class, io.kubernetes.client.proto.V1Batch.SuccessPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.SuccessPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRulesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.SuccessPolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.SuccessPolicy build() {
        io.kubernetes.client.proto.V1Batch.SuccessPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.SuccessPolicy buildPartial() {
        io.kubernetes.client.proto.V1Batch.SuccessPolicy result = new io.kubernetes.client.proto.V1Batch.SuccessPolicy(this);
        int from_bitField0_ = bitField0_;
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.SuccessPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.SuccessPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.SuccessPolicy other) {
        if (other == io.kubernetes.client.proto.V1Batch.SuccessPolicy.getDefaultInstance()) return this;
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.SuccessPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.SuccessPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule>(rules_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.SuccessPolicyRule, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder, io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Batch.SuccessPolicyRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Batch.SuccessPolicyRule> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.getDefaultInstance());
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.getDefaultInstance());
      }
      /**
       * <pre>
       * rules represents the list of alternative rules for the declaring the Jobs
       * as successful before `.status.succeeded &gt;= .spec.completions`. Once any of the rules are met,
       * the "SuccessCriteriaMet" condition is added, and the lingering pods are removed.
       * The terminal state for such a Job has the "Complete" condition.
       * Additionally, these rules are evaluated in order; Once the Job meets one of the rules,
       * other rules are ignored. At most 20 elements are allowed.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.batch.v1.SuccessPolicyRule rules = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Batch.SuccessPolicyRule, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder, io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Batch.SuccessPolicyRule, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder, io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.SuccessPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.SuccessPolicy)
    private static final io.kubernetes.client.proto.V1Batch.SuccessPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.SuccessPolicy();
    }

    public static io.kubernetes.client.proto.V1Batch.SuccessPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<SuccessPolicy>
        PARSER = new com.google.protobuf.AbstractParser<SuccessPolicy>() {
      @java.lang.Override
      public SuccessPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SuccessPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SuccessPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SuccessPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.SuccessPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SuccessPolicyRuleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.SuccessPolicyRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * succeededIndexes specifies the set of indexes
     * which need to be contained in the actual set of the succeeded indexes for the Job.
     * The list of indexes must be within 0 to ".spec.completions-1" and
     * must not contain duplicates. At least one element is required.
     * The indexes are represented as intervals separated by commas.
     * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
     * The number are listed in represented by the first and last element of the series,
     * separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * When this field is null, this field doesn't default to any value
     * and is never evaluated at any time.
     * +optional
     * </pre>
     *
     * <code>optional string succeededIndexes = 1;</code>
     */
    boolean hasSucceededIndexes();
    /**
     * <pre>
     * succeededIndexes specifies the set of indexes
     * which need to be contained in the actual set of the succeeded indexes for the Job.
     * The list of indexes must be within 0 to ".spec.completions-1" and
     * must not contain duplicates. At least one element is required.
     * The indexes are represented as intervals separated by commas.
     * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
     * The number are listed in represented by the first and last element of the series,
     * separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * When this field is null, this field doesn't default to any value
     * and is never evaluated at any time.
     * +optional
     * </pre>
     *
     * <code>optional string succeededIndexes = 1;</code>
     */
    java.lang.String getSucceededIndexes();
    /**
     * <pre>
     * succeededIndexes specifies the set of indexes
     * which need to be contained in the actual set of the succeeded indexes for the Job.
     * The list of indexes must be within 0 to ".spec.completions-1" and
     * must not contain duplicates. At least one element is required.
     * The indexes are represented as intervals separated by commas.
     * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
     * The number are listed in represented by the first and last element of the series,
     * separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * When this field is null, this field doesn't default to any value
     * and is never evaluated at any time.
     * +optional
     * </pre>
     *
     * <code>optional string succeededIndexes = 1;</code>
     */
    com.google.protobuf.ByteString
        getSucceededIndexesBytes();

    /**
     * <pre>
     * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
     * for the Job. When succeededCount is used along with succeededIndexes, the check is
     * constrained only to the set of indexes specified by succeededIndexes.
     * For example, given that succeededIndexes is "1-4", succeededCount is "3",
     * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
     * because only "1" and "3" indexes are considered in that rules.
     * When this field is null, this doesn't default to any value and
     * is never evaluated at any time.
     * When specified it needs to be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeededCount = 2;</code>
     */
    boolean hasSucceededCount();
    /**
     * <pre>
     * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
     * for the Job. When succeededCount is used along with succeededIndexes, the check is
     * constrained only to the set of indexes specified by succeededIndexes.
     * For example, given that succeededIndexes is "1-4", succeededCount is "3",
     * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
     * because only "1" and "3" indexes are considered in that rules.
     * When this field is null, this doesn't default to any value and
     * is never evaluated at any time.
     * When specified it needs to be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeededCount = 2;</code>
     */
    int getSucceededCount();
  }
  /**
   * <pre>
   * SuccessPolicyRule describes rule for declaring a Job as succeeded.
   * Each rule must have at least one of the "succeededIndexes" or "succeededCount" specified.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.SuccessPolicyRule}
   */
  public  static final class SuccessPolicyRule extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.SuccessPolicyRule)
      SuccessPolicyRuleOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SuccessPolicyRule.newBuilder() to construct.
    private SuccessPolicyRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SuccessPolicyRule() {
      succeededIndexes_ = "";
      succeededCount_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SuccessPolicyRule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              succeededIndexes_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              succeededCount_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.class, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder.class);
    }

    private int bitField0_;
    public static final int SUCCEEDEDINDEXES_FIELD_NUMBER = 1;
    private volatile java.lang.Object succeededIndexes_;
    /**
     * <pre>
     * succeededIndexes specifies the set of indexes
     * which need to be contained in the actual set of the succeeded indexes for the Job.
     * The list of indexes must be within 0 to ".spec.completions-1" and
     * must not contain duplicates. At least one element is required.
     * The indexes are represented as intervals separated by commas.
     * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
     * The number are listed in represented by the first and last element of the series,
     * separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * When this field is null, this field doesn't default to any value
     * and is never evaluated at any time.
     * +optional
     * </pre>
     *
     * <code>optional string succeededIndexes = 1;</code>
     */
    public boolean hasSucceededIndexes() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * succeededIndexes specifies the set of indexes
     * which need to be contained in the actual set of the succeeded indexes for the Job.
     * The list of indexes must be within 0 to ".spec.completions-1" and
     * must not contain duplicates. At least one element is required.
     * The indexes are represented as intervals separated by commas.
     * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
     * The number are listed in represented by the first and last element of the series,
     * separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * When this field is null, this field doesn't default to any value
     * and is never evaluated at any time.
     * +optional
     * </pre>
     *
     * <code>optional string succeededIndexes = 1;</code>
     */
    public java.lang.String getSucceededIndexes() {
      java.lang.Object ref = succeededIndexes_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          succeededIndexes_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * succeededIndexes specifies the set of indexes
     * which need to be contained in the actual set of the succeeded indexes for the Job.
     * The list of indexes must be within 0 to ".spec.completions-1" and
     * must not contain duplicates. At least one element is required.
     * The indexes are represented as intervals separated by commas.
     * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
     * The number are listed in represented by the first and last element of the series,
     * separated by a hyphen.
     * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
     * represented as "1,3-5,7".
     * When this field is null, this field doesn't default to any value
     * and is never evaluated at any time.
     * +optional
     * </pre>
     *
     * <code>optional string succeededIndexes = 1;</code>
     */
    public com.google.protobuf.ByteString
        getSucceededIndexesBytes() {
      java.lang.Object ref = succeededIndexes_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        succeededIndexes_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SUCCEEDEDCOUNT_FIELD_NUMBER = 2;
    private int succeededCount_;
    /**
     * <pre>
     * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
     * for the Job. When succeededCount is used along with succeededIndexes, the check is
     * constrained only to the set of indexes specified by succeededIndexes.
     * For example, given that succeededIndexes is "1-4", succeededCount is "3",
     * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
     * because only "1" and "3" indexes are considered in that rules.
     * When this field is null, this doesn't default to any value and
     * is never evaluated at any time.
     * When specified it needs to be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeededCount = 2;</code>
     */
    public boolean hasSucceededCount() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
     * for the Job. When succeededCount is used along with succeededIndexes, the check is
     * constrained only to the set of indexes specified by succeededIndexes.
     * For example, given that succeededIndexes is "1-4", succeededCount is "3",
     * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
     * because only "1" and "3" indexes are considered in that rules.
     * When this field is null, this doesn't default to any value and
     * is never evaluated at any time.
     * When specified it needs to be a positive integer.
     * +optional
     * </pre>
     *
     * <code>optional int32 succeededCount = 2;</code>
     */
    public int getSucceededCount() {
      return succeededCount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, succeededIndexes_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, succeededCount_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, succeededIndexes_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, succeededCount_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.SuccessPolicyRule)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.SuccessPolicyRule other = (io.kubernetes.client.proto.V1Batch.SuccessPolicyRule) obj;

      boolean result = true;
      result = result && (hasSucceededIndexes() == other.hasSucceededIndexes());
      if (hasSucceededIndexes()) {
        result = result && getSucceededIndexes()
            .equals(other.getSucceededIndexes());
      }
      result = result && (hasSucceededCount() == other.hasSucceededCount());
      if (hasSucceededCount()) {
        result = result && (getSucceededCount()
            == other.getSucceededCount());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSucceededIndexes()) {
        hash = (37 * hash) + SUCCEEDEDINDEXES_FIELD_NUMBER;
        hash = (53 * hash) + getSucceededIndexes().hashCode();
      }
      if (hasSucceededCount()) {
        hash = (37 * hash) + SUCCEEDEDCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getSucceededCount();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.SuccessPolicyRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * SuccessPolicyRule describes rule for declaring a Job as succeeded.
     * Each rule must have at least one of the "succeededIndexes" or "succeededCount" specified.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.SuccessPolicyRule}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.SuccessPolicyRule)
        io.kubernetes.client.proto.V1Batch.SuccessPolicyRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.class, io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        succeededIndexes_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        succeededCount_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule build() {
        io.kubernetes.client.proto.V1Batch.SuccessPolicyRule result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule buildPartial() {
        io.kubernetes.client.proto.V1Batch.SuccessPolicyRule result = new io.kubernetes.client.proto.V1Batch.SuccessPolicyRule(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.succeededIndexes_ = succeededIndexes_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.succeededCount_ = succeededCount_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.SuccessPolicyRule) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.SuccessPolicyRule)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.SuccessPolicyRule other) {
        if (other == io.kubernetes.client.proto.V1Batch.SuccessPolicyRule.getDefaultInstance()) return this;
        if (other.hasSucceededIndexes()) {
          bitField0_ |= 0x00000001;
          succeededIndexes_ = other.succeededIndexes_;
          onChanged();
        }
        if (other.hasSucceededCount()) {
          setSucceededCount(other.getSucceededCount());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.SuccessPolicyRule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.SuccessPolicyRule) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object succeededIndexes_ = "";
      /**
       * <pre>
       * succeededIndexes specifies the set of indexes
       * which need to be contained in the actual set of the succeeded indexes for the Job.
       * The list of indexes must be within 0 to ".spec.completions-1" and
       * must not contain duplicates. At least one element is required.
       * The indexes are represented as intervals separated by commas.
       * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
       * The number are listed in represented by the first and last element of the series,
       * separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * When this field is null, this field doesn't default to any value
       * and is never evaluated at any time.
       * +optional
       * </pre>
       *
       * <code>optional string succeededIndexes = 1;</code>
       */
      public boolean hasSucceededIndexes() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * succeededIndexes specifies the set of indexes
       * which need to be contained in the actual set of the succeeded indexes for the Job.
       * The list of indexes must be within 0 to ".spec.completions-1" and
       * must not contain duplicates. At least one element is required.
       * The indexes are represented as intervals separated by commas.
       * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
       * The number are listed in represented by the first and last element of the series,
       * separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * When this field is null, this field doesn't default to any value
       * and is never evaluated at any time.
       * +optional
       * </pre>
       *
       * <code>optional string succeededIndexes = 1;</code>
       */
      public java.lang.String getSucceededIndexes() {
        java.lang.Object ref = succeededIndexes_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            succeededIndexes_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * succeededIndexes specifies the set of indexes
       * which need to be contained in the actual set of the succeeded indexes for the Job.
       * The list of indexes must be within 0 to ".spec.completions-1" and
       * must not contain duplicates. At least one element is required.
       * The indexes are represented as intervals separated by commas.
       * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
       * The number are listed in represented by the first and last element of the series,
       * separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * When this field is null, this field doesn't default to any value
       * and is never evaluated at any time.
       * +optional
       * </pre>
       *
       * <code>optional string succeededIndexes = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSucceededIndexesBytes() {
        java.lang.Object ref = succeededIndexes_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          succeededIndexes_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * succeededIndexes specifies the set of indexes
       * which need to be contained in the actual set of the succeeded indexes for the Job.
       * The list of indexes must be within 0 to ".spec.completions-1" and
       * must not contain duplicates. At least one element is required.
       * The indexes are represented as intervals separated by commas.
       * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
       * The number are listed in represented by the first and last element of the series,
       * separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * When this field is null, this field doesn't default to any value
       * and is never evaluated at any time.
       * +optional
       * </pre>
       *
       * <code>optional string succeededIndexes = 1;</code>
       */
      public Builder setSucceededIndexes(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        succeededIndexes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeededIndexes specifies the set of indexes
       * which need to be contained in the actual set of the succeeded indexes for the Job.
       * The list of indexes must be within 0 to ".spec.completions-1" and
       * must not contain duplicates. At least one element is required.
       * The indexes are represented as intervals separated by commas.
       * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
       * The number are listed in represented by the first and last element of the series,
       * separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * When this field is null, this field doesn't default to any value
       * and is never evaluated at any time.
       * +optional
       * </pre>
       *
       * <code>optional string succeededIndexes = 1;</code>
       */
      public Builder clearSucceededIndexes() {
        bitField0_ = (bitField0_ & ~0x00000001);
        succeededIndexes_ = getDefaultInstance().getSucceededIndexes();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeededIndexes specifies the set of indexes
       * which need to be contained in the actual set of the succeeded indexes for the Job.
       * The list of indexes must be within 0 to ".spec.completions-1" and
       * must not contain duplicates. At least one element is required.
       * The indexes are represented as intervals separated by commas.
       * The intervals can be a decimal integer or a pair of decimal integers separated by a hyphen.
       * The number are listed in represented by the first and last element of the series,
       * separated by a hyphen.
       * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
       * represented as "1,3-5,7".
       * When this field is null, this field doesn't default to any value
       * and is never evaluated at any time.
       * +optional
       * </pre>
       *
       * <code>optional string succeededIndexes = 1;</code>
       */
      public Builder setSucceededIndexesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        succeededIndexes_ = value;
        onChanged();
        return this;
      }

      private int succeededCount_ ;
      /**
       * <pre>
       * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
       * for the Job. When succeededCount is used along with succeededIndexes, the check is
       * constrained only to the set of indexes specified by succeededIndexes.
       * For example, given that succeededIndexes is "1-4", succeededCount is "3",
       * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
       * because only "1" and "3" indexes are considered in that rules.
       * When this field is null, this doesn't default to any value and
       * is never evaluated at any time.
       * When specified it needs to be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeededCount = 2;</code>
       */
      public boolean hasSucceededCount() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
       * for the Job. When succeededCount is used along with succeededIndexes, the check is
       * constrained only to the set of indexes specified by succeededIndexes.
       * For example, given that succeededIndexes is "1-4", succeededCount is "3",
       * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
       * because only "1" and "3" indexes are considered in that rules.
       * When this field is null, this doesn't default to any value and
       * is never evaluated at any time.
       * When specified it needs to be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeededCount = 2;</code>
       */
      public int getSucceededCount() {
        return succeededCount_;
      }
      /**
       * <pre>
       * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
       * for the Job. When succeededCount is used along with succeededIndexes, the check is
       * constrained only to the set of indexes specified by succeededIndexes.
       * For example, given that succeededIndexes is "1-4", succeededCount is "3",
       * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
       * because only "1" and "3" indexes are considered in that rules.
       * When this field is null, this doesn't default to any value and
       * is never evaluated at any time.
       * When specified it needs to be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeededCount = 2;</code>
       */
      public Builder setSucceededCount(int value) {
        bitField0_ |= 0x00000002;
        succeededCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeededCount specifies the minimal required size of the actual set of the succeeded indexes
       * for the Job. When succeededCount is used along with succeededIndexes, the check is
       * constrained only to the set of indexes specified by succeededIndexes.
       * For example, given that succeededIndexes is "1-4", succeededCount is "3",
       * and completed indexes are "1", "3", and "5", the Job isn't declared as succeeded
       * because only "1" and "3" indexes are considered in that rules.
       * When this field is null, this doesn't default to any value and
       * is never evaluated at any time.
       * When specified it needs to be a positive integer.
       * +optional
       * </pre>
       *
       * <code>optional int32 succeededCount = 2;</code>
       */
      public Builder clearSucceededCount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        succeededCount_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.SuccessPolicyRule)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.SuccessPolicyRule)
    private static final io.kubernetes.client.proto.V1Batch.SuccessPolicyRule DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.SuccessPolicyRule();
    }

    public static io.kubernetes.client.proto.V1Batch.SuccessPolicyRule getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<SuccessPolicyRule>
        PARSER = new com.google.protobuf.AbstractParser<SuccessPolicyRule>() {
      @java.lang.Override
      public SuccessPolicyRule parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SuccessPolicyRule(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SuccessPolicyRule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SuccessPolicyRule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.SuccessPolicyRule getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface UncountedTerminatedPodsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.batch.v1.UncountedTerminatedPods)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    java.util.List<java.lang.String>
        getSucceededList();
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    int getSucceededCount();
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    java.lang.String getSucceeded(int index);
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    com.google.protobuf.ByteString
        getSucceededBytes(int index);

    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    java.util.List<java.lang.String>
        getFailedList();
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    int getFailedCount();
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    java.lang.String getFailed(int index);
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    com.google.protobuf.ByteString
        getFailedBytes(int index);
  }
  /**
   * <pre>
   * UncountedTerminatedPods holds UIDs of Pods that have terminated but haven't
   * been accounted in Job status counters.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.batch.v1.UncountedTerminatedPods}
   */
  public  static final class UncountedTerminatedPods extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.batch.v1.UncountedTerminatedPods)
      UncountedTerminatedPodsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use UncountedTerminatedPods.newBuilder() to construct.
    private UncountedTerminatedPods(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private UncountedTerminatedPods() {
      succeeded_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      failed_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private UncountedTerminatedPods(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                succeeded_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              succeeded_.add(bs);
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                failed_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000002;
              }
              failed_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          succeeded_ = succeeded_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          failed_ = failed_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.class, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder.class);
    }

    public static final int SUCCEEDED_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList succeeded_;
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getSucceededList() {
      return succeeded_;
    }
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    public int getSucceededCount() {
      return succeeded_.size();
    }
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    public java.lang.String getSucceeded(int index) {
      return succeeded_.get(index);
    }
    /**
     * <pre>
     * succeeded holds UIDs of succeeded Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string succeeded = 1;</code>
     */
    public com.google.protobuf.ByteString
        getSucceededBytes(int index) {
      return succeeded_.getByteString(index);
    }

    public static final int FAILED_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList failed_;
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getFailedList() {
      return failed_;
    }
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    public int getFailedCount() {
      return failed_.size();
    }
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    public java.lang.String getFailed(int index) {
      return failed_.get(index);
    }
    /**
     * <pre>
     * failed holds UIDs of failed Pods.
     * +listType=set
     * +optional
     * </pre>
     *
     * <code>repeated string failed = 2;</code>
     */
    public com.google.protobuf.ByteString
        getFailedBytes(int index) {
      return failed_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < succeeded_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, succeeded_.getRaw(i));
      }
      for (int i = 0; i < failed_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, failed_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < succeeded_.size(); i++) {
          dataSize += computeStringSizeNoTag(succeeded_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getSucceededList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < failed_.size(); i++) {
          dataSize += computeStringSizeNoTag(failed_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getFailedList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods other = (io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods) obj;

      boolean result = true;
      result = result && getSucceededList()
          .equals(other.getSucceededList());
      result = result && getFailedList()
          .equals(other.getFailedList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSucceededCount() > 0) {
        hash = (37 * hash) + SUCCEEDED_FIELD_NUMBER;
        hash = (53 * hash) + getSucceededList().hashCode();
      }
      if (getFailedCount() > 0) {
        hash = (37 * hash) + FAILED_FIELD_NUMBER;
        hash = (53 * hash) + getFailedList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * UncountedTerminatedPods holds UIDs of Pods that have terminated but haven't
     * been accounted in Job status counters.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.batch.v1.UncountedTerminatedPods}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.batch.v1.UncountedTerminatedPods)
        io.kubernetes.client.proto.V1Batch.UncountedTerminatedPodsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.class, io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        succeeded_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        failed_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Batch.internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods build() {
        io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods buildPartial() {
        io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods result = new io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          succeeded_ = succeeded_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.succeeded_ = succeeded_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          failed_ = failed_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.failed_ = failed_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods) {
          return mergeFrom((io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods other) {
        if (other == io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods.getDefaultInstance()) return this;
        if (!other.succeeded_.isEmpty()) {
          if (succeeded_.isEmpty()) {
            succeeded_ = other.succeeded_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureSucceededIsMutable();
            succeeded_.addAll(other.succeeded_);
          }
          onChanged();
        }
        if (!other.failed_.isEmpty()) {
          if (failed_.isEmpty()) {
            failed_ = other.failed_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureFailedIsMutable();
            failed_.addAll(other.failed_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList succeeded_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureSucceededIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          succeeded_ = new com.google.protobuf.LazyStringArrayList(succeeded_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getSucceededList() {
        return succeeded_.getUnmodifiableView();
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public int getSucceededCount() {
        return succeeded_.size();
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public java.lang.String getSucceeded(int index) {
        return succeeded_.get(index);
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSucceededBytes(int index) {
        return succeeded_.getByteString(index);
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public Builder setSucceeded(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSucceededIsMutable();
        succeeded_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public Builder addSucceeded(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSucceededIsMutable();
        succeeded_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public Builder addAllSucceeded(
          java.lang.Iterable<java.lang.String> values) {
        ensureSucceededIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, succeeded_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public Builder clearSucceeded() {
        succeeded_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * succeeded holds UIDs of succeeded Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string succeeded = 1;</code>
       */
      public Builder addSucceededBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSucceededIsMutable();
        succeeded_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList failed_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureFailedIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          failed_ = new com.google.protobuf.LazyStringArrayList(failed_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getFailedList() {
        return failed_.getUnmodifiableView();
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public int getFailedCount() {
        return failed_.size();
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public java.lang.String getFailed(int index) {
        return failed_.get(index);
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public com.google.protobuf.ByteString
          getFailedBytes(int index) {
        return failed_.getByteString(index);
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public Builder setFailed(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureFailedIsMutable();
        failed_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public Builder addFailed(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureFailedIsMutable();
        failed_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public Builder addAllFailed(
          java.lang.Iterable<java.lang.String> values) {
        ensureFailedIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, failed_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public Builder clearFailed() {
        failed_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failed holds UIDs of failed Pods.
       * +listType=set
       * +optional
       * </pre>
       *
       * <code>repeated string failed = 2;</code>
       */
      public Builder addFailedBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureFailedIsMutable();
        failed_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.batch.v1.UncountedTerminatedPods)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.batch.v1.UncountedTerminatedPods)
    private static final io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods();
    }

    public static io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<UncountedTerminatedPods>
        PARSER = new com.google.protobuf.AbstractParser<UncountedTerminatedPods>() {
      @java.lang.Override
      public UncountedTerminatedPods parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new UncountedTerminatedPods(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<UncountedTerminatedPods> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<UncountedTerminatedPods> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Batch.UncountedTerminatedPods getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_CronJob_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_CronJob_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_CronJobList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_CronJobList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_CronJobSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_CronJobSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_CronJobStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_CronJobStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_Job_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_Job_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_JobCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_JobCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_JobList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_JobList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_JobSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_JobSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_JobStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_JobStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_JobTemplateSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_JobTemplateSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_PodFailurePolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_PodFailurePolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_SuccessPolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_SuccessPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n#k8s.io/api/batch/v1/generated.proto\022\023k" +
      "8s.io.api.batch.v1\032\"k8s.io/api/core/v1/g" +
      "enerated.proto\0324k8s.io/apimachinery/pkg/" +
      "apis/meta/v1/generated.proto\032/k8s.io/api" +
      "machinery/pkg/runtime/generated.proto\0326k" +
      "8s.io/apimachinery/pkg/runtime/schema/ge" +
      "nerated.proto\"\261\001\n\007CronJob\022B\n\010metadata\030\001 " +
      "\001(\01320.k8s.io.apimachinery.pkg.apis.meta." +
      "v1.ObjectMeta\022.\n\004spec\030\002 \001(\0132 .k8s.io.api" +
      ".batch.v1.CronJobSpec\0222\n\006status\030\003 \001(\0132\"." +
      "k8s.io.api.batch.v1.CronJobStatus\"|\n\013Cro" +
      "nJobList\022@\n\010metadata\030\001 \001(\0132..k8s.io.apim" +
      "achinery.pkg.apis.meta.v1.ListMeta\022+\n\005it" +
      "ems\030\002 \003(\0132\034.k8s.io.api.batch.v1.CronJob\"" +
      "\375\001\n\013CronJobSpec\022\020\n\010schedule\030\001 \001(\t\022\020\n\010tim" +
      "eZone\030\010 \001(\t\022\037\n\027startingDeadlineSeconds\030\002" +
      " \001(\003\022\031\n\021concurrencyPolicy\030\003 \001(\t\022\017\n\007suspe" +
      "nd\030\004 \001(\010\0229\n\013jobTemplate\030\005 \001(\0132$.k8s.io.a" +
      "pi.batch.v1.JobTemplateSpec\022\"\n\032successfu" +
      "lJobsHistoryLimit\030\006 \001(\005\022\036\n\026failedJobsHis" +
      "toryLimit\030\007 \001(\005\"\322\001\n\rCronJobStatus\0223\n\006act" +
      "ive\030\001 \003(\0132#.k8s.io.api.core.v1.ObjectRef" +
      "erence\022D\n\020lastScheduleTime\030\004 \001(\0132*.k8s.i" +
      "o.apimachinery.pkg.apis.meta.v1.Time\022F\n\022" +
      "lastSuccessfulTime\030\005 \001(\0132*.k8s.io.apimac" +
      "hinery.pkg.apis.meta.v1.Time\"\245\001\n\003Job\022B\n\010" +
      "metadata\030\001 \001(\01320.k8s.io.apimachinery.pkg" +
      ".apis.meta.v1.ObjectMeta\022*\n\004spec\030\002 \001(\0132\034" +
      ".k8s.io.api.batch.v1.JobSpec\022.\n\006status\030\003" +
      " \001(\0132\036.k8s.io.api.batch.v1.JobStatus\"\330\001\n" +
      "\014JobCondition\022\014\n\004type\030\001 \001(\t\022\016\n\006status\030\002 " +
      "\001(\t\022A\n\rlastProbeTime\030\003 \001(\0132*.k8s.io.apim" +
      "achinery.pkg.apis.meta.v1.Time\022F\n\022lastTr" +
      "ansitionTime\030\004 \001(\0132*.k8s.io.apimachinery" +
      ".pkg.apis.meta.v1.Time\022\016\n\006reason\030\005 \001(\t\022\017" +
      "\n\007message\030\006 \001(\t\"t\n\007JobList\022@\n\010metadata\030\001" +
      " \001(\0132..k8s.io.apimachinery.pkg.apis.meta" +
      ".v1.ListMeta\022\'\n\005items\030\002 \003(\0132\030.k8s.io.api" +
      ".batch.v1.Job\"\255\004\n\007JobSpec\022\023\n\013parallelism" +
      "\030\001 \001(\005\022\023\n\013completions\030\002 \001(\005\022\035\n\025activeDea" +
      "dlineSeconds\030\003 \001(\003\022?\n\020podFailurePolicy\030\013" +
      " \001(\0132%.k8s.io.api.batch.v1.PodFailurePol" +
      "icy\0229\n\rsuccessPolicy\030\020 \001(\0132\".k8s.io.api." +
      "batch.v1.SuccessPolicy\022\024\n\014backoffLimit\030\007" +
      " \001(\005\022\034\n\024backoffLimitPerIndex\030\014 \001(\005\022\030\n\020ma" +
      "xFailedIndexes\030\r \001(\005\022E\n\010selector\030\004 \001(\01323" +
      ".k8s.io.apimachinery.pkg.apis.meta.v1.La" +
      "belSelector\022\026\n\016manualSelector\030\005 \001(\010\0225\n\010t" +
      "emplate\030\006 \001(\0132#.k8s.io.api.core.v1.PodTe" +
      "mplateSpec\022\037\n\027ttlSecondsAfterFinished\030\010 " +
      "\001(\005\022\026\n\016completionMode\030\t \001(\t\022\017\n\007suspend\030\n" +
      " \001(\010\022\034\n\024podReplacementPolicy\030\016 \001(\t\022\021\n\tma" +
      "nagedBy\030\017 \001(\t\"\234\003\n\tJobStatus\0225\n\ncondition" +
      "s\030\001 \003(\0132!.k8s.io.api.batch.v1.JobConditi" +
      "on\022=\n\tstartTime\030\002 \001(\0132*.k8s.io.apimachin" +
      "ery.pkg.apis.meta.v1.Time\022B\n\016completionT" +
      "ime\030\003 \001(\0132*.k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.Time\022\016\n\006active\030\004 \001(\005\022\021\n\tsucceed" +
      "ed\030\005 \001(\005\022\016\n\006failed\030\006 \001(\005\022\023\n\013terminating\030" +
      "\013 \001(\005\022\030\n\020completedIndexes\030\007 \001(\t\022\025\n\rfaile" +
      "dIndexes\030\n \001(\t\022M\n\027uncountedTerminatedPod" +
      "s\030\010 \001(\0132,.k8s.io.api.batch.v1.UncountedT" +
      "erminatedPods\022\r\n\005ready\030\t \001(\005\"\201\001\n\017JobTemp" +
      "lateSpec\022B\n\010metadata\030\001 \001(\01320.k8s.io.apim" +
      "achinery.pkg.apis.meta.v1.ObjectMeta\022*\n\004" +
      "spec\030\002 \001(\0132\034.k8s.io.api.batch.v1.JobSpec" +
      "\"L\n\020PodFailurePolicy\0228\n\005rules\030\001 \003(\0132).k8" +
      "s.io.api.batch.v1.PodFailurePolicyRule\"a" +
      "\n&PodFailurePolicyOnExitCodesRequirement" +
      "\022\025\n\rcontainerName\030\001 \001(\t\022\020\n\010operator\030\002 \001(" +
      "\t\022\016\n\006values\030\003 \003(\005\"F\n&PodFailurePolicyOnP" +
      "odConditionsPattern\022\014\n\004type\030\001 \001(\t\022\016\n\006sta" +
      "tus\030\002 \001(\t\"\316\001\n\024PodFailurePolicyRule\022\016\n\006ac" +
      "tion\030\001 \001(\t\022P\n\013onExitCodes\030\002 \001(\0132;.k8s.io" +
      ".api.batch.v1.PodFailurePolicyOnExitCode" +
      "sRequirement\022T\n\017onPodConditions\030\003 \003(\0132;." +
      "k8s.io.api.batch.v1.PodFailurePolicyOnPo" +
      "dConditionsPattern\"F\n\rSuccessPolicy\0225\n\005r" +
      "ules\030\001 \003(\0132&.k8s.io.api.batch.v1.Success" +
      "PolicyRule\"E\n\021SuccessPolicyRule\022\030\n\020succe" +
      "ededIndexes\030\001 \001(\t\022\026\n\016succeededCount\030\002 \001(" +
      "\005\"<\n\027UncountedTerminatedPods\022\021\n\tsucceede" +
      "d\030\001 \003(\t\022\016\n\006failed\030\002 \003(\tB:\n\032io.kubernetes" +
      ".client.protoB\007V1BatchZ\023k8s.io/api/batch" +
      "/v1"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
        }, assigner);
    internal_static_k8s_io_api_batch_v1_CronJob_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_batch_v1_CronJob_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_CronJob_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_batch_v1_CronJobList_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_batch_v1_CronJobList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_CronJobList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_batch_v1_CronJobSpec_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_batch_v1_CronJobSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_CronJobSpec_descriptor,
        new java.lang.String[] { "Schedule", "TimeZone", "StartingDeadlineSeconds", "ConcurrencyPolicy", "Suspend", "JobTemplate", "SuccessfulJobsHistoryLimit", "FailedJobsHistoryLimit", });
    internal_static_k8s_io_api_batch_v1_CronJobStatus_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_batch_v1_CronJobStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_CronJobStatus_descriptor,
        new java.lang.String[] { "Active", "LastScheduleTime", "LastSuccessfulTime", });
    internal_static_k8s_io_api_batch_v1_Job_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_batch_v1_Job_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_Job_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_batch_v1_JobCondition_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_batch_v1_JobCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_JobCondition_descriptor,
        new java.lang.String[] { "Type", "Status", "LastProbeTime", "LastTransitionTime", "Reason", "Message", });
    internal_static_k8s_io_api_batch_v1_JobList_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_batch_v1_JobList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_JobList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_batch_v1_JobSpec_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_batch_v1_JobSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_JobSpec_descriptor,
        new java.lang.String[] { "Parallelism", "Completions", "ActiveDeadlineSeconds", "PodFailurePolicy", "SuccessPolicy", "BackoffLimit", "BackoffLimitPerIndex", "MaxFailedIndexes", "Selector", "ManualSelector", "Template", "TtlSecondsAfterFinished", "CompletionMode", "Suspend", "PodReplacementPolicy", "ManagedBy", });
    internal_static_k8s_io_api_batch_v1_JobStatus_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_batch_v1_JobStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_JobStatus_descriptor,
        new java.lang.String[] { "Conditions", "StartTime", "CompletionTime", "Active", "Succeeded", "Failed", "Terminating", "CompletedIndexes", "FailedIndexes", "UncountedTerminatedPods", "Ready", });
    internal_static_k8s_io_api_batch_v1_JobTemplateSpec_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_batch_v1_JobTemplateSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_JobTemplateSpec_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_batch_v1_PodFailurePolicy_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_batch_v1_PodFailurePolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_PodFailurePolicy_descriptor,
        new java.lang.String[] { "Rules", });
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnExitCodesRequirement_descriptor,
        new java.lang.String[] { "ContainerName", "Operator", "Values", });
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_PodFailurePolicyOnPodConditionsPattern_descriptor,
        new java.lang.String[] { "Type", "Status", });
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_PodFailurePolicyRule_descriptor,
        new java.lang.String[] { "Action", "OnExitCodes", "OnPodConditions", });
    internal_static_k8s_io_api_batch_v1_SuccessPolicy_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_batch_v1_SuccessPolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_SuccessPolicy_descriptor,
        new java.lang.String[] { "Rules", });
    internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_SuccessPolicyRule_descriptor,
        new java.lang.String[] { "SucceededIndexes", "SucceededCount", });
    internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_batch_v1_UncountedTerminatedPods_descriptor,
        new java.lang.String[] { "Succeeded", "Failed", });
    io.kubernetes.client.proto.V1.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
