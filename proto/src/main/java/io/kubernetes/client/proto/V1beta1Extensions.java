/*
Copyright 2021 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package io.kubernetes.client.proto;

public final class V1beta1Extensions {
  private V1beta1Extensions() {}

  public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry) {}

  public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions((com.google.protobuf.ExtensionRegistryLite) registry);
  }

  public interface AllowedCSIDriverOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.AllowedCSIDriver)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Name is the registered name of the CSI driver
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     *
     *
     * <pre>
     * Name is the registered name of the CSI driver
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     *
     *
     * <pre>
     * Name is the registered name of the CSI driver
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString getNameBytes();
  }
  /**
   *
   *
   * <pre>
   * AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.AllowedCSIDriver}
   */
  public static final class AllowedCSIDriver extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.AllowedCSIDriver)
      AllowedCSIDriverOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use AllowedCSIDriver.newBuilder() to construct.
    private AllowedCSIDriver(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AllowedCSIDriver() {
      name_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private AllowedCSIDriver(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                name_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.class,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     *
     *
     * <pre>
     * Name is the registered name of the CSI driver
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Name is the registered name of the CSI driver
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Name is the registered name of the CSI driver
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver other =
          (io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName().equals(other.getName());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.AllowedCSIDriver}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.AllowedCSIDriver)
        io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.class,
                io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver build() {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver result =
            new io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.getDefaultInstance())
          return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       *
       *
       * <pre>
       * Name is the registered name of the CSI driver
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Name is the registered name of the CSI driver
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Name is the registered name of the CSI driver
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Name is the registered name of the CSI driver
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Name is the registered name of the CSI driver
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Name is the registered name of the CSI driver
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.AllowedCSIDriver)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.AllowedCSIDriver)
    private static final io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<AllowedCSIDriver> PARSER =
        new com.google.protobuf.AbstractParser<AllowedCSIDriver>() {
          @java.lang.Override
          public AllowedCSIDriver parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new AllowedCSIDriver(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<AllowedCSIDriver> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AllowedCSIDriver> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AllowedFlexVolumeOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.AllowedFlexVolume)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * driver is the name of the Flexvolume driver.
     * </pre>
     *
     * <code>optional string driver = 1;</code>
     */
    boolean hasDriver();
    /**
     *
     *
     * <pre>
     * driver is the name of the Flexvolume driver.
     * </pre>
     *
     * <code>optional string driver = 1;</code>
     */
    java.lang.String getDriver();
    /**
     *
     *
     * <pre>
     * driver is the name of the Flexvolume driver.
     * </pre>
     *
     * <code>optional string driver = 1;</code>
     */
    com.google.protobuf.ByteString getDriverBytes();
  }
  /**
   *
   *
   * <pre>
   * AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
   * Deprecated: use AllowedFlexVolume from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.AllowedFlexVolume}
   */
  public static final class AllowedFlexVolume extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.AllowedFlexVolume)
      AllowedFlexVolumeOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use AllowedFlexVolume.newBuilder() to construct.
    private AllowedFlexVolume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AllowedFlexVolume() {
      driver_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private AllowedFlexVolume(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                driver_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.class,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder.class);
    }

    private int bitField0_;
    public static final int DRIVER_FIELD_NUMBER = 1;
    private volatile java.lang.Object driver_;
    /**
     *
     *
     * <pre>
     * driver is the name of the Flexvolume driver.
     * </pre>
     *
     * <code>optional string driver = 1;</code>
     */
    public boolean hasDriver() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * driver is the name of the Flexvolume driver.
     * </pre>
     *
     * <code>optional string driver = 1;</code>
     */
    public java.lang.String getDriver() {
      java.lang.Object ref = driver_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          driver_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * driver is the name of the Flexvolume driver.
     * </pre>
     *
     * <code>optional string driver = 1;</code>
     */
    public com.google.protobuf.ByteString getDriverBytes() {
      java.lang.Object ref = driver_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        driver_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, driver_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, driver_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume other =
          (io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume) obj;

      boolean result = true;
      result = result && (hasDriver() == other.hasDriver());
      if (hasDriver()) {
        result = result && getDriver().equals(other.getDriver());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasDriver()) {
        hash = (37 * hash) + DRIVER_FIELD_NUMBER;
        hash = (53 * hash) + getDriver().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
     * Deprecated: use AllowedFlexVolume from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.AllowedFlexVolume}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.AllowedFlexVolume)
        io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.class,
                io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        driver_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume build() {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume result =
            new io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.driver_ = driver_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.getDefaultInstance())
          return this;
        if (other.hasDriver()) {
          bitField0_ |= 0x00000001;
          driver_ = other.driver_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object driver_ = "";
      /**
       *
       *
       * <pre>
       * driver is the name of the Flexvolume driver.
       * </pre>
       *
       * <code>optional string driver = 1;</code>
       */
      public boolean hasDriver() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * driver is the name of the Flexvolume driver.
       * </pre>
       *
       * <code>optional string driver = 1;</code>
       */
      public java.lang.String getDriver() {
        java.lang.Object ref = driver_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            driver_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * driver is the name of the Flexvolume driver.
       * </pre>
       *
       * <code>optional string driver = 1;</code>
       */
      public com.google.protobuf.ByteString getDriverBytes() {
        java.lang.Object ref = driver_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          driver_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * driver is the name of the Flexvolume driver.
       * </pre>
       *
       * <code>optional string driver = 1;</code>
       */
      public Builder setDriver(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        driver_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * driver is the name of the Flexvolume driver.
       * </pre>
       *
       * <code>optional string driver = 1;</code>
       */
      public Builder clearDriver() {
        bitField0_ = (bitField0_ & ~0x00000001);
        driver_ = getDefaultInstance().getDriver();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * driver is the name of the Flexvolume driver.
       * </pre>
       *
       * <code>optional string driver = 1;</code>
       */
      public Builder setDriverBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        driver_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.AllowedFlexVolume)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.AllowedFlexVolume)
    private static final io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<AllowedFlexVolume> PARSER =
        new com.google.protobuf.AbstractParser<AllowedFlexVolume>() {
          @java.lang.Override
          public AllowedFlexVolume parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new AllowedFlexVolume(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<AllowedFlexVolume> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AllowedFlexVolume> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AllowedHostPathOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.AllowedHostPath)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * pathPrefix is the path prefix that the host volume must match.
     * It does not support `*`.
     * Trailing slashes are trimmed when validating the path prefix with a host path.
     * Examples:
     * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
     * `/foo` would not allow `/food` or `/etc/foo`
     * </pre>
     *
     * <code>optional string pathPrefix = 1;</code>
     */
    boolean hasPathPrefix();
    /**
     *
     *
     * <pre>
     * pathPrefix is the path prefix that the host volume must match.
     * It does not support `*`.
     * Trailing slashes are trimmed when validating the path prefix with a host path.
     * Examples:
     * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
     * `/foo` would not allow `/food` or `/etc/foo`
     * </pre>
     *
     * <code>optional string pathPrefix = 1;</code>
     */
    java.lang.String getPathPrefix();
    /**
     *
     *
     * <pre>
     * pathPrefix is the path prefix that the host volume must match.
     * It does not support `*`.
     * Trailing slashes are trimmed when validating the path prefix with a host path.
     * Examples:
     * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
     * `/foo` would not allow `/food` or `/etc/foo`
     * </pre>
     *
     * <code>optional string pathPrefix = 1;</code>
     */
    com.google.protobuf.ByteString getPathPrefixBytes();

    /**
     *
     *
     * <pre>
     * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnly = 2;</code>
     */
    boolean hasReadOnly();
    /**
     *
     *
     * <pre>
     * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnly = 2;</code>
     */
    boolean getReadOnly();
  }
  /**
   *
   *
   * <pre>
   * AllowedHostPath defines the host volume conditions that will be enabled by a policy
   * for pods to use. It requires the path prefix to be defined.
   * Deprecated: use AllowedHostPath from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.AllowedHostPath}
   */
  public static final class AllowedHostPath extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.AllowedHostPath)
      AllowedHostPathOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use AllowedHostPath.newBuilder() to construct.
    private AllowedHostPath(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AllowedHostPath() {
      pathPrefix_ = "";
      readOnly_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private AllowedHostPath(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                pathPrefix_ = bs;
                break;
              }
            case 16:
              {
                bitField0_ |= 0x00000002;
                readOnly_ = input.readBool();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.class,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder.class);
    }

    private int bitField0_;
    public static final int PATHPREFIX_FIELD_NUMBER = 1;
    private volatile java.lang.Object pathPrefix_;
    /**
     *
     *
     * <pre>
     * pathPrefix is the path prefix that the host volume must match.
     * It does not support `*`.
     * Trailing slashes are trimmed when validating the path prefix with a host path.
     * Examples:
     * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
     * `/foo` would not allow `/food` or `/etc/foo`
     * </pre>
     *
     * <code>optional string pathPrefix = 1;</code>
     */
    public boolean hasPathPrefix() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * pathPrefix is the path prefix that the host volume must match.
     * It does not support `*`.
     * Trailing slashes are trimmed when validating the path prefix with a host path.
     * Examples:
     * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
     * `/foo` would not allow `/food` or `/etc/foo`
     * </pre>
     *
     * <code>optional string pathPrefix = 1;</code>
     */
    public java.lang.String getPathPrefix() {
      java.lang.Object ref = pathPrefix_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          pathPrefix_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * pathPrefix is the path prefix that the host volume must match.
     * It does not support `*`.
     * Trailing slashes are trimmed when validating the path prefix with a host path.
     * Examples:
     * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
     * `/foo` would not allow `/food` or `/etc/foo`
     * </pre>
     *
     * <code>optional string pathPrefix = 1;</code>
     */
    public com.google.protobuf.ByteString getPathPrefixBytes() {
      java.lang.Object ref = pathPrefix_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        pathPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int READONLY_FIELD_NUMBER = 2;
    private boolean readOnly_;
    /**
     *
     *
     * <pre>
     * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnly = 2;</code>
     */
    public boolean hasReadOnly() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnly = 2;</code>
     */
    public boolean getReadOnly() {
      return readOnly_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, pathPrefix_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBool(2, readOnly_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, pathPrefix_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(2, readOnly_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath other =
          (io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath) obj;

      boolean result = true;
      result = result && (hasPathPrefix() == other.hasPathPrefix());
      if (hasPathPrefix()) {
        result = result && getPathPrefix().equals(other.getPathPrefix());
      }
      result = result && (hasReadOnly() == other.hasReadOnly());
      if (hasReadOnly()) {
        result = result && (getReadOnly() == other.getReadOnly());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPathPrefix()) {
        hash = (37 * hash) + PATHPREFIX_FIELD_NUMBER;
        hash = (53 * hash) + getPathPrefix().hashCode();
      }
      if (hasReadOnly()) {
        hash = (37 * hash) + READONLY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getReadOnly());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * AllowedHostPath defines the host volume conditions that will be enabled by a policy
     * for pods to use. It requires the path prefix to be defined.
     * Deprecated: use AllowedHostPath from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.AllowedHostPath}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.AllowedHostPath)
        io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.class,
                io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        pathPrefix_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        readOnly_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath build() {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath result =
            new io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.pathPrefix_ = pathPrefix_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.readOnly_ = readOnly_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.getDefaultInstance())
          return this;
        if (other.hasPathPrefix()) {
          bitField0_ |= 0x00000001;
          pathPrefix_ = other.pathPrefix_;
          onChanged();
        }
        if (other.hasReadOnly()) {
          setReadOnly(other.getReadOnly());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object pathPrefix_ = "";
      /**
       *
       *
       * <pre>
       * pathPrefix is the path prefix that the host volume must match.
       * It does not support `*`.
       * Trailing slashes are trimmed when validating the path prefix with a host path.
       * Examples:
       * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
       * `/foo` would not allow `/food` or `/etc/foo`
       * </pre>
       *
       * <code>optional string pathPrefix = 1;</code>
       */
      public boolean hasPathPrefix() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * pathPrefix is the path prefix that the host volume must match.
       * It does not support `*`.
       * Trailing slashes are trimmed when validating the path prefix with a host path.
       * Examples:
       * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
       * `/foo` would not allow `/food` or `/etc/foo`
       * </pre>
       *
       * <code>optional string pathPrefix = 1;</code>
       */
      public java.lang.String getPathPrefix() {
        java.lang.Object ref = pathPrefix_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            pathPrefix_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * pathPrefix is the path prefix that the host volume must match.
       * It does not support `*`.
       * Trailing slashes are trimmed when validating the path prefix with a host path.
       * Examples:
       * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
       * `/foo` would not allow `/food` or `/etc/foo`
       * </pre>
       *
       * <code>optional string pathPrefix = 1;</code>
       */
      public com.google.protobuf.ByteString getPathPrefixBytes() {
        java.lang.Object ref = pathPrefix_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          pathPrefix_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * pathPrefix is the path prefix that the host volume must match.
       * It does not support `*`.
       * Trailing slashes are trimmed when validating the path prefix with a host path.
       * Examples:
       * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
       * `/foo` would not allow `/food` or `/etc/foo`
       * </pre>
       *
       * <code>optional string pathPrefix = 1;</code>
       */
      public Builder setPathPrefix(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        pathPrefix_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * pathPrefix is the path prefix that the host volume must match.
       * It does not support `*`.
       * Trailing slashes are trimmed when validating the path prefix with a host path.
       * Examples:
       * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
       * `/foo` would not allow `/food` or `/etc/foo`
       * </pre>
       *
       * <code>optional string pathPrefix = 1;</code>
       */
      public Builder clearPathPrefix() {
        bitField0_ = (bitField0_ & ~0x00000001);
        pathPrefix_ = getDefaultInstance().getPathPrefix();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * pathPrefix is the path prefix that the host volume must match.
       * It does not support `*`.
       * Trailing slashes are trimmed when validating the path prefix with a host path.
       * Examples:
       * `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
       * `/foo` would not allow `/food` or `/etc/foo`
       * </pre>
       *
       * <code>optional string pathPrefix = 1;</code>
       */
      public Builder setPathPrefixBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        pathPrefix_ = value;
        onChanged();
        return this;
      }

      private boolean readOnly_;
      /**
       *
       *
       * <pre>
       * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnly = 2;</code>
       */
      public boolean hasReadOnly() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnly = 2;</code>
       */
      public boolean getReadOnly() {
        return readOnly_;
      }
      /**
       *
       *
       * <pre>
       * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnly = 2;</code>
       */
      public Builder setReadOnly(boolean value) {
        bitField0_ |= 0x00000002;
        readOnly_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnly = 2;</code>
       */
      public Builder clearReadOnly() {
        bitField0_ = (bitField0_ & ~0x00000002);
        readOnly_ = false;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.AllowedHostPath)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.AllowedHostPath)
    private static final io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<AllowedHostPath> PARSER =
        new com.google.protobuf.AbstractParser<AllowedHostPath>() {
          @java.lang.Override
          public AllowedHostPath parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new AllowedHostPath(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<AllowedHostPath> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AllowedHostPath> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DaemonSetOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DaemonSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec getSpec();
    /**
     *
     *
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder getSpecOrBuilder();

    /**
     *
     *
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus getStatus();
    /**
     *
     *
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder getStatusOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for
   * more information.
   * DaemonSet represents the configuration of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSet}
   */
  public static final class DaemonSet extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DaemonSet)
      DaemonSetOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DaemonSet.newBuilder() to construct.
    private DaemonSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DaemonSet() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DaemonSet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = status_.toBuilder();
                }
                status_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(status_);
                  status_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.class,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec spec_;
    /**
     *
     *
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.getDefaultInstance()
          : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus status_;
    /**
     *
     *
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus getStatus() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.getDefaultInstance()
          : status_;
    }
    /**
     *
     *
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder
        getStatusOrBuilder() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.getDefaultInstance()
          : status_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DaemonSet other =
          (io.kubernetes.client.proto.V1beta1Extensions.DaemonSet) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for
     * more information.
     * DaemonSet represents the configuration of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSet}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DaemonSet)
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.class,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet build() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSet result =
            new io.kubernetes.client.proto.V1beta1Extensions.DaemonSet(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSet) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DaemonSet) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.DaemonSet other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSet) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec
                      .getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder
          getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder>
          statusBuilder_;
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.getDefaultInstance()
              : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public Builder mergeStatus(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && status_ != null
              && status_
                  != io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus
                      .getDefaultInstance()) {
            status_ =
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.newBuilder(status_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder
          getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder
          getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.getDefaultInstance()
              : status_;
        }
      }
      /**
       *
       *
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder>
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder>(
                  getStatus(), getParentForChildren(), isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DaemonSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DaemonSet)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DaemonSet DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DaemonSet();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DaemonSet> PARSER =
        new com.google.protobuf.AbstractParser<DaemonSet>() {
          @java.lang.Override
          public DaemonSet parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DaemonSet(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DaemonSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DaemonSetConditionOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DaemonSetCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     *
     *
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     *
     *
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString getTypeBytes();

    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    java.lang.String getStatus();
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    com.google.protobuf.ByteString getStatusBytes();

    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    boolean hasLastTransitionTime();
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    boolean hasReason();
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    java.lang.String getReason();
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    com.google.protobuf.ByteString getReasonBytes();

    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    boolean hasMessage();
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    java.lang.String getMessage();
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    com.google.protobuf.ByteString getMessageBytes();
  }
  /**
   *
   *
   * <pre>
   * DaemonSetCondition describes the state of a DaemonSet at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetCondition}
   */
  public static final class DaemonSetCondition extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DaemonSetCondition)
      DaemonSetConditionOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DaemonSetCondition.newBuilder() to construct.
    private DaemonSetCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DaemonSetCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DaemonSetCondition(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                type_ = bs;
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000002;
                status_ = bs;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = lastTransitionTime_.toBuilder();
                }
                lastTransitionTime_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(lastTransitionTime_);
                  lastTransitionTime_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 34:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000008;
                reason_ = bs;
                break;
              }
            case 42:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000010;
                message_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.class,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     *
     *
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Type of DaemonSet condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private volatile java.lang.Object status_;
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public com.google.protobuf.ByteString getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastTransitionTime_;
    }
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    private volatile java.lang.Object reason_;
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public boolean hasReason() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public com.google.protobuf.ByteString getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    private volatile java.lang.Object message_;
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public com.google.protobuf.ByteString getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, message_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, message_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition other =
          (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType().equals(other.getType());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && (hasLastTransitionTime() == other.hasLastTransitionTime());
      if (hasLastTransitionTime()) {
        result = result && getLastTransitionTime().equals(other.getLastTransitionTime());
      }
      result = result && (hasReason() == other.hasReason());
      if (hasReason()) {
        result = result && getReason().equals(other.getReason());
      }
      result = result && (hasMessage() == other.hasMessage());
      if (hasMessage()) {
        result = result && getMessage().equals(other.getMessage());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DaemonSetCondition describes the state of a DaemonSet at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetCondition}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DaemonSetCondition)
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.class,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getLastTransitionTimeFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        status_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        reason_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition build() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition result =
            new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.status_ = status_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (lastTransitionTimeBuilder_ == null) {
          result.lastTransitionTime_ = lastTransitionTime_;
        } else {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.reason_ = reason_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.message_ = message_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.getDefaultInstance())
          return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasStatus()) {
          bitField0_ |= 0x00000002;
          status_ = other.status_;
          onChanged();
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          bitField0_ |= 0x00000008;
          reason_ = other.reason_;
          onChanged();
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000010;
          message_ = other.message_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       *
       *
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of DaemonSet condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public com.google.protobuf.ByteString getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatus(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = getDefaultInstance().getStatus();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatusBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          lastTransitionTimeBuilder_;
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && lastTransitionTime_ != null
              && lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastTransitionTime_ =
                io.kubernetes.client.proto.Meta.Time.newBuilder(lastTransitionTime_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            lastTransitionTime_ = value;
          }
          onChanged();
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder clearLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastTransitionTime_;
        }
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.Time,
                  io.kubernetes.client.proto.Meta.Time.Builder,
                  io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(), getParentForChildren(), isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public com.google.protobuf.ByteString getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder setReason(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        reason_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000008);
        reason_ = getDefaultInstance().getReason();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder setReasonBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        reason_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public com.google.protobuf.ByteString getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder setMessage(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000010);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder setMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        message_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DaemonSetCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DaemonSetCondition)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DaemonSetCondition> PARSER =
        new com.google.protobuf.AbstractParser<DaemonSetCondition>() {
          @java.lang.Override
          public DaemonSetCondition parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DaemonSetCondition(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DaemonSetCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DaemonSetListOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DaemonSetList)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet> getItemsList();
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSet getItems(int index);
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    int getItemsCount();
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder>
        getItemsOrBuilderList();
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder getItemsOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * DaemonSetList is a collection of daemon sets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetList}
   */
  public static final class DaemonSetList extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DaemonSetList)
      DaemonSetListOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DaemonSetList.newBuilder() to construct.
    private DaemonSetList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DaemonSetList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DaemonSetList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  items_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.DaemonSet>();
                  mutable_bitField0_ |= 0x00000002;
                }
                items_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.class,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet> items_;
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet> getItemsList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder>
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet getItems(int index) {
      return items_.get(index);
    }
    /**
     *
     *
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList other =
          (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && getItemsList().equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DaemonSetList is a collection of daemon sets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetList}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DaemonSetList)
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.class,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList build() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList result =
            new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getItemsFieldBuilder()
                      : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ListMeta,
                  io.kubernetes.client.proto.Meta.ListMeta.Builder,
                  io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet> items_ =
          java.util.Collections.emptyList();

      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet>(
                  items_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSet,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder>
          itemsBuilder_;

      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder setItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Extensions.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSet>
              values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder>
          getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder addItemsBuilder() {
        return getItemsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder()
            .addBuilder(
                index, io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder>
          getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSet,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder>
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSet,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSet.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DaemonSetList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DaemonSetList)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DaemonSetList> PARSER =
        new com.google.protobuf.AbstractParser<DaemonSetList>() {
          @java.lang.Override
          public DaemonSetList parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DaemonSetList(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DaemonSetList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DaemonSetSpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DaemonSetSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    boolean hasSelector();
    /**
     *
     *
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     *
     *
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     *
     *
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    boolean hasTemplate();
    /**
     *
     *
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     *
     *
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     *
     *
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
     * </code>
     */
    boolean hasUpdateStrategy();
    /**
     *
     *
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy getUpdateStrategy();
    /**
     *
     *
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder
        getUpdateStrategyOrBuilder();

    /**
     *
     *
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    boolean hasMinReadySeconds();
    /**
     *
     *
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    int getMinReadySeconds();

    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * A sequence number representing a specific generation of the template.
     * Populated by the system. It can be set only during the creation.
     * +optional
     * </pre>
     *
     * <code>optional int64 templateGeneration = 5;</code>
     */
    boolean hasTemplateGeneration();
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * A sequence number representing a specific generation of the template.
     * Populated by the system. It can be set only during the creation.
     * +optional
     * </pre>
     *
     * <code>optional int64 templateGeneration = 5;</code>
     */
    long getTemplateGeneration();

    /**
     *
     *
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    boolean hasRevisionHistoryLimit();
    /**
     *
     *
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    int getRevisionHistoryLimit();
  }
  /**
   *
   *
   * <pre>
   * DaemonSetSpec is the specification of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetSpec}
   */
  public static final class DaemonSetSpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DaemonSetSpec)
      DaemonSetSpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DaemonSetSpec.newBuilder() to construct.
    private DaemonSetSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DaemonSetSpec() {
      minReadySeconds_ = 0;
      templateGeneration_ = 0L;
      revisionHistoryLimit_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DaemonSetSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = selector_.toBuilder();
                }
                selector_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(selector_);
                  selector_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1.PodTemplateSpec.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = template_.toBuilder();
                }
                template_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.PodTemplateSpec.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(template_);
                  template_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = updateStrategy_.toBuilder();
                }
                updateStrategy_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(updateStrategy_);
                  updateStrategy_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 32:
              {
                bitField0_ |= 0x00000008;
                minReadySeconds_ = input.readInt32();
                break;
              }
            case 40:
              {
                bitField0_ |= 0x00000010;
                templateGeneration_ = input.readInt64();
                break;
              }
            case 48:
              {
                bitField0_ |= 0x00000020;
                revisionHistoryLimit_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder.class);
    }

    private int bitField0_;
    public static final int SELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     *
     *
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : selector_;
    }
    /**
     *
     *
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     *
     *
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null
          ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
          : template_;
    }
    /**
     *
     *
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null
          ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
          : template_;
    }

    public static final int UPDATESTRATEGY_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy updateStrategy_;
    /**
     *
     *
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
     * </code>
     */
    public boolean hasUpdateStrategy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
        getUpdateStrategy() {
      return updateStrategy_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
              .getDefaultInstance()
          : updateStrategy_;
    }
    /**
     *
     *
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder
        getUpdateStrategyOrBuilder() {
      return updateStrategy_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
              .getDefaultInstance()
          : updateStrategy_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 4;
    private int minReadySeconds_;
    /**
     *
     *
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int TEMPLATEGENERATION_FIELD_NUMBER = 5;
    private long templateGeneration_;
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * A sequence number representing a specific generation of the template.
     * Populated by the system. It can be set only during the creation.
     * +optional
     * </pre>
     *
     * <code>optional int64 templateGeneration = 5;</code>
     */
    public boolean hasTemplateGeneration() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * A sequence number representing a specific generation of the template.
     * Populated by the system. It can be set only during the creation.
     * +optional
     * </pre>
     *
     * <code>optional int64 templateGeneration = 5;</code>
     */
    public long getTemplateGeneration() {
      return templateGeneration_;
    }

    public static final int REVISIONHISTORYLIMIT_FIELD_NUMBER = 6;
    private int revisionHistoryLimit_;
    /**
     *
     *
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    public boolean hasRevisionHistoryLimit() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     *
     *
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    public int getRevisionHistoryLimit() {
      return revisionHistoryLimit_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getTemplate());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(5, templateGeneration_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(6, revisionHistoryLimit_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getTemplate());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(5, templateGeneration_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(6, revisionHistoryLimit_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec) obj;

      boolean result = true;
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector().equals(other.getSelector());
      }
      result = result && (hasTemplate() == other.hasTemplate());
      if (hasTemplate()) {
        result = result && getTemplate().equals(other.getTemplate());
      }
      result = result && (hasUpdateStrategy() == other.hasUpdateStrategy());
      if (hasUpdateStrategy()) {
        result = result && getUpdateStrategy().equals(other.getUpdateStrategy());
      }
      result = result && (hasMinReadySeconds() == other.hasMinReadySeconds());
      if (hasMinReadySeconds()) {
        result = result && (getMinReadySeconds() == other.getMinReadySeconds());
      }
      result = result && (hasTemplateGeneration() == other.hasTemplateGeneration());
      if (hasTemplateGeneration()) {
        result = result && (getTemplateGeneration() == other.getTemplateGeneration());
      }
      result = result && (hasRevisionHistoryLimit() == other.hasRevisionHistoryLimit());
      if (hasRevisionHistoryLimit()) {
        result = result && (getRevisionHistoryLimit() == other.getRevisionHistoryLimit());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (hasUpdateStrategy()) {
        hash = (37 * hash) + UPDATESTRATEGY_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateStrategy().hashCode();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasTemplateGeneration()) {
        hash = (37 * hash) + TEMPLATEGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getTemplateGeneration());
      }
      if (hasRevisionHistoryLimit()) {
        hash = (37 * hash) + REVISIONHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getRevisionHistoryLimit();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DaemonSetSpec is the specification of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetSpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DaemonSetSpec)
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
          getUpdateStrategyFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (templateBuilder_ == null) {
          template_ = null;
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = null;
        } else {
          updateStrategyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        minReadySeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        templateGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        revisionHistoryLimit_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (templateBuilder_ == null) {
          result.template_ = template_;
        } else {
          result.template_ = templateBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (updateStrategyBuilder_ == null) {
          result.updateStrategy_ = updateStrategy_;
        } else {
          result.updateStrategy_ = updateStrategyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.minReadySeconds_ = minReadySeconds_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.templateGeneration_ = templateGeneration_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.revisionHistoryLimit_ = revisionHistoryLimit_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec.getDefaultInstance())
          return this;
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (other.hasUpdateStrategy()) {
          mergeUpdateStrategy(other.getUpdateStrategy());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasTemplateGeneration()) {
          setTemplateGeneration(other.getTemplateGeneration());
        }
        if (other.hasRevisionHistoryLimit()) {
          setRevisionHistoryLimit(other.getRevisionHistoryLimit());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          selectorBuilder_;
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && selector_ != null
              && selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
                io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : selector_;
        }
      }
      /**
       *
       *
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.LabelSelector,
                  io.kubernetes.client.proto.Meta.LabelSelector.Builder,
                  io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(), getParentForChildren(), isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec,
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
              io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>
          templateBuilder_;
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null
              ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
              : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
          onChanged();
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
          onChanged();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && template_ != null
              && template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            template_ =
                io.kubernetes.client.proto.V1.PodTemplateSpec.newBuilder(template_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            template_ = value;
          }
          onChanged();
        } else {
          templateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder clearTemplate() {
        if (templateBuilder_ == null) {
          template_ = null;
          onChanged();
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null
              ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
              : template_;
        }
      }
      /**
       *
       *
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec,
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
              io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1.PodTemplateSpec,
                  io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
                  io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(), getParentForChildren(), isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy updateStrategy_ =
          null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder>
          updateStrategyBuilder_;
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public boolean hasUpdateStrategy() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
          getUpdateStrategy() {
        if (updateStrategyBuilder_ == null) {
          return updateStrategy_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
                  .getDefaultInstance()
              : updateStrategy_;
        } else {
          return updateStrategyBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public Builder setUpdateStrategy(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          updateStrategy_ = value;
          onChanged();
        } else {
          updateStrategyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public Builder setUpdateStrategy(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder
              builderForValue) {
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = builderForValue.build();
          onChanged();
        } else {
          updateStrategyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public Builder mergeUpdateStrategy(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && updateStrategy_ != null
              && updateStrategy_
                  != io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
                      .getDefaultInstance()) {
            updateStrategy_ =
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.newBuilder(
                        updateStrategy_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            updateStrategy_ = value;
          }
          onChanged();
        } else {
          updateStrategyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public Builder clearUpdateStrategy() {
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = null;
          onChanged();
        } else {
          updateStrategyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder
          getUpdateStrategyBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getUpdateStrategyFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder
          getUpdateStrategyOrBuilder() {
        if (updateStrategyBuilder_ != null) {
          return updateStrategyBuilder_.getMessageOrBuilder();
        } else {
          return updateStrategy_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
                  .getDefaultInstance()
              : updateStrategy_;
        }
      }
      /**
       *
       *
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder>
          getUpdateStrategyFieldBuilder() {
        if (updateStrategyBuilder_ == null) {
          updateStrategyBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder>(
                  getUpdateStrategy(), getParentForChildren(), isClean());
          updateStrategy_ = null;
        }
        return updateStrategyBuilder_;
      }

      private int minReadySeconds_;
      /**
       *
       *
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       *
       *
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public Builder setMinReadySeconds(int value) {
        bitField0_ |= 0x00000008;
        minReadySeconds_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000008);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private long templateGeneration_;
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * A sequence number representing a specific generation of the template.
       * Populated by the system. It can be set only during the creation.
       * +optional
       * </pre>
       *
       * <code>optional int64 templateGeneration = 5;</code>
       */
      public boolean hasTemplateGeneration() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * A sequence number representing a specific generation of the template.
       * Populated by the system. It can be set only during the creation.
       * +optional
       * </pre>
       *
       * <code>optional int64 templateGeneration = 5;</code>
       */
      public long getTemplateGeneration() {
        return templateGeneration_;
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * A sequence number representing a specific generation of the template.
       * Populated by the system. It can be set only during the creation.
       * +optional
       * </pre>
       *
       * <code>optional int64 templateGeneration = 5;</code>
       */
      public Builder setTemplateGeneration(long value) {
        bitField0_ |= 0x00000010;
        templateGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * A sequence number representing a specific generation of the template.
       * Populated by the system. It can be set only during the creation.
       * +optional
       * </pre>
       *
       * <code>optional int64 templateGeneration = 5;</code>
       */
      public Builder clearTemplateGeneration() {
        bitField0_ = (bitField0_ & ~0x00000010);
        templateGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int revisionHistoryLimit_;
      /**
       *
       *
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public boolean hasRevisionHistoryLimit() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       *
       *
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public int getRevisionHistoryLimit() {
        return revisionHistoryLimit_;
      }
      /**
       *
       *
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public Builder setRevisionHistoryLimit(int value) {
        bitField0_ |= 0x00000020;
        revisionHistoryLimit_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public Builder clearRevisionHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000020);
        revisionHistoryLimit_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DaemonSetSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DaemonSetSpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DaemonSetSpec> PARSER =
        new com.google.protobuf.AbstractParser<DaemonSetSpec>() {
          @java.lang.Override
          public DaemonSetSpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DaemonSetSpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DaemonSetSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DaemonSetStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DaemonSetStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    boolean hasCurrentNumberScheduled();
    /**
     *
     *
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    int getCurrentNumberScheduled();

    /**
     *
     *
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    boolean hasNumberMisscheduled();
    /**
     *
     *
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    int getNumberMisscheduled();

    /**
     *
     *
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    boolean hasDesiredNumberScheduled();
    /**
     *
     *
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    int getDesiredNumberScheduled();

    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    boolean hasNumberReady();
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    int getNumberReady();

    /**
     *
     *
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    boolean hasObservedGeneration();
    /**
     *
     *
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    long getObservedGeneration();

    /**
     *
     *
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    boolean hasUpdatedNumberScheduled();
    /**
     *
     *
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    int getUpdatedNumberScheduled();

    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    boolean hasNumberAvailable();
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    int getNumberAvailable();

    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    boolean hasNumberUnavailable();
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    int getNumberUnavailable();

    /**
     *
     *
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    boolean hasCollisionCount();
    /**
     *
     *
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    int getCollisionCount();

    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>
        getConditionsList();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition getConditions(int index);
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    int getConditionsCount();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder>
        getConditionsOrBuilderList();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder getConditionsOrBuilder(
        int index);
  }
  /**
   *
   *
   * <pre>
   * DaemonSetStatus represents the current status of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetStatus}
   */
  public static final class DaemonSetStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DaemonSetStatus)
      DaemonSetStatusOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DaemonSetStatus.newBuilder() to construct.
    private DaemonSetStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DaemonSetStatus() {
      currentNumberScheduled_ = 0;
      numberMisscheduled_ = 0;
      desiredNumberScheduled_ = 0;
      numberReady_ = 0;
      observedGeneration_ = 0L;
      updatedNumberScheduled_ = 0;
      numberAvailable_ = 0;
      numberUnavailable_ = 0;
      collisionCount_ = 0;
      conditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DaemonSetStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                currentNumberScheduled_ = input.readInt32();
                break;
              }
            case 16:
              {
                bitField0_ |= 0x00000002;
                numberMisscheduled_ = input.readInt32();
                break;
              }
            case 24:
              {
                bitField0_ |= 0x00000004;
                desiredNumberScheduled_ = input.readInt32();
                break;
              }
            case 32:
              {
                bitField0_ |= 0x00000008;
                numberReady_ = input.readInt32();
                break;
              }
            case 40:
              {
                bitField0_ |= 0x00000010;
                observedGeneration_ = input.readInt64();
                break;
              }
            case 48:
              {
                bitField0_ |= 0x00000020;
                updatedNumberScheduled_ = input.readInt32();
                break;
              }
            case 56:
              {
                bitField0_ |= 0x00000040;
                numberAvailable_ = input.readInt32();
                break;
              }
            case 64:
              {
                bitField0_ |= 0x00000080;
                numberUnavailable_ = input.readInt32();
                break;
              }
            case 72:
              {
                bitField0_ |= 0x00000100;
                collisionCount_ = input.readInt32();
                break;
              }
            case 82:
              {
                if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                  conditions_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>();
                  mutable_bitField0_ |= 0x00000200;
                }
                conditions_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          conditions_ = java.util.Collections.unmodifiableList(conditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.class,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder.class);
    }

    private int bitField0_;
    public static final int CURRENTNUMBERSCHEDULED_FIELD_NUMBER = 1;
    private int currentNumberScheduled_;
    /**
     *
     *
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    public boolean hasCurrentNumberScheduled() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    public int getCurrentNumberScheduled() {
      return currentNumberScheduled_;
    }

    public static final int NUMBERMISSCHEDULED_FIELD_NUMBER = 2;
    private int numberMisscheduled_;
    /**
     *
     *
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    public boolean hasNumberMisscheduled() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    public int getNumberMisscheduled() {
      return numberMisscheduled_;
    }

    public static final int DESIREDNUMBERSCHEDULED_FIELD_NUMBER = 3;
    private int desiredNumberScheduled_;
    /**
     *
     *
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    public boolean hasDesiredNumberScheduled() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    public int getDesiredNumberScheduled() {
      return desiredNumberScheduled_;
    }

    public static final int NUMBERREADY_FIELD_NUMBER = 4;
    private int numberReady_;
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    public boolean hasNumberReady() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    public int getNumberReady() {
      return numberReady_;
    }

    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 5;
    private long observedGeneration_;
    /**
     *
     *
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int UPDATEDNUMBERSCHEDULED_FIELD_NUMBER = 6;
    private int updatedNumberScheduled_;
    /**
     *
     *
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    public boolean hasUpdatedNumberScheduled() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     *
     *
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    public int getUpdatedNumberScheduled() {
      return updatedNumberScheduled_;
    }

    public static final int NUMBERAVAILABLE_FIELD_NUMBER = 7;
    private int numberAvailable_;
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    public boolean hasNumberAvailable() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    public int getNumberAvailable() {
      return numberAvailable_;
    }

    public static final int NUMBERUNAVAILABLE_FIELD_NUMBER = 8;
    private int numberUnavailable_;
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    public boolean hasNumberUnavailable() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     *
     *
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    public int getNumberUnavailable() {
      return numberUnavailable_;
    }

    public static final int COLLISIONCOUNT_FIELD_NUMBER = 9;
    private int collisionCount_;
    /**
     *
     *
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    public boolean hasCollisionCount() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     *
     *
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    public int getCollisionCount() {
      return collisionCount_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 10;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>
        conditions_;
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>
        getConditionsList() {
      return conditions_;
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder>
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition getConditions(
        int index) {
      return conditions_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a DaemonSet's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder
        getConditionsOrBuilder(int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, currentNumberScheduled_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, numberMisscheduled_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, desiredNumberScheduled_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, numberReady_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(5, observedGeneration_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(6, updatedNumberScheduled_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(7, numberAvailable_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(8, numberUnavailable_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeInt32(9, collisionCount_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(10, conditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, currentNumberScheduled_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, numberMisscheduled_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(3, desiredNumberScheduled_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, numberReady_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(5, observedGeneration_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(6, updatedNumberScheduled_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(7, numberAvailable_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(8, numberUnavailable_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(9, collisionCount_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(10, conditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus other =
          (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus) obj;

      boolean result = true;
      result = result && (hasCurrentNumberScheduled() == other.hasCurrentNumberScheduled());
      if (hasCurrentNumberScheduled()) {
        result = result && (getCurrentNumberScheduled() == other.getCurrentNumberScheduled());
      }
      result = result && (hasNumberMisscheduled() == other.hasNumberMisscheduled());
      if (hasNumberMisscheduled()) {
        result = result && (getNumberMisscheduled() == other.getNumberMisscheduled());
      }
      result = result && (hasDesiredNumberScheduled() == other.hasDesiredNumberScheduled());
      if (hasDesiredNumberScheduled()) {
        result = result && (getDesiredNumberScheduled() == other.getDesiredNumberScheduled());
      }
      result = result && (hasNumberReady() == other.hasNumberReady());
      if (hasNumberReady()) {
        result = result && (getNumberReady() == other.getNumberReady());
      }
      result = result && (hasObservedGeneration() == other.hasObservedGeneration());
      if (hasObservedGeneration()) {
        result = result && (getObservedGeneration() == other.getObservedGeneration());
      }
      result = result && (hasUpdatedNumberScheduled() == other.hasUpdatedNumberScheduled());
      if (hasUpdatedNumberScheduled()) {
        result = result && (getUpdatedNumberScheduled() == other.getUpdatedNumberScheduled());
      }
      result = result && (hasNumberAvailable() == other.hasNumberAvailable());
      if (hasNumberAvailable()) {
        result = result && (getNumberAvailable() == other.getNumberAvailable());
      }
      result = result && (hasNumberUnavailable() == other.hasNumberUnavailable());
      if (hasNumberUnavailable()) {
        result = result && (getNumberUnavailable() == other.getNumberUnavailable());
      }
      result = result && (hasCollisionCount() == other.hasCollisionCount());
      if (hasCollisionCount()) {
        result = result && (getCollisionCount() == other.getCollisionCount());
      }
      result = result && getConditionsList().equals(other.getConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCurrentNumberScheduled()) {
        hash = (37 * hash) + CURRENTNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getCurrentNumberScheduled();
      }
      if (hasNumberMisscheduled()) {
        hash = (37 * hash) + NUMBERMISSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getNumberMisscheduled();
      }
      if (hasDesiredNumberScheduled()) {
        hash = (37 * hash) + DESIREDNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getDesiredNumberScheduled();
      }
      if (hasNumberReady()) {
        hash = (37 * hash) + NUMBERREADY_FIELD_NUMBER;
        hash = (53 * hash) + getNumberReady();
      }
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getObservedGeneration());
      }
      if (hasUpdatedNumberScheduled()) {
        hash = (37 * hash) + UPDATEDNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getUpdatedNumberScheduled();
      }
      if (hasNumberAvailable()) {
        hash = (37 * hash) + NUMBERAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getNumberAvailable();
      }
      if (hasNumberUnavailable()) {
        hash = (37 * hash) + NUMBERUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getNumberUnavailable();
      }
      if (hasCollisionCount()) {
        hash = (37 * hash) + COLLISIONCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCollisionCount();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DaemonSetStatus represents the current status of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetStatus}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DaemonSetStatus)
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.class,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getConditionsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        currentNumberScheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        numberMisscheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        desiredNumberScheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        numberReady_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        observedGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        updatedNumberScheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        numberAvailable_ = 0;
        bitField0_ = (bitField0_ & ~0x00000040);
        numberUnavailable_ = 0;
        bitField0_ = (bitField0_ & ~0x00000080);
        collisionCount_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus build() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus result =
            new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.currentNumberScheduled_ = currentNumberScheduled_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.numberMisscheduled_ = numberMisscheduled_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.desiredNumberScheduled_ = desiredNumberScheduled_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.numberReady_ = numberReady_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.observedGeneration_ = observedGeneration_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.updatedNumberScheduled_ = updatedNumberScheduled_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.numberAvailable_ = numberAvailable_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.numberUnavailable_ = numberUnavailable_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.collisionCount_ = collisionCount_;
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000200) == 0x00000200)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus.getDefaultInstance())
          return this;
        if (other.hasCurrentNumberScheduled()) {
          setCurrentNumberScheduled(other.getCurrentNumberScheduled());
        }
        if (other.hasNumberMisscheduled()) {
          setNumberMisscheduled(other.getNumberMisscheduled());
        }
        if (other.hasDesiredNumberScheduled()) {
          setDesiredNumberScheduled(other.getDesiredNumberScheduled());
        }
        if (other.hasNumberReady()) {
          setNumberReady(other.getNumberReady());
        }
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasUpdatedNumberScheduled()) {
          setUpdatedNumberScheduled(other.getUpdatedNumberScheduled());
        }
        if (other.hasNumberAvailable()) {
          setNumberAvailable(other.getNumberAvailable());
        }
        if (other.hasNumberUnavailable()) {
          setNumberUnavailable(other.getNumberUnavailable());
        }
        if (other.hasCollisionCount()) {
          setCollisionCount(other.getCollisionCount());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000200);
              conditionsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getConditionsFieldBuilder()
                      : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int currentNumberScheduled_;
      /**
       *
       *
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public boolean hasCurrentNumberScheduled() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public int getCurrentNumberScheduled() {
        return currentNumberScheduled_;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public Builder setCurrentNumberScheduled(int value) {
        bitField0_ |= 0x00000001;
        currentNumberScheduled_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public Builder clearCurrentNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000001);
        currentNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberMisscheduled_;
      /**
       *
       *
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public boolean hasNumberMisscheduled() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public int getNumberMisscheduled() {
        return numberMisscheduled_;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public Builder setNumberMisscheduled(int value) {
        bitField0_ |= 0x00000002;
        numberMisscheduled_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public Builder clearNumberMisscheduled() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numberMisscheduled_ = 0;
        onChanged();
        return this;
      }

      private int desiredNumberScheduled_;
      /**
       *
       *
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public boolean hasDesiredNumberScheduled() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public int getDesiredNumberScheduled() {
        return desiredNumberScheduled_;
      }
      /**
       *
       *
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public Builder setDesiredNumberScheduled(int value) {
        bitField0_ |= 0x00000004;
        desiredNumberScheduled_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public Builder clearDesiredNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000004);
        desiredNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberReady_;
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public boolean hasNumberReady() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public int getNumberReady() {
        return numberReady_;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public Builder setNumberReady(int value) {
        bitField0_ |= 0x00000008;
        numberReady_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public Builder clearNumberReady() {
        bitField0_ = (bitField0_ & ~0x00000008);
        numberReady_ = 0;
        onChanged();
        return this;
      }

      private long observedGeneration_;
      /**
       *
       *
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       *
       *
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public Builder setObservedGeneration(long value) {
        bitField0_ |= 0x00000010;
        observedGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000010);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int updatedNumberScheduled_;
      /**
       *
       *
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public boolean hasUpdatedNumberScheduled() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       *
       *
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public int getUpdatedNumberScheduled() {
        return updatedNumberScheduled_;
      }
      /**
       *
       *
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public Builder setUpdatedNumberScheduled(int value) {
        bitField0_ |= 0x00000020;
        updatedNumberScheduled_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public Builder clearUpdatedNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000020);
        updatedNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberAvailable_;
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public boolean hasNumberAvailable() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public int getNumberAvailable() {
        return numberAvailable_;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public Builder setNumberAvailable(int value) {
        bitField0_ |= 0x00000040;
        numberAvailable_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public Builder clearNumberAvailable() {
        bitField0_ = (bitField0_ & ~0x00000040);
        numberAvailable_ = 0;
        onChanged();
        return this;
      }

      private int numberUnavailable_;
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public boolean hasNumberUnavailable() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public int getNumberUnavailable() {
        return numberUnavailable_;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public Builder setNumberUnavailable(int value) {
        bitField0_ |= 0x00000080;
        numberUnavailable_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public Builder clearNumberUnavailable() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numberUnavailable_ = 0;
        onChanged();
        return this;
      }

      private int collisionCount_;
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public boolean hasCollisionCount() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public int getCollisionCount() {
        return collisionCount_;
      }
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public Builder setCollisionCount(int value) {
        bitField0_ |= 0x00000100;
        collisionCount_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public Builder clearCollisionCount() {
        bitField0_ = (bitField0_ & ~0x00000100);
        collisionCount_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>
          conditions_ = java.util.Collections.emptyList();

      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          conditions_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>(conditions_);
          bitField0_ |= 0x00000200;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder>
          conditionsBuilder_;

      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>
          getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition getConditions(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder setConditions(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addConditions(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition>
              values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder
          getConditionsBuilder(int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder
          getConditionsOrBuilder(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder>
          getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder
          addConditionsBuilder() {
        return getConditionsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder
          addConditionsBuilder(int index) {
        return getConditionsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a DaemonSet's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DaemonSetCondition conditions = 10;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder>
          getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder>
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetCondition.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DaemonSetConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000200) == 0x00000200),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DaemonSetStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DaemonSetStatus)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DaemonSetStatus> PARSER =
        new com.google.protobuf.AbstractParser<DaemonSetStatus>() {
          @java.lang.Override
          public DaemonSetStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DaemonSetStatus(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DaemonSetStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetStatus
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DaemonSetUpdateStrategyOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
     * Default is OnDelete.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     *
     *
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
     * Default is OnDelete.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     *
     *
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
     * Default is OnDelete.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString getTypeBytes();

    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
     * </code>
     */
    boolean hasRollingUpdate();
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet getRollingUpdate();
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder
        getRollingUpdateOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DaemonSetUpdateStrategy indicates the strategy that the DaemonSet
   * controller will use to perform updates. It includes any additional parameters
   * necessary to perform the update for the indicated strategy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy}
   */
  public static final class DaemonSetUpdateStrategy extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy)
      DaemonSetUpdateStrategyOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DaemonSetUpdateStrategy.newBuilder() to construct.
    private DaemonSetUpdateStrategy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DaemonSetUpdateStrategy() {
      type_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DaemonSetUpdateStrategy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                type_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = rollingUpdate_.toBuilder();
                }
                rollingUpdate_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(rollingUpdate_);
                  rollingUpdate_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.class,
              io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     *
     *
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
     * Default is OnDelete.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
     * Default is OnDelete.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
     * Default is OnDelete.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROLLINGUPDATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet rollingUpdate_;
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
     * </code>
     */
    public boolean hasRollingUpdate() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet getRollingUpdate() {
      return rollingUpdate_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.getDefaultInstance()
          : rollingUpdate_;
    }
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder
        getRollingUpdateOrBuilder() {
      return rollingUpdate_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.getDefaultInstance()
          : rollingUpdate_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getRollingUpdate());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getRollingUpdate());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy other =
          (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType().equals(other.getType());
      }
      result = result && (hasRollingUpdate() == other.hasRollingUpdate());
      if (hasRollingUpdate()) {
        result = result && getRollingUpdate().equals(other.getRollingUpdate());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasRollingUpdate()) {
        hash = (37 * hash) + ROLLINGUPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getRollingUpdate().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DaemonSetUpdateStrategy indicates the strategy that the DaemonSet
     * controller will use to perform updates. It includes any additional parameters
     * necessary to perform the update for the indicated strategy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy)
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.class,
                io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRollingUpdateFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = null;
        } else {
          rollingUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy build() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy result =
            new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (rollingUpdateBuilder_ == null) {
          result.rollingUpdate_ = rollingUpdate_;
        } else {
          result.rollingUpdate_ = rollingUpdateBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
                .getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasRollingUpdate()) {
          mergeRollingUpdate(other.getRollingUpdate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       *
       *
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
       * Default is OnDelete.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
       * Default is OnDelete.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
       * Default is OnDelete.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
       * Default is OnDelete.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
       * Default is OnDelete.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
       * Default is OnDelete.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet rollingUpdate_ =
          null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder>
          rollingUpdateBuilder_;
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public boolean hasRollingUpdate() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
          getRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          return rollingUpdate_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
                  .getDefaultInstance()
              : rollingUpdate_;
        } else {
          return rollingUpdateBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet value) {
        if (rollingUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollingUpdate_ = value;
          onChanged();
        } else {
          rollingUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder
              builderForValue) {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = builderForValue.build();
          onChanged();
        } else {
          rollingUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public Builder mergeRollingUpdate(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet value) {
        if (rollingUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && rollingUpdate_ != null
              && rollingUpdate_
                  != io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
                      .getDefaultInstance()) {
            rollingUpdate_ =
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.newBuilder(
                        rollingUpdate_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            rollingUpdate_ = value;
          }
          onChanged();
        } else {
          rollingUpdateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public Builder clearRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = null;
          onChanged();
        } else {
          rollingUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder
          getRollingUpdateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRollingUpdateFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder
          getRollingUpdateOrBuilder() {
        if (rollingUpdateBuilder_ != null) {
          return rollingUpdateBuilder_.getMessageOrBuilder();
        } else {
          return rollingUpdate_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
                  .getDefaultInstance()
              : rollingUpdate_;
        }
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder>
          getRollingUpdateFieldBuilder() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet,
                  io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder>(
                  getRollingUpdate(), getParentForChildren(), isClean());
          rollingUpdate_ = null;
        }
        return rollingUpdateBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DaemonSetUpdateStrategy)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DaemonSetUpdateStrategy> PARSER =
        new com.google.protobuf.AbstractParser<DaemonSetUpdateStrategy>() {
          @java.lang.Override
          public DaemonSetUpdateStrategy parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DaemonSetUpdateStrategy(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DaemonSetUpdateStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetUpdateStrategy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DaemonSetUpdateStrategy
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.Deployment)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec getSpec();
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder getSpecOrBuilder();

    /**
     *
     *
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus getStatus();
    /**
     *
     *
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder getStatusOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for
   * more information.
   * Deployment enables declarative updates for Pods and ReplicaSets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.Deployment}
   */
  public static final class Deployment extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.Deployment)
      DeploymentOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use Deployment.newBuilder() to construct.
    private Deployment(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private Deployment() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private Deployment(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = status_.toBuilder();
                }
                status_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(status_);
                  status_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_Deployment_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_Deployment_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.Deployment.class,
              io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec spec_;
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.getDefaultInstance()
          : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus status_;
    /**
     *
     *
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus getStatus() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.getDefaultInstance()
          : status_;
    }
    /**
     *
     *
     * <pre>
     * Most recently observed status of the Deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder
        getStatusOrBuilder() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.getDefaultInstance()
          : status_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.Deployment)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.Deployment other =
          (io.kubernetes.client.proto.V1beta1Extensions.Deployment) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.Deployment prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for
     * more information.
     * Deployment enables declarative updates for Pods and ReplicaSets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.Deployment}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.Deployment)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Deployment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Deployment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.Deployment.class,
                io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.Deployment.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Deployment_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.Deployment.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment build() {
        io.kubernetes.client.proto.V1beta1Extensions.Deployment result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.Deployment result =
            new io.kubernetes.client.proto.V1beta1Extensions.Deployment(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.Deployment) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.Deployment) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.Deployment other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.Deployment.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.Deployment parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.Deployment) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec
                      .getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder
          getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder>
          statusBuilder_;
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.getDefaultInstance()
              : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public Builder mergeStatus(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && status_ != null
              && status_
                  != io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus
                      .getDefaultInstance()) {
            status_ =
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.newBuilder(status_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder
          getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder
          getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.getDefaultInstance()
              : status_;
        }
      }
      /**
       *
       *
       * <pre>
       * Most recently observed status of the Deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder>
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder>(
                  getStatus(), getParentForChildren(), isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.Deployment)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.Deployment)
    private static final io.kubernetes.client.proto.V1beta1Extensions.Deployment DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.Deployment();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Deployment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<Deployment> PARSER =
        new com.google.protobuf.AbstractParser<Deployment>() {
          @java.lang.Override
          public Deployment parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new Deployment(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<Deployment> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Deployment> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.Deployment getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentConditionOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DeploymentCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     *
     *
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     *
     *
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString getTypeBytes();

    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    java.lang.String getStatus();
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    com.google.protobuf.ByteString getStatusBytes();

    /**
     *
     *
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    boolean hasLastUpdateTime();
    /**
     *
     *
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastUpdateTime();
    /**
     *
     *
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastUpdateTimeOrBuilder();

    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    boolean hasLastTransitionTime();
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    boolean hasReason();
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    java.lang.String getReason();
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    com.google.protobuf.ByteString getReasonBytes();

    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    boolean hasMessage();
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    java.lang.String getMessage();
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    com.google.protobuf.ByteString getMessageBytes();
  }
  /**
   *
   *
   * <pre>
   * DeploymentCondition describes the state of a deployment at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentCondition}
   */
  public static final class DeploymentCondition extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DeploymentCondition)
      DeploymentConditionOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DeploymentCondition.newBuilder() to construct.
    private DeploymentCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DeploymentCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DeploymentCondition(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                type_ = bs;
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000002;
                status_ = bs;
                break;
              }
            case 34:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000010;
                reason_ = bs;
                break;
              }
            case 42:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000020;
                message_ = bs;
                break;
              }
            case 50:
              {
                io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = lastUpdateTime_.toBuilder();
                }
                lastUpdateTime_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(lastUpdateTime_);
                  lastUpdateTime_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 58:
              {
                io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
                if (((bitField0_ & 0x00000008) == 0x00000008)) {
                  subBuilder = lastTransitionTime_.toBuilder();
                }
                lastTransitionTime_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(lastTransitionTime_);
                  lastTransitionTime_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000008;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.class,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     *
     *
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Type of deployment condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private volatile java.lang.Object status_;
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public com.google.protobuf.ByteString getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTUPDATETIME_FIELD_NUMBER = 6;
    private io.kubernetes.client.proto.Meta.Time lastUpdateTime_;
    /**
     *
     *
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    public boolean hasLastUpdateTime() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastUpdateTime() {
      return lastUpdateTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastUpdateTime_;
    }
    /**
     *
     *
     * <pre>
     * The last time this condition was updated.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastUpdateTimeOrBuilder() {
      return lastUpdateTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastUpdateTime_;
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 7;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastTransitionTime_;
    }
    /**
     *
     *
     * <pre>
     * Last time the condition transitioned from one status to another.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    private volatile java.lang.Object reason_;
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public boolean hasReason() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public com.google.protobuf.ByteString getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    private volatile java.lang.Object message_;
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public com.google.protobuf.ByteString getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, message_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(6, getLastUpdateTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(7, getLastTransitionTime());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, message_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, getLastUpdateTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(7, getLastTransitionTime());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition other =
          (io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType().equals(other.getType());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && (hasLastUpdateTime() == other.hasLastUpdateTime());
      if (hasLastUpdateTime()) {
        result = result && getLastUpdateTime().equals(other.getLastUpdateTime());
      }
      result = result && (hasLastTransitionTime() == other.hasLastTransitionTime());
      if (hasLastTransitionTime()) {
        result = result && getLastTransitionTime().equals(other.getLastTransitionTime());
      }
      result = result && (hasReason() == other.hasReason());
      if (hasReason()) {
        result = result && getReason().equals(other.getReason());
      }
      result = result && (hasMessage() == other.hasMessage());
      if (hasMessage()) {
        result = result && getMessage().equals(other.getMessage());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastUpdateTime()) {
        hash = (37 * hash) + LASTUPDATETIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastUpdateTime().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DeploymentCondition describes the state of a deployment at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentCondition}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DeploymentCondition)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.class,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getLastUpdateTimeFieldBuilder();
          getLastTransitionTimeFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        status_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (lastUpdateTimeBuilder_ == null) {
          lastUpdateTime_ = null;
        } else {
          lastUpdateTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        reason_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition build() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition result =
            new io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.status_ = status_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (lastUpdateTimeBuilder_ == null) {
          result.lastUpdateTime_ = lastUpdateTime_;
        } else {
          result.lastUpdateTime_ = lastUpdateTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (lastTransitionTimeBuilder_ == null) {
          result.lastTransitionTime_ = lastTransitionTime_;
        } else {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.reason_ = reason_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.message_ = message_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
                .getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasStatus()) {
          bitField0_ |= 0x00000002;
          status_ = other.status_;
          onChanged();
        }
        if (other.hasLastUpdateTime()) {
          mergeLastUpdateTime(other.getLastUpdateTime());
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          bitField0_ |= 0x00000010;
          reason_ = other.reason_;
          onChanged();
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000020;
          message_ = other.message_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       *
       *
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of deployment condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public com.google.protobuf.ByteString getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatus(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = getDefaultInstance().getStatus();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatusBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastUpdateTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          lastUpdateTimeBuilder_;
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public boolean hasLastUpdateTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastUpdateTime() {
        if (lastUpdateTimeBuilder_ == null) {
          return lastUpdateTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastUpdateTime_;
        } else {
          return lastUpdateTimeBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder setLastUpdateTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastUpdateTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastUpdateTime_ = value;
          onChanged();
        } else {
          lastUpdateTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder setLastUpdateTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastUpdateTimeBuilder_ == null) {
          lastUpdateTime_ = builderForValue.build();
          onChanged();
        } else {
          lastUpdateTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder mergeLastUpdateTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastUpdateTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && lastUpdateTime_ != null
              && lastUpdateTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastUpdateTime_ =
                io.kubernetes.client.proto.Meta.Time.newBuilder(lastUpdateTime_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            lastUpdateTime_ = value;
          }
          onChanged();
        } else {
          lastUpdateTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public Builder clearLastUpdateTime() {
        if (lastUpdateTimeBuilder_ == null) {
          lastUpdateTime_ = null;
          onChanged();
        } else {
          lastUpdateTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastUpdateTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastUpdateTimeFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastUpdateTimeOrBuilder() {
        if (lastUpdateTimeBuilder_ != null) {
          return lastUpdateTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastUpdateTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastUpdateTime_;
        }
      }
      /**
       *
       *
       * <pre>
       * The last time this condition was updated.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          getLastUpdateTimeFieldBuilder() {
        if (lastUpdateTimeBuilder_ == null) {
          lastUpdateTimeBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.Time,
                  io.kubernetes.client.proto.Meta.Time.Builder,
                  io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastUpdateTime(), getParentForChildren(), isClean());
          lastUpdateTime_ = null;
        }
        return lastUpdateTimeBuilder_;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          lastTransitionTimeBuilder_;
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)
              && lastTransitionTime_ != null
              && lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastTransitionTime_ =
                io.kubernetes.client.proto.Meta.Time.newBuilder(lastTransitionTime_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            lastTransitionTime_ = value;
          }
          onChanged();
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public Builder clearLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastTransitionTime_;
        }
      }
      /**
       *
       *
       * <pre>
       * Last time the condition transitioned from one status to another.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.Time,
                  io.kubernetes.client.proto.Meta.Time.Builder,
                  io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(), getParentForChildren(), isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public com.google.protobuf.ByteString getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder setReason(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        reason_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000010);
        reason_ = getDefaultInstance().getReason();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder setReasonBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        reason_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public com.google.protobuf.ByteString getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder setMessage(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000020);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder setMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        message_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DeploymentCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DeploymentCondition)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DeploymentCondition> PARSER =
        new com.google.protobuf.AbstractParser<DeploymentCondition>() {
          @java.lang.Override
          public DeploymentCondition parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DeploymentCondition(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DeploymentCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentListOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DeploymentList)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Deployment> getItemsList();
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.Deployment getItems(int index);
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    int getItemsCount();
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder>
        getItemsOrBuilderList();
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder getItemsOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * DeploymentList is a list of Deployments.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentList}
   */
  public static final class DeploymentList extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DeploymentList)
      DeploymentListOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DeploymentList.newBuilder() to construct.
    private DeploymentList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DeploymentList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DeploymentList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  items_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.Deployment>();
                  mutable_bitField0_ |= 0x00000002;
                }
                items_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.Deployment.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.class,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Deployment> items_;
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Deployment> getItemsList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder>
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.Deployment getItems(int index) {
      return items_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Deployments.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DeploymentList other =
          (io.kubernetes.client.proto.V1beta1Extensions.DeploymentList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && getItemsList().equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DeploymentList is a list of Deployments.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentList}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DeploymentList)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.class,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentList
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentList build() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentList buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentList result =
            new io.kubernetes.client.proto.V1beta1Extensions.DeploymentList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DeploymentList) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.DeploymentList other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DeploymentList.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getItemsFieldBuilder()
                      : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentList)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ListMeta,
                  io.kubernetes.client.proto.Meta.ListMeta.Builder,
                  io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Deployment> items_ =
          java.util.Collections.emptyList();

      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.Deployment>(
                  items_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.Deployment,
              io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder>
          itemsBuilder_;

      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Deployment>
          getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.Deployment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder setItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Extensions.Deployment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.Deployment value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder addItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.Deployment>
              values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder>
          getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder addItemsBuilder() {
        return getItemsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.Deployment.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.Deployment.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Deployments.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Deployment items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder>
          getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.Deployment,
              io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder>
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.Deployment,
                  io.kubernetes.client.proto.V1beta1Extensions.Deployment.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DeploymentList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DeploymentList)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DeploymentList
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DeploymentList();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DeploymentList> PARSER =
        new com.google.protobuf.AbstractParser<DeploymentList>() {
          @java.lang.Override
          public DeploymentList parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DeploymentList(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DeploymentList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentRollbackOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DeploymentRollback)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Required: This must match the Name of a deployment.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     *
     *
     * <pre>
     * Required: This must match the Name of a deployment.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     *
     *
     * <pre>
     * Required: This must match the Name of a deployment.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString getNameBytes();

    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    int getUpdatedAnnotationsCount();
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    boolean containsUpdatedAnnotations(java.lang.String key);
    /** Use {@link #getUpdatedAnnotationsMap()} instead. */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String> getUpdatedAnnotations();
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String> getUpdatedAnnotationsMap();
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    java.lang.String getUpdatedAnnotationsOrDefault(
        java.lang.String key, java.lang.String defaultValue);
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    java.lang.String getUpdatedAnnotationsOrThrow(java.lang.String key);

    /**
     *
     *
     * <pre>
     * The config of this deployment rollback.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
     */
    boolean hasRollbackTo();
    /**
     *
     *
     * <pre>
     * The config of this deployment rollback.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getRollbackTo();
    /**
     *
     *
     * <pre>
     * The config of this deployment rollback.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder getRollbackToOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED.
   * DeploymentRollback stores the information required to rollback a deployment.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentRollback}
   */
  public static final class DeploymentRollback extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DeploymentRollback)
      DeploymentRollbackOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DeploymentRollback.newBuilder() to construct.
    private DeploymentRollback(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DeploymentRollback() {
      name_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DeploymentRollback(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                name_ = bs;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  updatedAnnotations_ =
                      com.google.protobuf.MapField.newMapField(
                          UpdatedAnnotationsDefaultEntryHolder.defaultEntry);
                  mutable_bitField0_ |= 0x00000002;
                }
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                    updatedAnnotations__ =
                        input.readMessage(
                            UpdatedAnnotationsDefaultEntryHolder.defaultEntry.getParserForType(),
                            extensionRegistry);
                updatedAnnotations_
                    .getMutableMap()
                    .put(updatedAnnotations__.getKey(), updatedAnnotations__.getValue());
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = rollbackTo_.toBuilder();
                }
                rollbackTo_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(rollbackTo_);
                  rollbackTo_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(int number) {
      switch (number) {
        case 2:
          return internalGetUpdatedAnnotations();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.class,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     *
     *
     * <pre>
     * Required: This must match the Name of a deployment.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Required: This must match the Name of a deployment.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Required: This must match the Name of a deployment.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UPDATEDANNOTATIONS_FIELD_NUMBER = 2;

    private static final class UpdatedAnnotationsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<java.lang.String, java.lang.String> defaultEntry =
          com.google.protobuf.MapEntry.<java.lang.String, java.lang.String>newDefaultInstance(
              io.kubernetes.client.proto.V1beta1Extensions
                  .internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_UpdatedAnnotationsEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.STRING,
              "");
    }

    private com.google.protobuf.MapField<java.lang.String, java.lang.String> updatedAnnotations_;

    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetUpdatedAnnotations() {
      if (updatedAnnotations_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            UpdatedAnnotationsDefaultEntryHolder.defaultEntry);
      }
      return updatedAnnotations_;
    }

    public int getUpdatedAnnotationsCount() {
      return internalGetUpdatedAnnotations().getMap().size();
    }
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    public boolean containsUpdatedAnnotations(java.lang.String key) {
      if (key == null) {
        throw new java.lang.NullPointerException();
      }
      return internalGetUpdatedAnnotations().getMap().containsKey(key);
    }
    /** Use {@link #getUpdatedAnnotationsMap()} instead. */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getUpdatedAnnotations() {
      return getUpdatedAnnotationsMap();
    }
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    public java.util.Map<java.lang.String, java.lang.String> getUpdatedAnnotationsMap() {
      return internalGetUpdatedAnnotations().getMap();
    }
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    public java.lang.String getUpdatedAnnotationsOrDefault(
        java.lang.String key, java.lang.String defaultValue) {
      if (key == null) {
        throw new java.lang.NullPointerException();
      }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetUpdatedAnnotations().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     *
     *
     * <pre>
     * The annotations to be updated to a deployment
     * +optional
     * </pre>
     *
     * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
     */
    public java.lang.String getUpdatedAnnotationsOrThrow(java.lang.String key) {
      if (key == null) {
        throw new java.lang.NullPointerException();
      }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetUpdatedAnnotations().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ROLLBACKTO_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig rollbackTo_;
    /**
     *
     *
     * <pre>
     * The config of this deployment rollback.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
     */
    public boolean hasRollbackTo() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The config of this deployment rollback.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getRollbackTo() {
      return rollbackTo_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
          : rollbackTo_;
    }
    /**
     *
     *
     * <pre>
     * The config of this deployment rollback.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder
        getRollbackToOrBuilder() {
      return rollbackTo_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
          : rollbackTo_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output,
          internalGetUpdatedAnnotations(),
          UpdatedAnnotationsDefaultEntryHolder.defaultEntry,
          2);
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(3, getRollbackTo());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry :
          internalGetUpdatedAnnotations().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String> updatedAnnotations__ =
            UpdatedAnnotationsDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, updatedAnnotations__);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getRollbackTo());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback other =
          (io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName().equals(other.getName());
      }
      result =
          result && internalGetUpdatedAnnotations().equals(other.internalGetUpdatedAnnotations());
      result = result && (hasRollbackTo() == other.hasRollbackTo());
      if (hasRollbackTo()) {
        result = result && getRollbackTo().equals(other.getRollbackTo());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (!internalGetUpdatedAnnotations().getMap().isEmpty()) {
        hash = (37 * hash) + UPDATEDANNOTATIONS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetUpdatedAnnotations().hashCode();
      }
      if (hasRollbackTo()) {
        hash = (37 * hash) + ROLLBACKTO_FIELD_NUMBER;
        hash = (53 * hash) + getRollbackTo().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * DeploymentRollback stores the information required to rollback a deployment.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentRollback}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DeploymentRollback)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollbackOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(int number) {
        switch (number) {
          case 2:
            return internalGetUpdatedAnnotations();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(int number) {
        switch (number) {
          case 2:
            return internalGetMutableUpdatedAnnotations();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.class,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRollbackToFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableUpdatedAnnotations().clear();
        if (rollbackToBuilder_ == null) {
          rollbackTo_ = null;
        } else {
          rollbackToBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback build() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback result =
            new io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        result.updatedAnnotations_ = internalGetUpdatedAnnotations();
        result.updatedAnnotations_.makeImmutable();
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000002;
        }
        if (rollbackToBuilder_ == null) {
          result.rollbackTo_ = rollbackTo_;
        } else {
          result.rollbackTo_ = rollbackToBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback.getDefaultInstance())
          return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        internalGetMutableUpdatedAnnotations().mergeFrom(other.internalGetUpdatedAnnotations());
        if (other.hasRollbackTo()) {
          mergeRollbackTo(other.getRollbackTo());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       *
       *
       * <pre>
       * Required: This must match the Name of a deployment.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Required: This must match the Name of a deployment.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Required: This must match the Name of a deployment.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Required: This must match the Name of a deployment.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Required: This must match the Name of a deployment.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Required: This must match the Name of a deployment.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<java.lang.String, java.lang.String> updatedAnnotations_;

      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetUpdatedAnnotations() {
        if (updatedAnnotations_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              UpdatedAnnotationsDefaultEntryHolder.defaultEntry);
        }
        return updatedAnnotations_;
      }

      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableUpdatedAnnotations() {
        onChanged();
        ;
        if (updatedAnnotations_ == null) {
          updatedAnnotations_ =
              com.google.protobuf.MapField.newMapField(
                  UpdatedAnnotationsDefaultEntryHolder.defaultEntry);
        }
        if (!updatedAnnotations_.isMutable()) {
          updatedAnnotations_ = updatedAnnotations_.copy();
        }
        return updatedAnnotations_;
      }

      public int getUpdatedAnnotationsCount() {
        return internalGetUpdatedAnnotations().getMap().size();
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public boolean containsUpdatedAnnotations(java.lang.String key) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        return internalGetUpdatedAnnotations().getMap().containsKey(key);
      }
      /** Use {@link #getUpdatedAnnotationsMap()} instead. */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getUpdatedAnnotations() {
        return getUpdatedAnnotationsMap();
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public java.util.Map<java.lang.String, java.lang.String> getUpdatedAnnotationsMap() {
        return internalGetUpdatedAnnotations().getMap();
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public java.lang.String getUpdatedAnnotationsOrDefault(
          java.lang.String key, java.lang.String defaultValue) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetUpdatedAnnotations().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public java.lang.String getUpdatedAnnotationsOrThrow(java.lang.String key) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetUpdatedAnnotations().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearUpdatedAnnotations() {
        internalGetMutableUpdatedAnnotations().getMutableMap().clear();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public Builder removeUpdatedAnnotations(java.lang.String key) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        internalGetMutableUpdatedAnnotations().getMutableMap().remove(key);
        return this;
      }
      /** Use alternate mutation accessors instead. */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getMutableUpdatedAnnotations() {
        return internalGetMutableUpdatedAnnotations().getMutableMap();
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public Builder putUpdatedAnnotations(java.lang.String key, java.lang.String value) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        if (value == null) {
          throw new java.lang.NullPointerException();
        }
        internalGetMutableUpdatedAnnotations().getMutableMap().put(key, value);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The annotations to be updated to a deployment
       * +optional
       * </pre>
       *
       * <code>map&lt;string, string&gt; updatedAnnotations = 2;</code>
       */
      public Builder putAllUpdatedAnnotations(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableUpdatedAnnotations().getMutableMap().putAll(values);
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig rollbackTo_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder>
          rollbackToBuilder_;
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public boolean hasRollbackTo() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getRollbackTo() {
        if (rollbackToBuilder_ == null) {
          return rollbackTo_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
              : rollbackTo_;
        } else {
          return rollbackToBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public Builder setRollbackTo(
          io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig value) {
        if (rollbackToBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollbackTo_ = value;
          onChanged();
        } else {
          rollbackToBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public Builder setRollbackTo(
          io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder builderForValue) {
        if (rollbackToBuilder_ == null) {
          rollbackTo_ = builderForValue.build();
          onChanged();
        } else {
          rollbackToBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public Builder mergeRollbackTo(
          io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig value) {
        if (rollbackToBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && rollbackTo_ != null
              && rollbackTo_
                  != io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig
                      .getDefaultInstance()) {
            rollbackTo_ =
                io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.newBuilder(rollbackTo_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            rollbackTo_ = value;
          }
          onChanged();
        } else {
          rollbackToBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public Builder clearRollbackTo() {
        if (rollbackToBuilder_ == null) {
          rollbackTo_ = null;
          onChanged();
        } else {
          rollbackToBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder
          getRollbackToBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getRollbackToFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder
          getRollbackToOrBuilder() {
        if (rollbackToBuilder_ != null) {
          return rollbackToBuilder_.getMessageOrBuilder();
        } else {
          return rollbackTo_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
              : rollbackTo_;
        }
      }
      /**
       *
       *
       * <pre>
       * The config of this deployment rollback.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder>
          getRollbackToFieldBuilder() {
        if (rollbackToBuilder_ == null) {
          rollbackToBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig,
                  io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder>(
                  getRollbackTo(), getParentForChildren(), isClean());
          rollbackTo_ = null;
        }
        return rollbackToBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DeploymentRollback)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DeploymentRollback)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DeploymentRollback> PARSER =
        new com.google.protobuf.AbstractParser<DeploymentRollback>() {
          @java.lang.Override
          public DeploymentRollback parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DeploymentRollback(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DeploymentRollback> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentRollback> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentRollback
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentSpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DeploymentSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    boolean hasReplicas();
    /**
     *
     *
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    int getReplicas();

    /**
     *
     *
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    boolean hasSelector();
    /**
     *
     *
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     *
     *
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     *
     *
     * <pre>
     * Template describes the pods that will be created.
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    boolean hasTemplate();
    /**
     *
     *
     * <pre>
     * Template describes the pods that will be created.
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     *
     *
     * <pre>
     * Template describes the pods that will be created.
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     *
     *
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
     */
    boolean hasStrategy();
    /**
     *
     *
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy getStrategy();
    /**
     *
     *
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder getStrategyOrBuilder();

    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     */
    boolean hasMinReadySeconds();
    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     */
    int getMinReadySeconds();

    /**
     *
     *
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * This is set to the max value of int32 (i.e. 2147483647) by default, which
     * means "retaining all old ReplicaSets".
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    boolean hasRevisionHistoryLimit();
    /**
     *
     *
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * This is set to the max value of int32 (i.e. 2147483647) by default, which
     * means "retaining all old ReplicaSets".
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    int getRevisionHistoryLimit();

    /**
     *
     *
     * <pre>
     * Indicates that the deployment is paused and will not be processed by the
     * deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     */
    boolean hasPaused();
    /**
     *
     *
     * <pre>
     * Indicates that the deployment is paused and will not be processed by the
     * deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     */
    boolean getPaused();

    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * The config this deployment is rolling back to. Will be cleared after rollback is done.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
     */
    boolean hasRollbackTo();
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * The config this deployment is rolling back to. Will be cleared after rollback is done.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getRollbackTo();
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * The config this deployment is rolling back to. Will be cleared after rollback is done.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder getRollbackToOrBuilder();

    /**
     *
     *
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. This is set to
     * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
     * +optional
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     */
    boolean hasProgressDeadlineSeconds();
    /**
     *
     *
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. This is set to
     * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
     * +optional
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     */
    int getProgressDeadlineSeconds();
  }
  /**
   *
   *
   * <pre>
   * DeploymentSpec is the specification of the desired behavior of the Deployment.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentSpec}
   */
  public static final class DeploymentSpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DeploymentSpec)
      DeploymentSpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DeploymentSpec.newBuilder() to construct.
    private DeploymentSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DeploymentSpec() {
      replicas_ = 0;
      minReadySeconds_ = 0;
      revisionHistoryLimit_ = 0;
      paused_ = false;
      progressDeadlineSeconds_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DeploymentSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                replicas_ = input.readInt32();
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = selector_.toBuilder();
                }
                selector_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(selector_);
                  selector_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1.PodTemplateSpec.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = template_.toBuilder();
                }
                template_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.PodTemplateSpec.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(template_);
                  template_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 34:
              {
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000008) == 0x00000008)) {
                  subBuilder = strategy_.toBuilder();
                }
                strategy_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(strategy_);
                  strategy_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000008;
                break;
              }
            case 40:
              {
                bitField0_ |= 0x00000010;
                minReadySeconds_ = input.readInt32();
                break;
              }
            case 48:
              {
                bitField0_ |= 0x00000020;
                revisionHistoryLimit_ = input.readInt32();
                break;
              }
            case 56:
              {
                bitField0_ |= 0x00000040;
                paused_ = input.readBool();
                break;
              }
            case 66:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000080) == 0x00000080)) {
                  subBuilder = rollbackTo_.toBuilder();
                }
                rollbackTo_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(rollbackTo_);
                  rollbackTo_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000080;
                break;
              }
            case 72:
              {
                bitField0_ |= 0x00000100;
                progressDeadlineSeconds_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_;
    /**
     *
     *
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Number of desired pods. This is a pointer to distinguish between explicit
     * zero and not specified. Defaults to 1.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public int getReplicas() {
      return replicas_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     *
     *
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : selector_;
    }
    /**
     *
     *
     * <pre>
     * Label selector for pods. Existing ReplicaSets whose pods are
     * selected by this will be the ones affected by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     *
     *
     * <pre>
     * Template describes the pods that will be created.
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Template describes the pods that will be created.
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null
          ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
          : template_;
    }
    /**
     *
     *
     * <pre>
     * Template describes the pods that will be created.
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null
          ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
          : template_;
    }

    public static final int STRATEGY_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy strategy_;
    /**
     *
     *
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
     */
    public boolean hasStrategy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy getStrategy() {
      return strategy_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.getDefaultInstance()
          : strategy_;
    }
    /**
     *
     *
     * <pre>
     * The deployment strategy to use to replace existing pods with new ones.
     * +optional
     * +patchStrategy=retainKeys
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder
        getStrategyOrBuilder() {
      return strategy_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.getDefaultInstance()
          : strategy_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 5;
    private int minReadySeconds_;
    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     */
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 5;</code>
     */
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int REVISIONHISTORYLIMIT_FIELD_NUMBER = 6;
    private int revisionHistoryLimit_;
    /**
     *
     *
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * This is set to the max value of int32 (i.e. 2147483647) by default, which
     * means "retaining all old ReplicaSets".
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    public boolean hasRevisionHistoryLimit() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     *
     *
     * <pre>
     * The number of old ReplicaSets to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * This is set to the max value of int32 (i.e. 2147483647) by default, which
     * means "retaining all old ReplicaSets".
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    public int getRevisionHistoryLimit() {
      return revisionHistoryLimit_;
    }

    public static final int PAUSED_FIELD_NUMBER = 7;
    private boolean paused_;
    /**
     *
     *
     * <pre>
     * Indicates that the deployment is paused and will not be processed by the
     * deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     */
    public boolean hasPaused() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     *
     *
     * <pre>
     * Indicates that the deployment is paused and will not be processed by the
     * deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional bool paused = 7;</code>
     */
    public boolean getPaused() {
      return paused_;
    }

    public static final int ROLLBACKTO_FIELD_NUMBER = 8;
    private io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig rollbackTo_;
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * The config this deployment is rolling back to. Will be cleared after rollback is done.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
     */
    public boolean hasRollbackTo() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * The config this deployment is rolling back to. Will be cleared after rollback is done.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getRollbackTo() {
      return rollbackTo_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
          : rollbackTo_;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * The config this deployment is rolling back to. Will be cleared after rollback is done.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder
        getRollbackToOrBuilder() {
      return rollbackTo_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
          : rollbackTo_;
    }

    public static final int PROGRESSDEADLINESECONDS_FIELD_NUMBER = 9;
    private int progressDeadlineSeconds_;
    /**
     *
     *
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. This is set to
     * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
     * +optional
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     */
    public boolean hasProgressDeadlineSeconds() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     *
     *
     * <pre>
     * The maximum time in seconds for a deployment to make progress before it
     * is considered to be failed. The deployment controller will continue to
     * process failed deployments and a condition with a ProgressDeadlineExceeded
     * reason will be surfaced in the deployment status. Note that progress will
     * not be estimated during the time a deployment is paused. This is set to
     * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
     * +optional
     * </pre>
     *
     * <code>optional int32 progressDeadlineSeconds = 9;</code>
     */
    public int getProgressDeadlineSeconds() {
      return progressDeadlineSeconds_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSelector());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getTemplate());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, getStrategy());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt32(5, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(6, revisionHistoryLimit_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeBool(7, paused_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeMessage(8, getRollbackTo());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeInt32(9, progressDeadlineSeconds_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSelector());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getTemplate());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, getStrategy());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(5, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(6, revisionHistoryLimit_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(7, paused_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(8, getRollbackTo());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(9, progressDeadlineSeconds_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec) obj;

      boolean result = true;
      result = result && (hasReplicas() == other.hasReplicas());
      if (hasReplicas()) {
        result = result && (getReplicas() == other.getReplicas());
      }
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector().equals(other.getSelector());
      }
      result = result && (hasTemplate() == other.hasTemplate());
      if (hasTemplate()) {
        result = result && getTemplate().equals(other.getTemplate());
      }
      result = result && (hasStrategy() == other.hasStrategy());
      if (hasStrategy()) {
        result = result && getStrategy().equals(other.getStrategy());
      }
      result = result && (hasMinReadySeconds() == other.hasMinReadySeconds());
      if (hasMinReadySeconds()) {
        result = result && (getMinReadySeconds() == other.getMinReadySeconds());
      }
      result = result && (hasRevisionHistoryLimit() == other.hasRevisionHistoryLimit());
      if (hasRevisionHistoryLimit()) {
        result = result && (getRevisionHistoryLimit() == other.getRevisionHistoryLimit());
      }
      result = result && (hasPaused() == other.hasPaused());
      if (hasPaused()) {
        result = result && (getPaused() == other.getPaused());
      }
      result = result && (hasRollbackTo() == other.hasRollbackTo());
      if (hasRollbackTo()) {
        result = result && getRollbackTo().equals(other.getRollbackTo());
      }
      result = result && (hasProgressDeadlineSeconds() == other.hasProgressDeadlineSeconds());
      if (hasProgressDeadlineSeconds()) {
        result = result && (getProgressDeadlineSeconds() == other.getProgressDeadlineSeconds());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (hasStrategy()) {
        hash = (37 * hash) + STRATEGY_FIELD_NUMBER;
        hash = (53 * hash) + getStrategy().hashCode();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasRevisionHistoryLimit()) {
        hash = (37 * hash) + REVISIONHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getRevisionHistoryLimit();
      }
      if (hasPaused()) {
        hash = (37 * hash) + PAUSED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getPaused());
      }
      if (hasRollbackTo()) {
        hash = (37 * hash) + ROLLBACKTO_FIELD_NUMBER;
        hash = (53 * hash) + getRollbackTo().hashCode();
      }
      if (hasProgressDeadlineSeconds()) {
        hash = (37 * hash) + PROGRESSDEADLINESECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getProgressDeadlineSeconds();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DeploymentSpec is the specification of the desired behavior of the Deployment.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentSpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DeploymentSpec)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
          getStrategyFieldBuilder();
          getRollbackToFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        replicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (templateBuilder_ == null) {
          template_ = null;
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (strategyBuilder_ == null) {
          strategy_ = null;
        } else {
          strategyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        minReadySeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        revisionHistoryLimit_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        paused_ = false;
        bitField0_ = (bitField0_ & ~0x00000040);
        if (rollbackToBuilder_ == null) {
          rollbackTo_ = null;
        } else {
          rollbackToBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        progressDeadlineSeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.replicas_ = replicas_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (templateBuilder_ == null) {
          result.template_ = template_;
        } else {
          result.template_ = templateBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (strategyBuilder_ == null) {
          result.strategy_ = strategy_;
        } else {
          result.strategy_ = strategyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.minReadySeconds_ = minReadySeconds_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.revisionHistoryLimit_ = revisionHistoryLimit_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.paused_ = paused_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        if (rollbackToBuilder_ == null) {
          result.rollbackTo_ = rollbackTo_;
        } else {
          result.rollbackTo_ = rollbackToBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.progressDeadlineSeconds_ = progressDeadlineSeconds_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec.getDefaultInstance())
          return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (other.hasStrategy()) {
          mergeStrategy(other.getStrategy());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasRevisionHistoryLimit()) {
          setRevisionHistoryLimit(other.getRevisionHistoryLimit());
        }
        if (other.hasPaused()) {
          setPaused(other.getPaused());
        }
        if (other.hasRollbackTo()) {
          mergeRollbackTo(other.getRollbackTo());
        }
        if (other.hasProgressDeadlineSeconds()) {
          setProgressDeadlineSeconds(other.getProgressDeadlineSeconds());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int replicas_;
      /**
       *
       *
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public int getReplicas() {
        return replicas_;
      }
      /**
       *
       *
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder setReplicas(int value) {
        bitField0_ |= 0x00000001;
        replicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Number of desired pods. This is a pointer to distinguish between explicit
       * zero and not specified. Defaults to 1.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          selectorBuilder_;
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && selector_ != null
              && selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
                io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : selector_;
        }
      }
      /**
       *
       *
       * <pre>
       * Label selector for pods. Existing ReplicaSets whose pods are
       * selected by this will be the ones affected by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.LabelSelector,
                  io.kubernetes.client.proto.Meta.LabelSelector.Builder,
                  io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(), getParentForChildren(), isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec,
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
              io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>
          templateBuilder_;
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null
              ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
              : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
          onChanged();
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
          onChanged();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && template_ != null
              && template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            template_ =
                io.kubernetes.client.proto.V1.PodTemplateSpec.newBuilder(template_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            template_ = value;
          }
          onChanged();
        } else {
          templateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder clearTemplate() {
        if (templateBuilder_ == null) {
          template_ = null;
          onChanged();
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null
              ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
              : template_;
        }
      }
      /**
       *
       *
       * <pre>
       * Template describes the pods that will be created.
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec,
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
              io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1.PodTemplateSpec,
                  io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
                  io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(), getParentForChildren(), isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy strategy_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder>
          strategyBuilder_;
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public boolean hasStrategy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy getStrategy() {
        if (strategyBuilder_ == null) {
          return strategy_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.getDefaultInstance()
              : strategy_;
        } else {
          return strategyBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder setStrategy(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy value) {
        if (strategyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          strategy_ = value;
          onChanged();
        } else {
          strategyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder setStrategy(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder builderForValue) {
        if (strategyBuilder_ == null) {
          strategy_ = builderForValue.build();
          onChanged();
        } else {
          strategyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder mergeStrategy(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy value) {
        if (strategyBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)
              && strategy_ != null
              && strategy_
                  != io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
                      .getDefaultInstance()) {
            strategy_ =
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.newBuilder(
                        strategy_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            strategy_ = value;
          }
          onChanged();
        } else {
          strategyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public Builder clearStrategy() {
        if (strategyBuilder_ == null) {
          strategy_ = null;
          onChanged();
        } else {
          strategyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder
          getStrategyBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getStrategyFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder
          getStrategyOrBuilder() {
        if (strategyBuilder_ != null) {
          return strategyBuilder_.getMessageOrBuilder();
        } else {
          return strategy_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.getDefaultInstance()
              : strategy_;
        }
      }
      /**
       *
       *
       * <pre>
       * The deployment strategy to use to replace existing pods with new ones.
       * +optional
       * +patchStrategy=retainKeys
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.DeploymentStrategy strategy = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder>
          getStrategyFieldBuilder() {
        if (strategyBuilder_ == null) {
          strategyBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder>(
                  getStrategy(), getParentForChildren(), isClean());
          strategy_ = null;
        }
        return strategyBuilder_;
      }

      private int minReadySeconds_;
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       */
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       */
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       */
      public Builder setMinReadySeconds(int value) {
        bitField0_ |= 0x00000010;
        minReadySeconds_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 5;</code>
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000010);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private int revisionHistoryLimit_;
      /**
       *
       *
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * This is set to the max value of int32 (i.e. 2147483647) by default, which
       * means "retaining all old ReplicaSets".
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public boolean hasRevisionHistoryLimit() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       *
       *
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * This is set to the max value of int32 (i.e. 2147483647) by default, which
       * means "retaining all old ReplicaSets".
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public int getRevisionHistoryLimit() {
        return revisionHistoryLimit_;
      }
      /**
       *
       *
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * This is set to the max value of int32 (i.e. 2147483647) by default, which
       * means "retaining all old ReplicaSets".
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public Builder setRevisionHistoryLimit(int value) {
        bitField0_ |= 0x00000020;
        revisionHistoryLimit_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of old ReplicaSets to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * This is set to the max value of int32 (i.e. 2147483647) by default, which
       * means "retaining all old ReplicaSets".
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public Builder clearRevisionHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000020);
        revisionHistoryLimit_ = 0;
        onChanged();
        return this;
      }

      private boolean paused_;
      /**
       *
       *
       * <pre>
       * Indicates that the deployment is paused and will not be processed by the
       * deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       */
      public boolean hasPaused() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       *
       *
       * <pre>
       * Indicates that the deployment is paused and will not be processed by the
       * deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       */
      public boolean getPaused() {
        return paused_;
      }
      /**
       *
       *
       * <pre>
       * Indicates that the deployment is paused and will not be processed by the
       * deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       */
      public Builder setPaused(boolean value) {
        bitField0_ |= 0x00000040;
        paused_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Indicates that the deployment is paused and will not be processed by the
       * deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional bool paused = 7;</code>
       */
      public Builder clearPaused() {
        bitField0_ = (bitField0_ & ~0x00000040);
        paused_ = false;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig rollbackTo_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder>
          rollbackToBuilder_;
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public boolean hasRollbackTo() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getRollbackTo() {
        if (rollbackToBuilder_ == null) {
          return rollbackTo_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
              : rollbackTo_;
        } else {
          return rollbackToBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public Builder setRollbackTo(
          io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig value) {
        if (rollbackToBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollbackTo_ = value;
          onChanged();
        } else {
          rollbackToBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public Builder setRollbackTo(
          io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder builderForValue) {
        if (rollbackToBuilder_ == null) {
          rollbackTo_ = builderForValue.build();
          onChanged();
        } else {
          rollbackToBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public Builder mergeRollbackTo(
          io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig value) {
        if (rollbackToBuilder_ == null) {
          if (((bitField0_ & 0x00000080) == 0x00000080)
              && rollbackTo_ != null
              && rollbackTo_
                  != io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig
                      .getDefaultInstance()) {
            rollbackTo_ =
                io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.newBuilder(rollbackTo_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            rollbackTo_ = value;
          }
          onChanged();
        } else {
          rollbackToBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public Builder clearRollbackTo() {
        if (rollbackToBuilder_ == null) {
          rollbackTo_ = null;
          onChanged();
        } else {
          rollbackToBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder
          getRollbackToBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getRollbackToFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder
          getRollbackToOrBuilder() {
        if (rollbackToBuilder_ != null) {
          return rollbackToBuilder_.getMessageOrBuilder();
        } else {
          return rollbackTo_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance()
              : rollbackTo_;
        }
      }
      /**
       *
       *
       * <pre>
       * DEPRECATED.
       * The config this deployment is rolling back to. Will be cleared after rollback is done.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollbackConfig rollbackTo = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder>
          getRollbackToFieldBuilder() {
        if (rollbackToBuilder_ == null) {
          rollbackToBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig,
                  io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder>(
                  getRollbackTo(), getParentForChildren(), isClean());
          rollbackTo_ = null;
        }
        return rollbackToBuilder_;
      }

      private int progressDeadlineSeconds_;
      /**
       *
       *
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. This is set to
       * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
       * +optional
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       */
      public boolean hasProgressDeadlineSeconds() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       *
       *
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. This is set to
       * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
       * +optional
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       */
      public int getProgressDeadlineSeconds() {
        return progressDeadlineSeconds_;
      }
      /**
       *
       *
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. This is set to
       * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
       * +optional
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       */
      public Builder setProgressDeadlineSeconds(int value) {
        bitField0_ |= 0x00000100;
        progressDeadlineSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum time in seconds for a deployment to make progress before it
       * is considered to be failed. The deployment controller will continue to
       * process failed deployments and a condition with a ProgressDeadlineExceeded
       * reason will be surfaced in the deployment status. Note that progress will
       * not be estimated during the time a deployment is paused. This is set to
       * the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
       * +optional
       * </pre>
       *
       * <code>optional int32 progressDeadlineSeconds = 9;</code>
       */
      public Builder clearProgressDeadlineSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        progressDeadlineSeconds_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DeploymentSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DeploymentSpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DeploymentSpec> PARSER =
        new com.google.protobuf.AbstractParser<DeploymentSpec>() {
          @java.lang.Override
          public DeploymentSpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DeploymentSpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DeploymentSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DeploymentStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    boolean hasObservedGeneration();
    /**
     *
     *
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    long getObservedGeneration();

    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     */
    boolean hasReplicas();
    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     */
    int getReplicas();

    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     */
    boolean hasUpdatedReplicas();
    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     */
    int getUpdatedReplicas();

    /**
     *
     *
     * <pre>
     * Total number of ready pods targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     */
    boolean hasReadyReplicas();
    /**
     *
     *
     * <pre>
     * Total number of ready pods targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     */
    int getReadyReplicas();

    /**
     *
     *
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     */
    boolean hasAvailableReplicas();
    /**
     *
     *
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     */
    int getAvailableReplicas();

    /**
     *
     *
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     */
    boolean hasUnavailableReplicas();
    /**
     *
     *
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     */
    int getUnavailableReplicas();

    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>
        getConditionsList();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition getConditions(int index);
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    int getConditionsCount();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder>
        getConditionsOrBuilderList();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder
        getConditionsOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     */
    boolean hasCollisionCount();
    /**
     *
     *
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     */
    int getCollisionCount();
  }
  /**
   *
   *
   * <pre>
   * DeploymentStatus is the most recently observed status of the Deployment.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentStatus}
   */
  public static final class DeploymentStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DeploymentStatus)
      DeploymentStatusOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DeploymentStatus.newBuilder() to construct.
    private DeploymentStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DeploymentStatus() {
      observedGeneration_ = 0L;
      replicas_ = 0;
      updatedReplicas_ = 0;
      readyReplicas_ = 0;
      availableReplicas_ = 0;
      unavailableReplicas_ = 0;
      conditions_ = java.util.Collections.emptyList();
      collisionCount_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DeploymentStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                observedGeneration_ = input.readInt64();
                break;
              }
            case 16:
              {
                bitField0_ |= 0x00000002;
                replicas_ = input.readInt32();
                break;
              }
            case 24:
              {
                bitField0_ |= 0x00000004;
                updatedReplicas_ = input.readInt32();
                break;
              }
            case 32:
              {
                bitField0_ |= 0x00000010;
                availableReplicas_ = input.readInt32();
                break;
              }
            case 40:
              {
                bitField0_ |= 0x00000020;
                unavailableReplicas_ = input.readInt32();
                break;
              }
            case 50:
              {
                if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                  conditions_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>();
                  mutable_bitField0_ |= 0x00000040;
                }
                conditions_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.PARSER,
                        extensionRegistry));
                break;
              }
            case 56:
              {
                bitField0_ |= 0x00000008;
                readyReplicas_ = input.readInt32();
                break;
              }
            case 64:
              {
                bitField0_ |= 0x00000040;
                collisionCount_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          conditions_ = java.util.Collections.unmodifiableList(conditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.class,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder.class);
    }

    private int bitField0_;
    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 1;
    private long observedGeneration_;
    /**
     *
     *
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * The generation observed by the deployment controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int REPLICAS_FIELD_NUMBER = 2;
    private int replicas_;
    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     */
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 2;</code>
     */
    public int getReplicas() {
      return replicas_;
    }

    public static final int UPDATEDREPLICAS_FIELD_NUMBER = 3;
    private int updatedReplicas_;
    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     */
    public boolean hasUpdatedReplicas() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedReplicas = 3;</code>
     */
    public int getUpdatedReplicas() {
      return updatedReplicas_;
    }

    public static final int READYREPLICAS_FIELD_NUMBER = 7;
    private int readyReplicas_;
    /**
     *
     *
     * <pre>
     * Total number of ready pods targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     */
    public boolean hasReadyReplicas() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * Total number of ready pods targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 7;</code>
     */
    public int getReadyReplicas() {
      return readyReplicas_;
    }

    public static final int AVAILABLEREPLICAS_FIELD_NUMBER = 4;
    private int availableReplicas_;
    /**
     *
     *
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     */
    public boolean hasAvailableReplicas() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 4;</code>
     */
    public int getAvailableReplicas() {
      return availableReplicas_;
    }

    public static final int UNAVAILABLEREPLICAS_FIELD_NUMBER = 5;
    private int unavailableReplicas_;
    /**
     *
     *
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     */
    public boolean hasUnavailableReplicas() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     *
     *
     * <pre>
     * Total number of unavailable pods targeted by this deployment. This is the total number of
     * pods that are still required for the deployment to have 100% available capacity. They may
     * either be pods that are running but not yet available or pods that still have not been created.
     * +optional
     * </pre>
     *
     * <code>optional int32 unavailableReplicas = 5;</code>
     */
    public int getUnavailableReplicas() {
      return unavailableReplicas_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 6;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>
        conditions_;
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>
        getConditionsList() {
      return conditions_;
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder>
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition getConditions(
        int index) {
      return conditions_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a deployment's current state.
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder
        getConditionsOrBuilder(int index) {
      return conditions_.get(index);
    }

    public static final int COLLISIONCOUNT_FIELD_NUMBER = 8;
    private int collisionCount_;
    /**
     *
     *
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     */
    public boolean hasCollisionCount() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     *
     *
     * <pre>
     * Count of hash collisions for the Deployment. The Deployment controller uses this
     * field as a collision avoidance mechanism when it needs to create the name for the
     * newest ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 8;</code>
     */
    public int getCollisionCount() {
      return collisionCount_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, replicas_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, updatedReplicas_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt32(4, availableReplicas_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(5, unavailableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(6, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(7, readyReplicas_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(8, collisionCount_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, replicas_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(3, updatedReplicas_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, availableReplicas_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(5, unavailableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, conditions_.get(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(7, readyReplicas_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(8, collisionCount_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus other =
          (io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus) obj;

      boolean result = true;
      result = result && (hasObservedGeneration() == other.hasObservedGeneration());
      if (hasObservedGeneration()) {
        result = result && (getObservedGeneration() == other.getObservedGeneration());
      }
      result = result && (hasReplicas() == other.hasReplicas());
      if (hasReplicas()) {
        result = result && (getReplicas() == other.getReplicas());
      }
      result = result && (hasUpdatedReplicas() == other.hasUpdatedReplicas());
      if (hasUpdatedReplicas()) {
        result = result && (getUpdatedReplicas() == other.getUpdatedReplicas());
      }
      result = result && (hasReadyReplicas() == other.hasReadyReplicas());
      if (hasReadyReplicas()) {
        result = result && (getReadyReplicas() == other.getReadyReplicas());
      }
      result = result && (hasAvailableReplicas() == other.hasAvailableReplicas());
      if (hasAvailableReplicas()) {
        result = result && (getAvailableReplicas() == other.getAvailableReplicas());
      }
      result = result && (hasUnavailableReplicas() == other.hasUnavailableReplicas());
      if (hasUnavailableReplicas()) {
        result = result && (getUnavailableReplicas() == other.getUnavailableReplicas());
      }
      result = result && getConditionsList().equals(other.getConditionsList());
      result = result && (hasCollisionCount() == other.hasCollisionCount());
      if (hasCollisionCount()) {
        result = result && (getCollisionCount() == other.getCollisionCount());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getObservedGeneration());
      }
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasUpdatedReplicas()) {
        hash = (37 * hash) + UPDATEDREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getUpdatedReplicas();
      }
      if (hasReadyReplicas()) {
        hash = (37 * hash) + READYREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReadyReplicas();
      }
      if (hasAvailableReplicas()) {
        hash = (37 * hash) + AVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getAvailableReplicas();
      }
      if (hasUnavailableReplicas()) {
        hash = (37 * hash) + UNAVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getUnavailableReplicas();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      if (hasCollisionCount()) {
        hash = (37 * hash) + COLLISIONCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCollisionCount();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DeploymentStatus is the most recently observed status of the Deployment.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentStatus}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DeploymentStatus)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.class,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getConditionsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        observedGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        updatedReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        readyReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        availableReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        unavailableReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
        } else {
          conditionsBuilder_.clear();
        }
        collisionCount_ = 0;
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus build() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus result =
            new io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.observedGeneration_ = observedGeneration_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.replicas_ = replicas_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.updatedReplicas_ = updatedReplicas_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.readyReplicas_ = readyReplicas_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.availableReplicas_ = availableReplicas_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.unavailableReplicas_ = unavailableReplicas_;
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000040;
        }
        result.collisionCount_ = collisionCount_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus.getDefaultInstance())
          return this;
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasUpdatedReplicas()) {
          setUpdatedReplicas(other.getUpdatedReplicas());
        }
        if (other.hasReadyReplicas()) {
          setReadyReplicas(other.getReadyReplicas());
        }
        if (other.hasAvailableReplicas()) {
          setAvailableReplicas(other.getAvailableReplicas());
        }
        if (other.hasUnavailableReplicas()) {
          setUnavailableReplicas(other.getUnavailableReplicas());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000040);
              conditionsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getConditionsFieldBuilder()
                      : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        if (other.hasCollisionCount()) {
          setCollisionCount(other.getCollisionCount());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private long observedGeneration_;
      /**
       *
       *
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       *
       *
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public Builder setObservedGeneration(long value) {
        bitField0_ |= 0x00000001;
        observedGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The generation observed by the deployment controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int replicas_;
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       */
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       */
      public int getReplicas() {
        return replicas_;
      }
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       */
      public Builder setReplicas(int value) {
        bitField0_ |= 0x00000002;
        replicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 2;</code>
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000002);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int updatedReplicas_;
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       */
      public boolean hasUpdatedReplicas() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       */
      public int getUpdatedReplicas() {
        return updatedReplicas_;
      }
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       */
      public Builder setUpdatedReplicas(int value) {
        bitField0_ |= 0x00000004;
        updatedReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedReplicas = 3;</code>
       */
      public Builder clearUpdatedReplicas() {
        bitField0_ = (bitField0_ & ~0x00000004);
        updatedReplicas_ = 0;
        onChanged();
        return this;
      }

      private int readyReplicas_;
      /**
       *
       *
       * <pre>
       * Total number of ready pods targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       */
      public boolean hasReadyReplicas() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * Total number of ready pods targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       */
      public int getReadyReplicas() {
        return readyReplicas_;
      }
      /**
       *
       *
       * <pre>
       * Total number of ready pods targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       */
      public Builder setReadyReplicas(int value) {
        bitField0_ |= 0x00000008;
        readyReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Total number of ready pods targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 7;</code>
       */
      public Builder clearReadyReplicas() {
        bitField0_ = (bitField0_ & ~0x00000008);
        readyReplicas_ = 0;
        onChanged();
        return this;
      }

      private int availableReplicas_;
      /**
       *
       *
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       */
      public boolean hasAvailableReplicas() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       */
      public int getAvailableReplicas() {
        return availableReplicas_;
      }
      /**
       *
       *
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       */
      public Builder setAvailableReplicas(int value) {
        bitField0_ |= 0x00000010;
        availableReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 4;</code>
       */
      public Builder clearAvailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000010);
        availableReplicas_ = 0;
        onChanged();
        return this;
      }

      private int unavailableReplicas_;
      /**
       *
       *
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       */
      public boolean hasUnavailableReplicas() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       *
       *
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       */
      public int getUnavailableReplicas() {
        return unavailableReplicas_;
      }
      /**
       *
       *
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       */
      public Builder setUnavailableReplicas(int value) {
        bitField0_ |= 0x00000020;
        unavailableReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Total number of unavailable pods targeted by this deployment. This is the total number of
       * pods that are still required for the deployment to have 100% available capacity. They may
       * either be pods that are running but not yet available or pods that still have not been created.
       * +optional
       * </pre>
       *
       * <code>optional int32 unavailableReplicas = 5;</code>
       */
      public Builder clearUnavailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000020);
        unavailableReplicas_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>
          conditions_ = java.util.Collections.emptyList();

      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          conditions_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>(conditions_);
          bitField0_ |= 0x00000040;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder>
          conditionsBuilder_;

      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>
          getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition getConditions(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder
              builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder
              builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder
              builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition>
              values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder
          getConditionsBuilder(int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder
          getConditionsOrBuilder(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder>
          getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder
          addConditionsBuilder() {
        return getConditionsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder
          addConditionsBuilder(int index) {
        return getConditionsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a deployment's current state.
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.DeploymentCondition conditions = 6;</code>
       */
      public java.util.List<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder>
          getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder>
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentCondition.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.DeploymentConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000040) == 0x00000040),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      private int collisionCount_;
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       */
      public boolean hasCollisionCount() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       */
      public int getCollisionCount() {
        return collisionCount_;
      }
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       */
      public Builder setCollisionCount(int value) {
        bitField0_ |= 0x00000080;
        collisionCount_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Count of hash collisions for the Deployment. The Deployment controller uses this
       * field as a collision avoidance mechanism when it needs to create the name for the
       * newest ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 8;</code>
       */
      public Builder clearCollisionCount() {
        bitField0_ = (bitField0_ & ~0x00000080);
        collisionCount_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DeploymentStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DeploymentStatus)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DeploymentStatus> PARSER =
        new com.google.protobuf.AbstractParser<DeploymentStatus>() {
          @java.lang.Override
          public DeploymentStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DeploymentStatus(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DeploymentStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStatus
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DeploymentStrategyOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.DeploymentStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     *
     *
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     *
     *
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString getTypeBytes();

    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
     * </code>
     */
    boolean hasRollingUpdate();
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment getRollingUpdate();
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder
        getRollingUpdateOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DeploymentStrategy describes how to replace existing pods with new ones.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentStrategy}
   */
  public static final class DeploymentStrategy extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.DeploymentStrategy)
      DeploymentStrategyOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use DeploymentStrategy.newBuilder() to construct.
    private DeploymentStrategy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DeploymentStrategy() {
      type_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private DeploymentStrategy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                type_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = rollingUpdate_.toBuilder();
                }
                rollingUpdate_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(rollingUpdate_);
                  rollingUpdate_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.class,
              io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     *
     *
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROLLINGUPDATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment rollingUpdate_;
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
     * </code>
     */
    public boolean hasRollingUpdate() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment getRollingUpdate() {
      return rollingUpdate_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
              .getDefaultInstance()
          : rollingUpdate_;
    }
    /**
     *
     *
     * <pre>
     * Rolling update config params. Present only if DeploymentStrategyType =
     * RollingUpdate.
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder
        getRollingUpdateOrBuilder() {
      return rollingUpdate_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
              .getDefaultInstance()
          : rollingUpdate_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getRollingUpdate());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getRollingUpdate());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy other =
          (io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType().equals(other.getType());
      }
      result = result && (hasRollingUpdate() == other.hasRollingUpdate());
      if (hasRollingUpdate()) {
        result = result && getRollingUpdate().equals(other.getRollingUpdate());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasRollingUpdate()) {
        hash = (37 * hash) + ROLLINGUPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getRollingUpdate().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DeploymentStrategy describes how to replace existing pods with new ones.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.DeploymentStrategy}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.DeploymentStrategy)
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.class,
                io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRollingUpdateFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = null;
        } else {
          rollingUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy build() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy result =
            new io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (rollingUpdateBuilder_ == null) {
          result.rollingUpdate_ = rollingUpdate_;
        } else {
          result.rollingUpdate_ = rollingUpdateBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy.getDefaultInstance())
          return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasRollingUpdate()) {
          mergeRollingUpdate(other.getRollingUpdate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       *
       *
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment rollingUpdate_ =
          null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder>
          rollingUpdateBuilder_;
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public boolean hasRollingUpdate() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
          getRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          return rollingUpdate_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
                  .getDefaultInstance()
              : rollingUpdate_;
        } else {
          return rollingUpdateBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment value) {
        if (rollingUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollingUpdate_ = value;
          onChanged();
        } else {
          rollingUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder
              builderForValue) {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = builderForValue.build();
          onChanged();
        } else {
          rollingUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public Builder mergeRollingUpdate(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment value) {
        if (rollingUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && rollingUpdate_ != null
              && rollingUpdate_
                  != io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
                      .getDefaultInstance()) {
            rollingUpdate_ =
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.newBuilder(
                        rollingUpdate_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            rollingUpdate_ = value;
          }
          onChanged();
        } else {
          rollingUpdateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public Builder clearRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = null;
          onChanged();
        } else {
          rollingUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder
          getRollingUpdateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRollingUpdateFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder
          getRollingUpdateOrBuilder() {
        if (rollingUpdateBuilder_ != null) {
          return rollingUpdateBuilder_.getMessageOrBuilder();
        } else {
          return rollingUpdate_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
                  .getDefaultInstance()
              : rollingUpdate_;
        }
      }
      /**
       *
       *
       * <pre>
       * Rolling update config params. Present only if DeploymentStrategyType =
       * RollingUpdate.
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder>
          getRollingUpdateFieldBuilder() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment,
                  io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder>(
                  getRollingUpdate(), getParentForChildren(), isClean());
          rollingUpdate_ = null;
        }
        return rollingUpdateBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.DeploymentStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.DeploymentStrategy)
    private static final io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<DeploymentStrategy> PARSER =
        new com.google.protobuf.AbstractParser<DeploymentStrategy>() {
          @java.lang.Override
          public DeploymentStrategy parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new DeploymentStrategy(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<DeploymentStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeploymentStrategy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.DeploymentStrategy
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface FSGroupStrategyOptionsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    boolean hasRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    java.lang.String getRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    com.google.protobuf.ByteString getRuleBytes();

    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index);
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    int getRangesCount();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
   * Deprecated: use FSGroupStrategyOptions from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions}
   */
  public static final class FSGroupStrategyOptions extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions)
      FSGroupStrategyOptionsOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use FSGroupStrategyOptions.newBuilder() to construct.
    private FSGroupStrategyOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private FSGroupStrategyOptions() {
      rule_ = "";
      ranges_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private FSGroupStrategyOptions(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                rule_ = bs;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  ranges_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.IDRange>();
                  mutable_bitField0_ |= 0x00000002;
                }
                ranges_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IDRange.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ = java.util.Collections.unmodifiableList(ranges_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.class,
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder.class);
    }

    private int bitField0_;
    public static final int RULE_FIELD_NUMBER = 1;
    private volatile java.lang.Object rule_;
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public boolean hasRule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public java.lang.String getRule() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          rule_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public com.google.protobuf.ByteString getRuleBytes() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        rule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RANGES_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_;
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public int getRangesCount() {
      return ranges_.size();
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
      return ranges_.get(index);
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of fs groups.  If you would like to force a single
     * fs group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
        int index) {
      return ranges_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        output.writeMessage(2, ranges_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, ranges_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions other =
          (io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions) obj;

      boolean result = true;
      result = result && (hasRule() == other.hasRule());
      if (hasRule()) {
        result = result && getRule().equals(other.getRule());
      }
      result = result && getRangesList().equals(other.getRangesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRule()) {
        hash = (37 * hash) + RULE_FIELD_NUMBER;
        hash = (53 * hash) + getRule().hashCode();
      }
      if (getRangesCount() > 0) {
        hash = (37 * hash) + RANGES_FIELD_NUMBER;
        hash = (53 * hash) + getRangesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
     * Deprecated: use FSGroupStrategyOptions from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions)
        io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.class,
                io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRangesFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        rule_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions build() {
        io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions result =
            new io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.rule_ = rule_;
        if (rangesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            ranges_ = java.util.Collections.unmodifiableList(ranges_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.ranges_ = ranges_;
        } else {
          result.ranges_ = rangesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
                .getDefaultInstance()) return this;
        if (other.hasRule()) {
          bitField0_ |= 0x00000001;
          rule_ = other.rule_;
          onChanged();
        }
        if (rangesBuilder_ == null) {
          if (!other.ranges_.isEmpty()) {
            if (ranges_.isEmpty()) {
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureRangesIsMutable();
              ranges_.addAll(other.ranges_);
            }
            onChanged();
          }
        } else {
          if (!other.ranges_.isEmpty()) {
            if (rangesBuilder_.isEmpty()) {
              rangesBuilder_.dispose();
              rangesBuilder_ = null;
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
              rangesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getRangesFieldBuilder()
                      : null;
            } else {
              rangesBuilder_.addAllMessages(other.ranges_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object rule_ = "";
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public boolean hasRule() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public java.lang.String getRule() {
        java.lang.Object ref = rule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            rule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public com.google.protobuf.ByteString getRuleBytes() {
        java.lang.Object ref = rule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          rule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRule(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder clearRule() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rule_ = getDefaultInstance().getRule();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRuleBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_ =
          java.util.Collections.emptyList();

      private void ensureRangesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.IDRange>(
                  ranges_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          rangesBuilder_;

      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
        if (rangesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ranges_);
        } else {
          return rangesBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public int getRangesCount() {
        if (rangesBuilder_ == null) {
          return ranges_.size();
        } else {
          return rangesBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.set(index, value);
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.set(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(index, value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addAllRanges(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRange>
              values) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ranges_);
          onChanged();
        } else {
          rangesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder clearRanges() {
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder removeRanges(int index) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.remove(index);
          onChanged();
        } else {
          rangesBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder getRangesBuilder(
          int index) {
        return getRangesFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
          int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesOrBuilderList() {
        if (rangesBuilder_ != null) {
          return rangesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ranges_);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder() {
        return getRangesFieldBuilder()
            .addBuilder(io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder(
          int index) {
        return getRangesFieldBuilder()
            .addBuilder(
                index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of fs groups.  If you would like to force a single
       * fs group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder>
          getRangesBuilderList() {
        return getRangesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesFieldBuilder() {
        if (rangesBuilder_ == null) {
          rangesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>(
                  ranges_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          ranges_ = null;
        }
        return rangesBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions)
    private static final io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<FSGroupStrategyOptions> PARSER =
        new com.google.protobuf.AbstractParser<FSGroupStrategyOptions>() {
          @java.lang.Override
          public FSGroupStrategyOptions parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new FSGroupStrategyOptions(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<FSGroupStrategyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FSGroupStrategyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface HTTPIngressPathOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.HTTPIngressPath)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
     * all paths from incoming requests are matched.
     * +optional
     * </pre>
     *
     * <code>optional string path = 1;</code>
     */
    boolean hasPath();
    /**
     *
     *
     * <pre>
     * Path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
     * all paths from incoming requests are matched.
     * +optional
     * </pre>
     *
     * <code>optional string path = 1;</code>
     */
    java.lang.String getPath();
    /**
     *
     *
     * <pre>
     * Path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
     * all paths from incoming requests are matched.
     * +optional
     * </pre>
     *
     * <code>optional string path = 1;</code>
     */
    com.google.protobuf.ByteString getPathBytes();

    /**
     *
     *
     * <pre>
     * PathType determines the interpretation of the Path matching. PathType can
     * be one of the following values:
     * * Exact: Matches the URL path exactly.
     * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
     *   done on a path element by element basis. A path element refers is the
     *   list of labels in the path split by the '/' separator. A request is a
     *   match for path p if every p is an element-wise prefix of p of the
     *   request path. Note that if the last element of the path is a substring
     *   of the last element in request path, it is not a match (e.g. /foo/bar
     *   matches /foo/bar/baz, but does not match /foo/barbaz).
     * * ImplementationSpecific: Interpretation of the Path matching is up to
     *   the IngressClass. Implementations can treat this as a separate PathType
     *   or treat it identically to Prefix or Exact path types.
     * Implementations are required to support all path types.
     * Defaults to ImplementationSpecific.
     * </pre>
     *
     * <code>optional string pathType = 3;</code>
     */
    boolean hasPathType();
    /**
     *
     *
     * <pre>
     * PathType determines the interpretation of the Path matching. PathType can
     * be one of the following values:
     * * Exact: Matches the URL path exactly.
     * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
     *   done on a path element by element basis. A path element refers is the
     *   list of labels in the path split by the '/' separator. A request is a
     *   match for path p if every p is an element-wise prefix of p of the
     *   request path. Note that if the last element of the path is a substring
     *   of the last element in request path, it is not a match (e.g. /foo/bar
     *   matches /foo/bar/baz, but does not match /foo/barbaz).
     * * ImplementationSpecific: Interpretation of the Path matching is up to
     *   the IngressClass. Implementations can treat this as a separate PathType
     *   or treat it identically to Prefix or Exact path types.
     * Implementations are required to support all path types.
     * Defaults to ImplementationSpecific.
     * </pre>
     *
     * <code>optional string pathType = 3;</code>
     */
    java.lang.String getPathType();
    /**
     *
     *
     * <pre>
     * PathType determines the interpretation of the Path matching. PathType can
     * be one of the following values:
     * * Exact: Matches the URL path exactly.
     * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
     *   done on a path element by element basis. A path element refers is the
     *   list of labels in the path split by the '/' separator. A request is a
     *   match for path p if every p is an element-wise prefix of p of the
     *   request path. Note that if the last element of the path is a substring
     *   of the last element in request path, it is not a match (e.g. /foo/bar
     *   matches /foo/bar/baz, but does not match /foo/barbaz).
     * * ImplementationSpecific: Interpretation of the Path matching is up to
     *   the IngressClass. Implementations can treat this as a separate PathType
     *   or treat it identically to Prefix or Exact path types.
     * Implementations are required to support all path types.
     * Defaults to ImplementationSpecific.
     * </pre>
     *
     * <code>optional string pathType = 3;</code>
     */
    com.google.protobuf.ByteString getPathTypeBytes();

    /**
     *
     *
     * <pre>
     * Backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
     */
    boolean hasBackend();
    /**
     *
     *
     * <pre>
     * Backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getBackend();
    /**
     *
     *
     * <pre>
     * Backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder getBackendOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * HTTPIngressPath associates a path with a backend. Incoming urls matching the
   * path are forwarded to the backend.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.HTTPIngressPath}
   */
  public static final class HTTPIngressPath extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.HTTPIngressPath)
      HTTPIngressPathOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use HTTPIngressPath.newBuilder() to construct.
    private HTTPIngressPath(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private HTTPIngressPath() {
      path_ = "";
      pathType_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private HTTPIngressPath(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                path_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = backend_.toBuilder();
                }
                backend_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(backend_);
                  backend_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 26:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000002;
                pathType_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.class,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder.class);
    }

    private int bitField0_;
    public static final int PATH_FIELD_NUMBER = 1;
    private volatile java.lang.Object path_;
    /**
     *
     *
     * <pre>
     * Path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
     * all paths from incoming requests are matched.
     * +optional
     * </pre>
     *
     * <code>optional string path = 1;</code>
     */
    public boolean hasPath() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
     * all paths from incoming requests are matched.
     * +optional
     * </pre>
     *
     * <code>optional string path = 1;</code>
     */
    public java.lang.String getPath() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          path_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
     * all paths from incoming requests are matched.
     * +optional
     * </pre>
     *
     * <code>optional string path = 1;</code>
     */
    public com.google.protobuf.ByteString getPathBytes() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        path_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PATHTYPE_FIELD_NUMBER = 3;
    private volatile java.lang.Object pathType_;
    /**
     *
     *
     * <pre>
     * PathType determines the interpretation of the Path matching. PathType can
     * be one of the following values:
     * * Exact: Matches the URL path exactly.
     * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
     *   done on a path element by element basis. A path element refers is the
     *   list of labels in the path split by the '/' separator. A request is a
     *   match for path p if every p is an element-wise prefix of p of the
     *   request path. Note that if the last element of the path is a substring
     *   of the last element in request path, it is not a match (e.g. /foo/bar
     *   matches /foo/bar/baz, but does not match /foo/barbaz).
     * * ImplementationSpecific: Interpretation of the Path matching is up to
     *   the IngressClass. Implementations can treat this as a separate PathType
     *   or treat it identically to Prefix or Exact path types.
     * Implementations are required to support all path types.
     * Defaults to ImplementationSpecific.
     * </pre>
     *
     * <code>optional string pathType = 3;</code>
     */
    public boolean hasPathType() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * PathType determines the interpretation of the Path matching. PathType can
     * be one of the following values:
     * * Exact: Matches the URL path exactly.
     * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
     *   done on a path element by element basis. A path element refers is the
     *   list of labels in the path split by the '/' separator. A request is a
     *   match for path p if every p is an element-wise prefix of p of the
     *   request path. Note that if the last element of the path is a substring
     *   of the last element in request path, it is not a match (e.g. /foo/bar
     *   matches /foo/bar/baz, but does not match /foo/barbaz).
     * * ImplementationSpecific: Interpretation of the Path matching is up to
     *   the IngressClass. Implementations can treat this as a separate PathType
     *   or treat it identically to Prefix or Exact path types.
     * Implementations are required to support all path types.
     * Defaults to ImplementationSpecific.
     * </pre>
     *
     * <code>optional string pathType = 3;</code>
     */
    public java.lang.String getPathType() {
      java.lang.Object ref = pathType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          pathType_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * PathType determines the interpretation of the Path matching. PathType can
     * be one of the following values:
     * * Exact: Matches the URL path exactly.
     * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
     *   done on a path element by element basis. A path element refers is the
     *   list of labels in the path split by the '/' separator. A request is a
     *   match for path p if every p is an element-wise prefix of p of the
     *   request path. Note that if the last element of the path is a substring
     *   of the last element in request path, it is not a match (e.g. /foo/bar
     *   matches /foo/bar/baz, but does not match /foo/barbaz).
     * * ImplementationSpecific: Interpretation of the Path matching is up to
     *   the IngressClass. Implementations can treat this as a separate PathType
     *   or treat it identically to Prefix or Exact path types.
     * Implementations are required to support all path types.
     * Defaults to ImplementationSpecific.
     * </pre>
     *
     * <code>optional string pathType = 3;</code>
     */
    public com.google.protobuf.ByteString getPathTypeBytes() {
      java.lang.Object ref = pathType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        pathType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BACKEND_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.IngressBackend backend_;
    /**
     *
     *
     * <pre>
     * Backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
     */
    public boolean hasBackend() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getBackend() {
      return backend_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
          : backend_;
    }
    /**
     *
     *
     * <pre>
     * Backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder
        getBackendOrBuilder() {
      return backend_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
          : backend_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, path_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(2, getBackend());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, pathType_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, path_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getBackend());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, pathType_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath other =
          (io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath) obj;

      boolean result = true;
      result = result && (hasPath() == other.hasPath());
      if (hasPath()) {
        result = result && getPath().equals(other.getPath());
      }
      result = result && (hasPathType() == other.hasPathType());
      if (hasPathType()) {
        result = result && getPathType().equals(other.getPathType());
      }
      result = result && (hasBackend() == other.hasBackend());
      if (hasBackend()) {
        result = result && getBackend().equals(other.getBackend());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPath()) {
        hash = (37 * hash) + PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPath().hashCode();
      }
      if (hasPathType()) {
        hash = (37 * hash) + PATHTYPE_FIELD_NUMBER;
        hash = (53 * hash) + getPathType().hashCode();
      }
      if (hasBackend()) {
        hash = (37 * hash) + BACKEND_FIELD_NUMBER;
        hash = (53 * hash) + getBackend().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * HTTPIngressPath associates a path with a backend. Incoming urls matching the
     * path are forwarded to the backend.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.HTTPIngressPath}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.HTTPIngressPath)
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.class,
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getBackendFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        path_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        pathType_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (backendBuilder_ == null) {
          backend_ = null;
        } else {
          backendBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath build() {
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath result =
            new io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.path_ = path_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.pathType_ = pathType_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (backendBuilder_ == null) {
          result.backend_ = backend_;
        } else {
          result.backend_ = backendBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.getDefaultInstance())
          return this;
        if (other.hasPath()) {
          bitField0_ |= 0x00000001;
          path_ = other.path_;
          onChanged();
        }
        if (other.hasPathType()) {
          bitField0_ |= 0x00000002;
          pathType_ = other.pathType_;
          onChanged();
        }
        if (other.hasBackend()) {
          mergeBackend(other.getBackend());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object path_ = "";
      /**
       *
       *
       * <pre>
       * Path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
       * all paths from incoming requests are matched.
       * +optional
       * </pre>
       *
       * <code>optional string path = 1;</code>
       */
      public boolean hasPath() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
       * all paths from incoming requests are matched.
       * +optional
       * </pre>
       *
       * <code>optional string path = 1;</code>
       */
      public java.lang.String getPath() {
        java.lang.Object ref = path_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            path_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
       * all paths from incoming requests are matched.
       * +optional
       * </pre>
       *
       * <code>optional string path = 1;</code>
       */
      public com.google.protobuf.ByteString getPathBytes() {
        java.lang.Object ref = path_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          path_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
       * all paths from incoming requests are matched.
       * +optional
       * </pre>
       *
       * <code>optional string path = 1;</code>
       */
      public Builder setPath(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        path_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
       * all paths from incoming requests are matched.
       * +optional
       * </pre>
       *
       * <code>optional string path = 1;</code>
       */
      public Builder clearPath() {
        bitField0_ = (bitField0_ & ~0x00000001);
        path_ = getDefaultInstance().getPath();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'. When unspecified,
       * all paths from incoming requests are matched.
       * +optional
       * </pre>
       *
       * <code>optional string path = 1;</code>
       */
      public Builder setPathBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        path_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object pathType_ = "";
      /**
       *
       *
       * <pre>
       * PathType determines the interpretation of the Path matching. PathType can
       * be one of the following values:
       * * Exact: Matches the URL path exactly.
       * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
       *   done on a path element by element basis. A path element refers is the
       *   list of labels in the path split by the '/' separator. A request is a
       *   match for path p if every p is an element-wise prefix of p of the
       *   request path. Note that if the last element of the path is a substring
       *   of the last element in request path, it is not a match (e.g. /foo/bar
       *   matches /foo/bar/baz, but does not match /foo/barbaz).
       * * ImplementationSpecific: Interpretation of the Path matching is up to
       *   the IngressClass. Implementations can treat this as a separate PathType
       *   or treat it identically to Prefix or Exact path types.
       * Implementations are required to support all path types.
       * Defaults to ImplementationSpecific.
       * </pre>
       *
       * <code>optional string pathType = 3;</code>
       */
      public boolean hasPathType() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * PathType determines the interpretation of the Path matching. PathType can
       * be one of the following values:
       * * Exact: Matches the URL path exactly.
       * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
       *   done on a path element by element basis. A path element refers is the
       *   list of labels in the path split by the '/' separator. A request is a
       *   match for path p if every p is an element-wise prefix of p of the
       *   request path. Note that if the last element of the path is a substring
       *   of the last element in request path, it is not a match (e.g. /foo/bar
       *   matches /foo/bar/baz, but does not match /foo/barbaz).
       * * ImplementationSpecific: Interpretation of the Path matching is up to
       *   the IngressClass. Implementations can treat this as a separate PathType
       *   or treat it identically to Prefix or Exact path types.
       * Implementations are required to support all path types.
       * Defaults to ImplementationSpecific.
       * </pre>
       *
       * <code>optional string pathType = 3;</code>
       */
      public java.lang.String getPathType() {
        java.lang.Object ref = pathType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            pathType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * PathType determines the interpretation of the Path matching. PathType can
       * be one of the following values:
       * * Exact: Matches the URL path exactly.
       * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
       *   done on a path element by element basis. A path element refers is the
       *   list of labels in the path split by the '/' separator. A request is a
       *   match for path p if every p is an element-wise prefix of p of the
       *   request path. Note that if the last element of the path is a substring
       *   of the last element in request path, it is not a match (e.g. /foo/bar
       *   matches /foo/bar/baz, but does not match /foo/barbaz).
       * * ImplementationSpecific: Interpretation of the Path matching is up to
       *   the IngressClass. Implementations can treat this as a separate PathType
       *   or treat it identically to Prefix or Exact path types.
       * Implementations are required to support all path types.
       * Defaults to ImplementationSpecific.
       * </pre>
       *
       * <code>optional string pathType = 3;</code>
       */
      public com.google.protobuf.ByteString getPathTypeBytes() {
        java.lang.Object ref = pathType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          pathType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * PathType determines the interpretation of the Path matching. PathType can
       * be one of the following values:
       * * Exact: Matches the URL path exactly.
       * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
       *   done on a path element by element basis. A path element refers is the
       *   list of labels in the path split by the '/' separator. A request is a
       *   match for path p if every p is an element-wise prefix of p of the
       *   request path. Note that if the last element of the path is a substring
       *   of the last element in request path, it is not a match (e.g. /foo/bar
       *   matches /foo/bar/baz, but does not match /foo/barbaz).
       * * ImplementationSpecific: Interpretation of the Path matching is up to
       *   the IngressClass. Implementations can treat this as a separate PathType
       *   or treat it identically to Prefix or Exact path types.
       * Implementations are required to support all path types.
       * Defaults to ImplementationSpecific.
       * </pre>
       *
       * <code>optional string pathType = 3;</code>
       */
      public Builder setPathType(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        pathType_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * PathType determines the interpretation of the Path matching. PathType can
       * be one of the following values:
       * * Exact: Matches the URL path exactly.
       * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
       *   done on a path element by element basis. A path element refers is the
       *   list of labels in the path split by the '/' separator. A request is a
       *   match for path p if every p is an element-wise prefix of p of the
       *   request path. Note that if the last element of the path is a substring
       *   of the last element in request path, it is not a match (e.g. /foo/bar
       *   matches /foo/bar/baz, but does not match /foo/barbaz).
       * * ImplementationSpecific: Interpretation of the Path matching is up to
       *   the IngressClass. Implementations can treat this as a separate PathType
       *   or treat it identically to Prefix or Exact path types.
       * Implementations are required to support all path types.
       * Defaults to ImplementationSpecific.
       * </pre>
       *
       * <code>optional string pathType = 3;</code>
       */
      public Builder clearPathType() {
        bitField0_ = (bitField0_ & ~0x00000002);
        pathType_ = getDefaultInstance().getPathType();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * PathType determines the interpretation of the Path matching. PathType can
       * be one of the following values:
       * * Exact: Matches the URL path exactly.
       * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
       *   done on a path element by element basis. A path element refers is the
       *   list of labels in the path split by the '/' separator. A request is a
       *   match for path p if every p is an element-wise prefix of p of the
       *   request path. Note that if the last element of the path is a substring
       *   of the last element in request path, it is not a match (e.g. /foo/bar
       *   matches /foo/bar/baz, but does not match /foo/barbaz).
       * * ImplementationSpecific: Interpretation of the Path matching is up to
       *   the IngressClass. Implementations can treat this as a separate PathType
       *   or treat it identically to Prefix or Exact path types.
       * Implementations are required to support all path types.
       * Defaults to ImplementationSpecific.
       * </pre>
       *
       * <code>optional string pathType = 3;</code>
       */
      public Builder setPathTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        pathType_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.IngressBackend backend_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder>
          backendBuilder_;
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public boolean hasBackend() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getBackend() {
        if (backendBuilder_ == null) {
          return backend_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
              : backend_;
        } else {
          return backendBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public Builder setBackend(io.kubernetes.client.proto.V1beta1Extensions.IngressBackend value) {
        if (backendBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          backend_ = value;
          onChanged();
        } else {
          backendBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public Builder setBackend(
          io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder builderForValue) {
        if (backendBuilder_ == null) {
          backend_ = builderForValue.build();
          onChanged();
        } else {
          backendBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public Builder mergeBackend(
          io.kubernetes.client.proto.V1beta1Extensions.IngressBackend value) {
        if (backendBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && backend_ != null
              && backend_
                  != io.kubernetes.client.proto.V1beta1Extensions.IngressBackend
                      .getDefaultInstance()) {
            backend_ =
                io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.newBuilder(backend_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            backend_ = value;
          }
          onChanged();
        } else {
          backendBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public Builder clearBackend() {
        if (backendBuilder_ == null) {
          backend_ = null;
          onChanged();
        } else {
          backendBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder
          getBackendBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getBackendFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder
          getBackendOrBuilder() {
        if (backendBuilder_ != null) {
          return backendBuilder_.getMessageOrBuilder();
        } else {
          return backend_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
              : backend_;
        }
      }
      /**
       *
       *
       * <pre>
       * Backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder>
          getBackendFieldBuilder() {
        if (backendBuilder_ == null) {
          backendBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressBackend,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder>(
                  getBackend(), getParentForChildren(), isClean());
          backend_ = null;
        }
        return backendBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.HTTPIngressPath)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.HTTPIngressPath)
    private static final io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<HTTPIngressPath> PARSER =
        new com.google.protobuf.AbstractParser<HTTPIngressPath>() {
          @java.lang.Override
          public HTTPIngressPath parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new HTTPIngressPath(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<HTTPIngressPath> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HTTPIngressPath> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface HTTPIngressRuleValueOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath> getPathsList();
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath getPaths(int index);
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    int getPathsCount();
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder>
        getPathsOrBuilderList();
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder getPathsOrBuilder(
        int index);
  }
  /**
   *
   *
   * <pre>
   * HTTPIngressRuleValue is a list of http selectors pointing to backends.
   * In the example: http://&lt;host&gt;/&lt;path&gt;?&lt;searchpart&gt; -&gt; backend where
   * where parts of the url correspond to RFC 3986, this resource will be used
   * to match against everything after the last '/' and before the first '?'
   * or '#'.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue}
   */
  public static final class HTTPIngressRuleValue extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue)
      HTTPIngressRuleValueOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use HTTPIngressRuleValue.newBuilder() to construct.
    private HTTPIngressRuleValue(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private HTTPIngressRuleValue() {
      paths_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private HTTPIngressRuleValue(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  paths_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath>();
                  mutable_bitField0_ |= 0x00000001;
                }
                paths_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          paths_ = java.util.Collections.unmodifiableList(paths_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.class,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder.class);
    }

    public static final int PATHS_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath> paths_;
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath>
        getPathsList() {
      return paths_;
    }
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder>
        getPathsOrBuilderList() {
      return paths_;
    }
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    public int getPathsCount() {
      return paths_.size();
    }
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath getPaths(int index) {
      return paths_.get(index);
    }
    /**
     *
     *
     * <pre>
     * A collection of paths that map requests to backends.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder getPathsOrBuilder(
        int index) {
      return paths_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < paths_.size(); i++) {
        output.writeMessage(1, paths_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < paths_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, paths_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue other =
          (io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue) obj;

      boolean result = true;
      result = result && getPathsList().equals(other.getPathsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getPathsCount() > 0) {
        hash = (37 * hash) + PATHS_FIELD_NUMBER;
        hash = (53 * hash) + getPathsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * HTTPIngressRuleValue is a list of http selectors pointing to backends.
     * In the example: http://&lt;host&gt;/&lt;path&gt;?&lt;searchpart&gt; -&gt; backend where
     * where parts of the url correspond to RFC 3986, this resource will be used
     * to match against everything after the last '/' and before the first '?'
     * or '#'.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue)
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.class,
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getPathsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (pathsBuilder_ == null) {
          paths_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          pathsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue build() {
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue result =
            new io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue(this);
        int from_bitField0_ = bitField0_;
        if (pathsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            paths_ = java.util.Collections.unmodifiableList(paths_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.paths_ = paths_;
        } else {
          result.paths_ = pathsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
                .getDefaultInstance()) return this;
        if (pathsBuilder_ == null) {
          if (!other.paths_.isEmpty()) {
            if (paths_.isEmpty()) {
              paths_ = other.paths_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensurePathsIsMutable();
              paths_.addAll(other.paths_);
            }
            onChanged();
          }
        } else {
          if (!other.paths_.isEmpty()) {
            if (pathsBuilder_.isEmpty()) {
              pathsBuilder_.dispose();
              pathsBuilder_ = null;
              paths_ = other.paths_;
              bitField0_ = (bitField0_ & ~0x00000001);
              pathsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getPathsFieldBuilder()
                      : null;
            } else {
              pathsBuilder_.addAllMessages(other.paths_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath> paths_ =
          java.util.Collections.emptyList();

      private void ensurePathsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          paths_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath>(
                  paths_);
          bitField0_ |= 0x00000001;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder>
          pathsBuilder_;

      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath>
          getPathsList() {
        if (pathsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(paths_);
        } else {
          return pathsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public int getPathsCount() {
        if (pathsBuilder_ == null) {
          return paths_.size();
        } else {
          return pathsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath getPaths(int index) {
        if (pathsBuilder_ == null) {
          return paths_.get(index);
        } else {
          return pathsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder setPaths(
          int index, io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath value) {
        if (pathsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePathsIsMutable();
          paths_.set(index, value);
          onChanged();
        } else {
          pathsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder setPaths(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder builderForValue) {
        if (pathsBuilder_ == null) {
          ensurePathsIsMutable();
          paths_.set(index, builderForValue.build());
          onChanged();
        } else {
          pathsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder addPaths(io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath value) {
        if (pathsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePathsIsMutable();
          paths_.add(value);
          onChanged();
        } else {
          pathsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder addPaths(
          int index, io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath value) {
        if (pathsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePathsIsMutable();
          paths_.add(index, value);
          onChanged();
        } else {
          pathsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder addPaths(
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder builderForValue) {
        if (pathsBuilder_ == null) {
          ensurePathsIsMutable();
          paths_.add(builderForValue.build());
          onChanged();
        } else {
          pathsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder addPaths(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder builderForValue) {
        if (pathsBuilder_ == null) {
          ensurePathsIsMutable();
          paths_.add(index, builderForValue.build());
          onChanged();
        } else {
          pathsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder addAllPaths(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath>
              values) {
        if (pathsBuilder_ == null) {
          ensurePathsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, paths_);
          onChanged();
        } else {
          pathsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder clearPaths() {
        if (pathsBuilder_ == null) {
          paths_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          pathsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public Builder removePaths(int index) {
        if (pathsBuilder_ == null) {
          ensurePathsIsMutable();
          paths_.remove(index);
          onChanged();
        } else {
          pathsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder getPathsBuilder(
          int index) {
        return getPathsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder
          getPathsOrBuilder(int index) {
        if (pathsBuilder_ == null) {
          return paths_.get(index);
        } else {
          return pathsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder>
          getPathsOrBuilderList() {
        if (pathsBuilder_ != null) {
          return pathsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(paths_);
        }
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder
          addPathsBuilder() {
        return getPathsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder addPathsBuilder(
          int index) {
        return getPathsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * A collection of paths that map requests to backends.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HTTPIngressPath paths = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder>
          getPathsBuilderList() {
        return getPathsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder>
          getPathsFieldBuilder() {
        if (pathsBuilder_ == null) {
          pathsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath,
                  io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPath.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressPathOrBuilder>(
                  paths_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          paths_ = null;
        }
        return pathsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue)
    private static final io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<HTTPIngressRuleValue> PARSER =
        new com.google.protobuf.AbstractParser<HTTPIngressRuleValue>() {
          @java.lang.Override
          public HTTPIngressRuleValue parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new HTTPIngressRuleValue(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<HTTPIngressRuleValue> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HTTPIngressRuleValue> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface HostPortRangeOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.HostPortRange)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 min = 1;</code>
     */
    boolean hasMin();
    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 min = 1;</code>
     */
    int getMin();

    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 max = 2;</code>
     */
    boolean hasMax();
    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 max = 2;</code>
     */
    int getMax();
  }
  /**
   *
   *
   * <pre>
   * HostPortRange defines a range of host ports that will be enabled by a policy
   * for pods to use.  It requires both the start and end to be defined.
   * Deprecated: use HostPortRange from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.HostPortRange}
   */
  public static final class HostPortRange extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.HostPortRange)
      HostPortRangeOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use HostPortRange.newBuilder() to construct.
    private HostPortRange(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private HostPortRange() {
      min_ = 0;
      max_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private HostPortRange(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                min_ = input.readInt32();
                break;
              }
            case 16:
              {
                bitField0_ |= 0x00000002;
                max_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.class,
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder.class);
    }

    private int bitField0_;
    public static final int MIN_FIELD_NUMBER = 1;
    private int min_;
    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 min = 1;</code>
     */
    public boolean hasMin() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 min = 1;</code>
     */
    public int getMin() {
      return min_;
    }

    public static final int MAX_FIELD_NUMBER = 2;
    private int max_;
    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 max = 2;</code>
     */
    public boolean hasMax() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int32 max = 2;</code>
     */
    public int getMax() {
      return max_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, min_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, max_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, min_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, max_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.HostPortRange)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.HostPortRange other =
          (io.kubernetes.client.proto.V1beta1Extensions.HostPortRange) obj;

      boolean result = true;
      result = result && (hasMin() == other.hasMin());
      if (hasMin()) {
        result = result && (getMin() == other.getMin());
      }
      result = result && (hasMax() == other.hasMax());
      if (hasMax()) {
        result = result && (getMax() == other.getMax());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMin()) {
        hash = (37 * hash) + MIN_FIELD_NUMBER;
        hash = (53 * hash) + getMin();
      }
      if (hasMax()) {
        hash = (37 * hash) + MAX_FIELD_NUMBER;
        hash = (53 * hash) + getMax();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.HostPortRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * HostPortRange defines a range of host ports that will be enabled by a policy
     * for pods to use.  It requires both the start and end to be defined.
     * Deprecated: use HostPortRange from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.HostPortRange}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.HostPortRange)
        io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.class,
                io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        min_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        max_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange build() {
        io.kubernetes.client.proto.V1beta1Extensions.HostPortRange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.HostPortRange result =
            new io.kubernetes.client.proto.V1beta1Extensions.HostPortRange(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.min_ = min_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.max_ = max_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.HostPortRange) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.HostPortRange) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.HostPortRange other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.getDefaultInstance())
          return this;
        if (other.hasMin()) {
          setMin(other.getMin());
        }
        if (other.hasMax()) {
          setMax(other.getMax());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.HostPortRange parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.HostPortRange) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int min_;
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 min = 1;</code>
       */
      public boolean hasMin() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 min = 1;</code>
       */
      public int getMin() {
        return min_;
      }
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 min = 1;</code>
       */
      public Builder setMin(int value) {
        bitField0_ |= 0x00000001;
        min_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 min = 1;</code>
       */
      public Builder clearMin() {
        bitField0_ = (bitField0_ & ~0x00000001);
        min_ = 0;
        onChanged();
        return this;
      }

      private int max_;
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 max = 2;</code>
       */
      public boolean hasMax() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 max = 2;</code>
       */
      public int getMax() {
        return max_;
      }
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 max = 2;</code>
       */
      public Builder setMax(int value) {
        bitField0_ |= 0x00000002;
        max_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int32 max = 2;</code>
       */
      public Builder clearMax() {
        bitField0_ = (bitField0_ & ~0x00000002);
        max_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.HostPortRange)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.HostPortRange)
    private static final io.kubernetes.client.proto.V1beta1Extensions.HostPortRange
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.HostPortRange();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.HostPortRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<HostPortRange> PARSER =
        new com.google.protobuf.AbstractParser<HostPortRange>() {
          @java.lang.Override
          public HostPortRange parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new HostPortRange(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<HostPortRange> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HostPortRange> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IDRangeOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IDRange)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 min = 1;</code>
     */
    boolean hasMin();
    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 min = 1;</code>
     */
    long getMin();

    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 max = 2;</code>
     */
    boolean hasMax();
    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 max = 2;</code>
     */
    long getMax();
  }
  /**
   *
   *
   * <pre>
   * IDRange provides a min/max of an allowed range of IDs.
   * Deprecated: use IDRange from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IDRange}
   */
  public static final class IDRange extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IDRange)
      IDRangeOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IDRange.newBuilder() to construct.
    private IDRange(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IDRange() {
      min_ = 0L;
      max_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IDRange(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                min_ = input.readInt64();
                break;
              }
            case 16:
              {
                bitField0_ |= 0x00000002;
                max_ = input.readInt64();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IDRange_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IDRange_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.class,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder.class);
    }

    private int bitField0_;
    public static final int MIN_FIELD_NUMBER = 1;
    private long min_;
    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 min = 1;</code>
     */
    public boolean hasMin() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * min is the start of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 min = 1;</code>
     */
    public long getMin() {
      return min_;
    }

    public static final int MAX_FIELD_NUMBER = 2;
    private long max_;
    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 max = 2;</code>
     */
    public boolean hasMax() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * max is the end of the range, inclusive.
     * </pre>
     *
     * <code>optional int64 max = 2;</code>
     */
    public long getMax() {
      return max_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, min_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt64(2, max_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, min_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, max_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IDRange)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IDRange other =
          (io.kubernetes.client.proto.V1beta1Extensions.IDRange) obj;

      boolean result = true;
      result = result && (hasMin() == other.hasMin());
      if (hasMin()) {
        result = result && (getMin() == other.getMin());
      }
      result = result && (hasMax() == other.hasMax());
      if (hasMax()) {
        result = result && (getMax() == other.getMax());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMin()) {
        hash = (37 * hash) + MIN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getMin());
      }
      if (hasMax()) {
        hash = (37 * hash) + MAX_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getMax());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IDRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IDRange provides a min/max of an allowed range of IDs.
     * Deprecated: use IDRange from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IDRange}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IDRange)
        io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IDRange_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IDRange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IDRange.class,
                io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IDRange.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        min_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        max_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IDRange_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange build() {
        io.kubernetes.client.proto.V1beta1Extensions.IDRange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IDRange result =
            new io.kubernetes.client.proto.V1beta1Extensions.IDRange(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.min_ = min_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.max_ = max_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IDRange) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IDRange) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IDRange other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance())
          return this;
        if (other.hasMin()) {
          setMin(other.getMin());
        }
        if (other.hasMax()) {
          setMax(other.getMax());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IDRange parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IDRange) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private long min_;
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 min = 1;</code>
       */
      public boolean hasMin() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 min = 1;</code>
       */
      public long getMin() {
        return min_;
      }
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 min = 1;</code>
       */
      public Builder setMin(long value) {
        bitField0_ |= 0x00000001;
        min_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * min is the start of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 min = 1;</code>
       */
      public Builder clearMin() {
        bitField0_ = (bitField0_ & ~0x00000001);
        min_ = 0L;
        onChanged();
        return this;
      }

      private long max_;
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 max = 2;</code>
       */
      public boolean hasMax() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 max = 2;</code>
       */
      public long getMax() {
        return max_;
      }
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 max = 2;</code>
       */
      public Builder setMax(long value) {
        bitField0_ |= 0x00000002;
        max_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * max is the end of the range, inclusive.
       * </pre>
       *
       * <code>optional int64 max = 2;</code>
       */
      public Builder clearMax() {
        bitField0_ = (bitField0_ & ~0x00000002);
        max_ = 0L;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IDRange)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IDRange)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IDRange DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IDRange();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IDRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IDRange> PARSER =
        new com.google.protobuf.AbstractParser<IDRange>() {
          @java.lang.Override
          public IDRange parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IDRange(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IDRange> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IDRange> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IDRange getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IPBlockOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IPBlock)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * CIDR is a string representing the IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * </pre>
     *
     * <code>optional string cidr = 1;</code>
     */
    boolean hasCidr();
    /**
     *
     *
     * <pre>
     * CIDR is a string representing the IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * </pre>
     *
     * <code>optional string cidr = 1;</code>
     */
    java.lang.String getCidr();
    /**
     *
     *
     * <pre>
     * CIDR is a string representing the IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * </pre>
     *
     * <code>optional string cidr = 1;</code>
     */
    com.google.protobuf.ByteString getCidrBytes();

    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    java.util.List<java.lang.String> getExceptList();
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    int getExceptCount();
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    java.lang.String getExcept(int index);
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    com.google.protobuf.ByteString getExceptBytes(int index);
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
   * IPBlock describes a particular CIDR (Ex. "192.168.1.1/24","2001:db9::/64") that is allowed
   * to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs
   * that should not be included within this rule.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IPBlock}
   */
  public static final class IPBlock extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IPBlock)
      IPBlockOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IPBlock.newBuilder() to construct.
    private IPBlock(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IPBlock() {
      cidr_ = "";
      except_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IPBlock(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                cidr_ = bs;
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  except_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000002;
                }
                except_.add(bs);
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          except_ = except_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IPBlock_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IPBlock_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IPBlock.class,
              io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder.class);
    }

    private int bitField0_;
    public static final int CIDR_FIELD_NUMBER = 1;
    private volatile java.lang.Object cidr_;
    /**
     *
     *
     * <pre>
     * CIDR is a string representing the IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * </pre>
     *
     * <code>optional string cidr = 1;</code>
     */
    public boolean hasCidr() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * CIDR is a string representing the IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * </pre>
     *
     * <code>optional string cidr = 1;</code>
     */
    public java.lang.String getCidr() {
      java.lang.Object ref = cidr_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          cidr_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * CIDR is a string representing the IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * </pre>
     *
     * <code>optional string cidr = 1;</code>
     */
    public com.google.protobuf.ByteString getCidrBytes() {
      java.lang.Object ref = cidr_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        cidr_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXCEPT_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList except_;
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList getExceptList() {
      return except_;
    }
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    public int getExceptCount() {
      return except_.size();
    }
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    public java.lang.String getExcept(int index) {
      return except_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Except is a slice of CIDRs that should not be included within an IP Block
     * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     * Except values will be rejected if they are outside the CIDR range
     * +optional
     * </pre>
     *
     * <code>repeated string except = 2;</code>
     */
    public com.google.protobuf.ByteString getExceptBytes(int index) {
      return except_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, cidr_);
      }
      for (int i = 0; i < except_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, except_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, cidr_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < except_.size(); i++) {
          dataSize += computeStringSizeNoTag(except_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getExceptList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IPBlock)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IPBlock other =
          (io.kubernetes.client.proto.V1beta1Extensions.IPBlock) obj;

      boolean result = true;
      result = result && (hasCidr() == other.hasCidr());
      if (hasCidr()) {
        result = result && getCidr().equals(other.getCidr());
      }
      result = result && getExceptList().equals(other.getExceptList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCidr()) {
        hash = (37 * hash) + CIDR_FIELD_NUMBER;
        hash = (53 * hash) + getCidr().hashCode();
      }
      if (getExceptCount() > 0) {
        hash = (37 * hash) + EXCEPT_FIELD_NUMBER;
        hash = (53 * hash) + getExceptList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IPBlock prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
     * IPBlock describes a particular CIDR (Ex. "192.168.1.1/24","2001:db9::/64") that is allowed
     * to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs
     * that should not be included within this rule.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IPBlock}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IPBlock)
        io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IPBlock_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IPBlock_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IPBlock.class,
                io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IPBlock.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        cidr_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        except_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IPBlock_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IPBlock getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IPBlock build() {
        io.kubernetes.client.proto.V1beta1Extensions.IPBlock result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IPBlock buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IPBlock result =
            new io.kubernetes.client.proto.V1beta1Extensions.IPBlock(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.cidr_ = cidr_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          except_ = except_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.except_ = except_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IPBlock) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IPBlock) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IPBlock other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance())
          return this;
        if (other.hasCidr()) {
          bitField0_ |= 0x00000001;
          cidr_ = other.cidr_;
          onChanged();
        }
        if (!other.except_.isEmpty()) {
          if (except_.isEmpty()) {
            except_ = other.except_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureExceptIsMutable();
            except_.addAll(other.except_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IPBlock parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IPBlock) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object cidr_ = "";
      /**
       *
       *
       * <pre>
       * CIDR is a string representing the IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * </pre>
       *
       * <code>optional string cidr = 1;</code>
       */
      public boolean hasCidr() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * CIDR is a string representing the IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * </pre>
       *
       * <code>optional string cidr = 1;</code>
       */
      public java.lang.String getCidr() {
        java.lang.Object ref = cidr_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            cidr_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * CIDR is a string representing the IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * </pre>
       *
       * <code>optional string cidr = 1;</code>
       */
      public com.google.protobuf.ByteString getCidrBytes() {
        java.lang.Object ref = cidr_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          cidr_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * CIDR is a string representing the IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * </pre>
       *
       * <code>optional string cidr = 1;</code>
       */
      public Builder setCidr(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        cidr_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * CIDR is a string representing the IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * </pre>
       *
       * <code>optional string cidr = 1;</code>
       */
      public Builder clearCidr() {
        bitField0_ = (bitField0_ & ~0x00000001);
        cidr_ = getDefaultInstance().getCidr();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * CIDR is a string representing the IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * </pre>
       *
       * <code>optional string cidr = 1;</code>
       */
      public Builder setCidrBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        cidr_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList except_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureExceptIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          except_ = new com.google.protobuf.LazyStringArrayList(except_);
          bitField0_ |= 0x00000002;
        }
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList getExceptList() {
        return except_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public int getExceptCount() {
        return except_.size();
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public java.lang.String getExcept(int index) {
        return except_.get(index);
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public com.google.protobuf.ByteString getExceptBytes(int index) {
        return except_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public Builder setExcept(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureExceptIsMutable();
        except_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public Builder addExcept(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureExceptIsMutable();
        except_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public Builder addAllExcept(java.lang.Iterable<java.lang.String> values) {
        ensureExceptIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, except_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public Builder clearExcept() {
        except_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Except is a slice of CIDRs that should not be included within an IP Block
       * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
       * Except values will be rejected if they are outside the CIDR range
       * +optional
       * </pre>
       *
       * <code>repeated string except = 2;</code>
       */
      public Builder addExceptBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureExceptIsMutable();
        except_.add(value);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IPBlock)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IPBlock)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IPBlock DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IPBlock();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IPBlock getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IPBlock> PARSER =
        new com.google.protobuf.AbstractParser<IPBlock>() {
          @java.lang.Override
          public IPBlock parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IPBlock(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IPBlock> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IPBlock> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IPBlock getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.Ingress)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Spec is the desired state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * Spec is the desired state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressSpec getSpec();
    /**
     *
     *
     * <pre>
     * Spec is the desired state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder getSpecOrBuilder();

    /**
     *
     *
     * <pre>
     * Status is the current state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * Status is the current state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressStatus getStatus();
    /**
     *
     *
     * <pre>
     * Status is the current state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder getStatusOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * Ingress is a collection of rules that allow inbound connections to reach the
   * endpoints defined by a backend. An Ingress can be configured to give services
   * externally-reachable urls, load balance traffic, terminate SSL, offer name
   * based virtual hosting etc.
   * DEPRECATED - This group version of Ingress is deprecated by networking.k8s.io/v1beta1 Ingress. See the release notes for more information.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.Ingress}
   */
  public static final class Ingress extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.Ingress)
      IngressOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use Ingress.newBuilder() to construct.
    private Ingress(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private Ingress() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private Ingress(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = status_.toBuilder();
                }
                status_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(status_);
                  status_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_Ingress_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_Ingress_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.Ingress.class,
              io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.IngressSpec spec_;
    /**
     *
     *
     * <pre>
     * Spec is the desired state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Spec is the desired state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * Spec is the desired state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.getDefaultInstance()
          : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.IngressStatus status_;
    /**
     *
     *
     * <pre>
     * Status is the current state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Status is the current state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus getStatus() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.getDefaultInstance()
          : status_;
    }
    /**
     *
     *
     * <pre>
     * Status is the current state of the Ingress.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder
        getStatusOrBuilder() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.getDefaultInstance()
          : status_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.Ingress)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.Ingress other =
          (io.kubernetes.client.proto.V1beta1Extensions.Ingress) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.Ingress prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * Ingress is a collection of rules that allow inbound connections to reach the
     * endpoints defined by a backend. An Ingress can be configured to give services
     * externally-reachable urls, load balance traffic, terminate SSL, offer name
     * based virtual hosting etc.
     * DEPRECATED - This group version of Ingress is deprecated by networking.k8s.io/v1beta1 Ingress. See the release notes for more information.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.Ingress}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.Ingress)
        io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Ingress_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Ingress_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.Ingress.class,
                io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.Ingress.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Ingress_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.Ingress.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress build() {
        io.kubernetes.client.proto.V1beta1Extensions.Ingress result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.Ingress result =
            new io.kubernetes.client.proto.V1beta1Extensions.Ingress(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.Ingress) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.Ingress) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.Ingress other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.Ingress.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.Ingress parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.Ingress) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.IngressSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpec,
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Extensions.IngressSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Extensions.IngressSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.IngressSpec
                      .getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * Spec is the desired state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpec,
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressSpec,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.IngressStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatus,
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder>
          statusBuilder_;
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.getDefaultInstance()
              : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1beta1Extensions.IngressStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1beta1Extensions.IngressStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && status_ != null
              && status_
                  != io.kubernetes.client.proto.V1beta1Extensions.IngressStatus
                      .getDefaultInstance()) {
            status_ =
                io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.newBuilder(status_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder
          getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.getDefaultInstance()
              : status_;
        }
      }
      /**
       *
       *
       * <pre>
       * Status is the current state of the Ingress.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatus,
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder>
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressStatus,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder>(
                  getStatus(), getParentForChildren(), isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.Ingress)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.Ingress)
    private static final io.kubernetes.client.proto.V1beta1Extensions.Ingress DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.Ingress();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Ingress getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<Ingress> PARSER =
        new com.google.protobuf.AbstractParser<Ingress>() {
          @java.lang.Override
          public Ingress parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new Ingress(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<Ingress> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Ingress> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.Ingress getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressBackendOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressBackend)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Specifies the name of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional string serviceName = 1;</code>
     */
    boolean hasServiceName();
    /**
     *
     *
     * <pre>
     * Specifies the name of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional string serviceName = 1;</code>
     */
    java.lang.String getServiceName();
    /**
     *
     *
     * <pre>
     * Specifies the name of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional string serviceName = 1;</code>
     */
    com.google.protobuf.ByteString getServiceNameBytes();

    /**
     *
     *
     * <pre>
     * Specifies the port of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
     */
    boolean hasServicePort();
    /**
     *
     *
     * <pre>
     * Specifies the port of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getServicePort();
    /**
     *
     *
     * <pre>
     * Specifies the port of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getServicePortOrBuilder();

    /**
     *
     *
     * <pre>
     * Resource is an ObjectRef to another Kubernetes resource in the namespace
     * of the Ingress object. If resource is specified, serviceName and servicePort
     * must not be specified.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
     */
    boolean hasResource();
    /**
     *
     *
     * <pre>
     * Resource is an ObjectRef to another Kubernetes resource in the namespace
     * of the Ingress object. If resource is specified, serviceName and servicePort
     * must not be specified.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
     */
    io.kubernetes.client.proto.V1.TypedLocalObjectReference getResource();
    /**
     *
     *
     * <pre>
     * Resource is an ObjectRef to another Kubernetes resource in the namespace
     * of the Ingress object. If resource is specified, serviceName and servicePort
     * must not be specified.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
     */
    io.kubernetes.client.proto.V1.TypedLocalObjectReferenceOrBuilder getResourceOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * IngressBackend describes all endpoints for a given service and port.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressBackend}
   */
  public static final class IngressBackend extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressBackend)
      IngressBackendOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressBackend.newBuilder() to construct.
    private IngressBackend(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressBackend() {
      serviceName_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressBackend(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                serviceName_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = servicePort_.toBuilder();
                }
                servicePort_ =
                    input.readMessage(
                        io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(servicePort_);
                  servicePort_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1.TypedLocalObjectReference.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = resource_.toBuilder();
                }
                resource_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.TypedLocalObjectReference.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(resource_);
                  resource_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder.class);
    }

    private int bitField0_;
    public static final int SERVICENAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object serviceName_;
    /**
     *
     *
     * <pre>
     * Specifies the name of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional string serviceName = 1;</code>
     */
    public boolean hasServiceName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Specifies the name of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional string serviceName = 1;</code>
     */
    public java.lang.String getServiceName() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          serviceName_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies the name of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional string serviceName = 1;</code>
     */
    public com.google.protobuf.ByteString getServiceNameBytes() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        serviceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVICEPORT_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString servicePort_;
    /**
     *
     *
     * <pre>
     * Specifies the port of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
     */
    public boolean hasServicePort() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Specifies the port of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getServicePort() {
      return servicePort_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : servicePort_;
    }
    /**
     *
     *
     * <pre>
     * Specifies the port of the referenced service.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getServicePortOrBuilder() {
      return servicePort_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : servicePort_;
    }

    public static final int RESOURCE_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1.TypedLocalObjectReference resource_;
    /**
     *
     *
     * <pre>
     * Resource is an ObjectRef to another Kubernetes resource in the namespace
     * of the Ingress object. If resource is specified, serviceName and servicePort
     * must not be specified.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
     */
    public boolean hasResource() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Resource is an ObjectRef to another Kubernetes resource in the namespace
     * of the Ingress object. If resource is specified, serviceName and servicePort
     * must not be specified.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
     */
    public io.kubernetes.client.proto.V1.TypedLocalObjectReference getResource() {
      return resource_ == null
          ? io.kubernetes.client.proto.V1.TypedLocalObjectReference.getDefaultInstance()
          : resource_;
    }
    /**
     *
     *
     * <pre>
     * Resource is an ObjectRef to another Kubernetes resource in the namespace
     * of the Ingress object. If resource is specified, serviceName and servicePort
     * must not be specified.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
     */
    public io.kubernetes.client.proto.V1.TypedLocalObjectReferenceOrBuilder getResourceOrBuilder() {
      return resource_ == null
          ? io.kubernetes.client.proto.V1.TypedLocalObjectReference.getDefaultInstance()
          : resource_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, serviceName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getServicePort());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getResource());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, serviceName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getServicePort());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getResource());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressBackend)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressBackend other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressBackend) obj;

      boolean result = true;
      result = result && (hasServiceName() == other.hasServiceName());
      if (hasServiceName()) {
        result = result && getServiceName().equals(other.getServiceName());
      }
      result = result && (hasServicePort() == other.hasServicePort());
      if (hasServicePort()) {
        result = result && getServicePort().equals(other.getServicePort());
      }
      result = result && (hasResource() == other.hasResource());
      if (hasResource()) {
        result = result && getResource().equals(other.getResource());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasServiceName()) {
        hash = (37 * hash) + SERVICENAME_FIELD_NUMBER;
        hash = (53 * hash) + getServiceName().hashCode();
      }
      if (hasServicePort()) {
        hash = (37 * hash) + SERVICEPORT_FIELD_NUMBER;
        hash = (53 * hash) + getServicePort().hashCode();
      }
      if (hasResource()) {
        hash = (37 * hash) + RESOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getResource().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressBackend prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressBackend describes all endpoints for a given service and port.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressBackend}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressBackend)
        io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getServicePortFieldBuilder();
          getResourceFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        serviceName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (servicePortBuilder_ == null) {
          servicePort_ = null;
        } else {
          servicePortBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (resourceBuilder_ == null) {
          resource_ = null;
        } else {
          resourceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressBackend result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressBackend result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressBackend(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.serviceName_ = serviceName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (servicePortBuilder_ == null) {
          result.servicePort_ = servicePort_;
        } else {
          result.servicePort_ = servicePortBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (resourceBuilder_ == null) {
          result.resource_ = resource_;
        } else {
          result.resource_ = resourceBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressBackend) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressBackend) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IngressBackend other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance())
          return this;
        if (other.hasServiceName()) {
          bitField0_ |= 0x00000001;
          serviceName_ = other.serviceName_;
          onChanged();
        }
        if (other.hasServicePort()) {
          mergeServicePort(other.getServicePort());
        }
        if (other.hasResource()) {
          mergeResource(other.getResource());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressBackend parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressBackend)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object serviceName_ = "";
      /**
       *
       *
       * <pre>
       * Specifies the name of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional string serviceName = 1;</code>
       */
      public boolean hasServiceName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Specifies the name of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional string serviceName = 1;</code>
       */
      public java.lang.String getServiceName() {
        java.lang.Object ref = serviceName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            serviceName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Specifies the name of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional string serviceName = 1;</code>
       */
      public com.google.protobuf.ByteString getServiceNameBytes() {
        java.lang.Object ref = serviceName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          serviceName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Specifies the name of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional string serviceName = 1;</code>
       */
      public Builder setServiceName(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        serviceName_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specifies the name of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional string serviceName = 1;</code>
       */
      public Builder clearServiceName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        serviceName_ = getDefaultInstance().getServiceName();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specifies the name of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional string serviceName = 1;</code>
       */
      public Builder setServiceNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        serviceName_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString servicePort_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          servicePortBuilder_;
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public boolean hasServicePort() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getServicePort() {
        if (servicePortBuilder_ == null) {
          return servicePort_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : servicePort_;
        } else {
          return servicePortBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public Builder setServicePort(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (servicePortBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          servicePort_ = value;
          onChanged();
        } else {
          servicePortBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public Builder setServicePort(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (servicePortBuilder_ == null) {
          servicePort_ = builderForValue.build();
          onChanged();
        } else {
          servicePortBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public Builder mergeServicePort(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (servicePortBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && servicePort_ != null
              && servicePort_
                  != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            servicePort_ =
                io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(servicePort_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            servicePort_ = value;
          }
          onChanged();
        } else {
          servicePortBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public Builder clearServicePort() {
        if (servicePortBuilder_ == null) {
          servicePort_ = null;
          onChanged();
        } else {
          servicePortBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getServicePortBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getServicePortFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getServicePortOrBuilder() {
        if (servicePortBuilder_ != null) {
          return servicePortBuilder_.getMessageOrBuilder();
        } else {
          return servicePort_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : servicePort_;
        }
      }
      /**
       *
       *
       * <pre>
       * Specifies the port of the referenced service.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString servicePort = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          getServicePortFieldBuilder() {
        if (servicePortBuilder_ == null) {
          servicePortBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.IntStr.IntOrString,
                  io.kubernetes.client.proto.IntStr.IntOrString.Builder,
                  io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getServicePort(), getParentForChildren(), isClean());
          servicePort_ = null;
        }
        return servicePortBuilder_;
      }

      private io.kubernetes.client.proto.V1.TypedLocalObjectReference resource_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.TypedLocalObjectReference,
              io.kubernetes.client.proto.V1.TypedLocalObjectReference.Builder,
              io.kubernetes.client.proto.V1.TypedLocalObjectReferenceOrBuilder>
          resourceBuilder_;
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public boolean hasResource() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public io.kubernetes.client.proto.V1.TypedLocalObjectReference getResource() {
        if (resourceBuilder_ == null) {
          return resource_ == null
              ? io.kubernetes.client.proto.V1.TypedLocalObjectReference.getDefaultInstance()
              : resource_;
        } else {
          return resourceBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public Builder setResource(io.kubernetes.client.proto.V1.TypedLocalObjectReference value) {
        if (resourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          resource_ = value;
          onChanged();
        } else {
          resourceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public Builder setResource(
          io.kubernetes.client.proto.V1.TypedLocalObjectReference.Builder builderForValue) {
        if (resourceBuilder_ == null) {
          resource_ = builderForValue.build();
          onChanged();
        } else {
          resourceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public Builder mergeResource(io.kubernetes.client.proto.V1.TypedLocalObjectReference value) {
        if (resourceBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && resource_ != null
              && resource_
                  != io.kubernetes.client.proto.V1.TypedLocalObjectReference.getDefaultInstance()) {
            resource_ =
                io.kubernetes.client.proto.V1.TypedLocalObjectReference.newBuilder(resource_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            resource_ = value;
          }
          onChanged();
        } else {
          resourceBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public Builder clearResource() {
        if (resourceBuilder_ == null) {
          resource_ = null;
          onChanged();
        } else {
          resourceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public io.kubernetes.client.proto.V1.TypedLocalObjectReference.Builder getResourceBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getResourceFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      public io.kubernetes.client.proto.V1.TypedLocalObjectReferenceOrBuilder
          getResourceOrBuilder() {
        if (resourceBuilder_ != null) {
          return resourceBuilder_.getMessageOrBuilder();
        } else {
          return resource_ == null
              ? io.kubernetes.client.proto.V1.TypedLocalObjectReference.getDefaultInstance()
              : resource_;
        }
      }
      /**
       *
       *
       * <pre>
       * Resource is an ObjectRef to another Kubernetes resource in the namespace
       * of the Ingress object. If resource is specified, serviceName and servicePort
       * must not be specified.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.TypedLocalObjectReference,
              io.kubernetes.client.proto.V1.TypedLocalObjectReference.Builder,
              io.kubernetes.client.proto.V1.TypedLocalObjectReferenceOrBuilder>
          getResourceFieldBuilder() {
        if (resourceBuilder_ == null) {
          resourceBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1.TypedLocalObjectReference,
                  io.kubernetes.client.proto.V1.TypedLocalObjectReference.Builder,
                  io.kubernetes.client.proto.V1.TypedLocalObjectReferenceOrBuilder>(
                  getResource(), getParentForChildren(), isClean());
          resource_ = null;
        }
        return resourceBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressBackend)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressBackend)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressBackend
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressBackend();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressBackend> PARSER =
        new com.google.protobuf.AbstractParser<IngressBackend>() {
          @java.lang.Override
          public IngressBackend parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressBackend(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressBackend> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressBackend> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressListOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressList)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Ingress> getItemsList();
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.Ingress getItems(int index);
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    int getItemsCount();
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder>
        getItemsOrBuilderList();
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder getItemsOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * IngressList is a collection of Ingress.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressList}
   */
  public static final class IngressList extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressList)
      IngressListOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressList.newBuilder() to construct.
    private IngressList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  items_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.Ingress>();
                  mutable_bitField0_ |= 0x00000002;
                }
                items_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.Ingress.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressList.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Ingress> items_;
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Ingress> getItemsList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder>
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.Ingress getItems(int index) {
      return items_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Items is the list of Ingress.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressList other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && getItemsList().equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressList is a collection of Ingress.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressList}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressList)
        io.kubernetes.client.proto.V1beta1Extensions.IngressListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressList.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressList build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressList buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressList result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressList) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IngressList other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.IngressList.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getItemsFieldBuilder()
                      : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ListMeta,
                  io.kubernetes.client.proto.Meta.ListMeta.Builder,
                  io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Ingress> items_ =
          java.util.Collections.emptyList();

      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.Ingress>(items_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.Ingress,
              io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder>
          itemsBuilder_;

      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Ingress> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.Ingress value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Extensions.Ingress value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.Ingress value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.Ingress>
              values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder>
          getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder addItemsBuilder() {
        return getItemsFieldBuilder()
            .addBuilder(io.kubernetes.client.proto.V1beta1Extensions.Ingress.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder()
            .addBuilder(
                index, io.kubernetes.client.proto.V1beta1Extensions.Ingress.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Items is the list of Ingress.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.Ingress items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder>
          getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.Ingress,
              io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder>
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.Ingress,
                  io.kubernetes.client.proto.V1beta1Extensions.Ingress.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressList)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressList DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressList();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressList> PARSER =
        new com.google.protobuf.AbstractParser<IngressList>() {
          @java.lang.Override
          public IngressList parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressList(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressRuleOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
     * Note the following deviations from the "host" part of the
     * URI as defined in RFC 3986:
     * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
     *    the IP in the Spec of the parent Ingress.
     * 2. The `:` delimiter is not respected because ports are not allowed.
     * 	  Currently the port of an Ingress is implicitly :80 for http and
     * 	  :443 for https.
     * Both these may change in the future.
     * Incoming requests are matched against the host before the
     * IngressRuleValue. If the host is unspecified, the Ingress routes all
     * traffic based on the specified IngressRuleValue.
     * Host can be "precise" which is a domain name without the terminating dot of
     * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
     * prefixed with a single wildcard label (e.g. "*.foo.com").
     * The wildcard character '*' must appear by itself as the first DNS label and
     * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
     * Requests will be matched against the Host field in the following way:
     * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
     * 2. If Host is a wildcard, then the request matches this rule if the http host header
     * is to equal to the suffix (removing the first label) of the wildcard rule.
     * +optional
     * </pre>
     *
     * <code>optional string host = 1;</code>
     */
    boolean hasHost();
    /**
     *
     *
     * <pre>
     * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
     * Note the following deviations from the "host" part of the
     * URI as defined in RFC 3986:
     * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
     *    the IP in the Spec of the parent Ingress.
     * 2. The `:` delimiter is not respected because ports are not allowed.
     * 	  Currently the port of an Ingress is implicitly :80 for http and
     * 	  :443 for https.
     * Both these may change in the future.
     * Incoming requests are matched against the host before the
     * IngressRuleValue. If the host is unspecified, the Ingress routes all
     * traffic based on the specified IngressRuleValue.
     * Host can be "precise" which is a domain name without the terminating dot of
     * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
     * prefixed with a single wildcard label (e.g. "*.foo.com").
     * The wildcard character '*' must appear by itself as the first DNS label and
     * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
     * Requests will be matched against the Host field in the following way:
     * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
     * 2. If Host is a wildcard, then the request matches this rule if the http host header
     * is to equal to the suffix (removing the first label) of the wildcard rule.
     * +optional
     * </pre>
     *
     * <code>optional string host = 1;</code>
     */
    java.lang.String getHost();
    /**
     *
     *
     * <pre>
     * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
     * Note the following deviations from the "host" part of the
     * URI as defined in RFC 3986:
     * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
     *    the IP in the Spec of the parent Ingress.
     * 2. The `:` delimiter is not respected because ports are not allowed.
     * 	  Currently the port of an Ingress is implicitly :80 for http and
     * 	  :443 for https.
     * Both these may change in the future.
     * Incoming requests are matched against the host before the
     * IngressRuleValue. If the host is unspecified, the Ingress routes all
     * traffic based on the specified IngressRuleValue.
     * Host can be "precise" which is a domain name without the terminating dot of
     * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
     * prefixed with a single wildcard label (e.g. "*.foo.com").
     * The wildcard character '*' must appear by itself as the first DNS label and
     * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
     * Requests will be matched against the Host field in the following way:
     * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
     * 2. If Host is a wildcard, then the request matches this rule if the http host header
     * is to equal to the suffix (removing the first label) of the wildcard rule.
     * +optional
     * </pre>
     *
     * <code>optional string host = 1;</code>
     */
    com.google.protobuf.ByteString getHostBytes();

    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to route requests for this IngressRule.
     * If unspecified, the rule defaults to a http catch-all. Whether that sends
     * just traffic matching the host to the default backend or all traffic to the
     * default backend, is left to the controller fulfilling the Ingress. Http is
     * currently the only supported IngressRuleValue.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
     */
    boolean hasIngressRuleValue();
    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to route requests for this IngressRule.
     * If unspecified, the rule defaults to a http catch-all. Whether that sends
     * just traffic matching the host to the default backend or all traffic to the
     * default backend, is left to the controller fulfilling the Ingress. Http is
     * currently the only supported IngressRuleValue.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue getIngressRuleValue();
    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to route requests for this IngressRule.
     * If unspecified, the rule defaults to a http catch-all. Whether that sends
     * just traffic matching the host to the default backend or all traffic to the
     * default backend, is left to the controller fulfilling the Ingress. Http is
     * currently the only supported IngressRuleValue.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder
        getIngressRuleValueOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * IngressRule represents the rules mapping the paths under a specified host to
   * the related backend services. Incoming requests are first evaluated for a host
   * match, then routed to the backend associated with the matching IngressRuleValue.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressRule}
   */
  public static final class IngressRule extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressRule)
      IngressRuleOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressRule.newBuilder() to construct.
    private IngressRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressRule() {
      host_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressRule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                host_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = ingressRuleValue_.toBuilder();
                }
                ingressRuleValue_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(ingressRuleValue_);
                  ingressRuleValue_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressRule.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder.class);
    }

    private int bitField0_;
    public static final int HOST_FIELD_NUMBER = 1;
    private volatile java.lang.Object host_;
    /**
     *
     *
     * <pre>
     * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
     * Note the following deviations from the "host" part of the
     * URI as defined in RFC 3986:
     * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
     *    the IP in the Spec of the parent Ingress.
     * 2. The `:` delimiter is not respected because ports are not allowed.
     * 	  Currently the port of an Ingress is implicitly :80 for http and
     * 	  :443 for https.
     * Both these may change in the future.
     * Incoming requests are matched against the host before the
     * IngressRuleValue. If the host is unspecified, the Ingress routes all
     * traffic based on the specified IngressRuleValue.
     * Host can be "precise" which is a domain name without the terminating dot of
     * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
     * prefixed with a single wildcard label (e.g. "*.foo.com").
     * The wildcard character '*' must appear by itself as the first DNS label and
     * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
     * Requests will be matched against the Host field in the following way:
     * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
     * 2. If Host is a wildcard, then the request matches this rule if the http host header
     * is to equal to the suffix (removing the first label) of the wildcard rule.
     * +optional
     * </pre>
     *
     * <code>optional string host = 1;</code>
     */
    public boolean hasHost() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
     * Note the following deviations from the "host" part of the
     * URI as defined in RFC 3986:
     * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
     *    the IP in the Spec of the parent Ingress.
     * 2. The `:` delimiter is not respected because ports are not allowed.
     * 	  Currently the port of an Ingress is implicitly :80 for http and
     * 	  :443 for https.
     * Both these may change in the future.
     * Incoming requests are matched against the host before the
     * IngressRuleValue. If the host is unspecified, the Ingress routes all
     * traffic based on the specified IngressRuleValue.
     * Host can be "precise" which is a domain name without the terminating dot of
     * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
     * prefixed with a single wildcard label (e.g. "*.foo.com").
     * The wildcard character '*' must appear by itself as the first DNS label and
     * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
     * Requests will be matched against the Host field in the following way:
     * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
     * 2. If Host is a wildcard, then the request matches this rule if the http host header
     * is to equal to the suffix (removing the first label) of the wildcard rule.
     * +optional
     * </pre>
     *
     * <code>optional string host = 1;</code>
     */
    public java.lang.String getHost() {
      java.lang.Object ref = host_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          host_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
     * Note the following deviations from the "host" part of the
     * URI as defined in RFC 3986:
     * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
     *    the IP in the Spec of the parent Ingress.
     * 2. The `:` delimiter is not respected because ports are not allowed.
     * 	  Currently the port of an Ingress is implicitly :80 for http and
     * 	  :443 for https.
     * Both these may change in the future.
     * Incoming requests are matched against the host before the
     * IngressRuleValue. If the host is unspecified, the Ingress routes all
     * traffic based on the specified IngressRuleValue.
     * Host can be "precise" which is a domain name without the terminating dot of
     * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
     * prefixed with a single wildcard label (e.g. "*.foo.com").
     * The wildcard character '*' must appear by itself as the first DNS label and
     * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
     * Requests will be matched against the Host field in the following way:
     * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
     * 2. If Host is a wildcard, then the request matches this rule if the http host header
     * is to equal to the suffix (removing the first label) of the wildcard rule.
     * +optional
     * </pre>
     *
     * <code>optional string host = 1;</code>
     */
    public com.google.protobuf.ByteString getHostBytes() {
      java.lang.Object ref = host_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        host_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INGRESSRULEVALUE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue ingressRuleValue_;
    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to route requests for this IngressRule.
     * If unspecified, the rule defaults to a http catch-all. Whether that sends
     * just traffic matching the host to the default backend or all traffic to the
     * default backend, is left to the controller fulfilling the Ingress. Http is
     * currently the only supported IngressRuleValue.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
     */
    public boolean hasIngressRuleValue() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to route requests for this IngressRule.
     * If unspecified, the rule defaults to a http catch-all. Whether that sends
     * just traffic matching the host to the default backend or all traffic to the
     * default backend, is left to the controller fulfilling the Ingress. Http is
     * currently the only supported IngressRuleValue.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue getIngressRuleValue() {
      return ingressRuleValue_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.getDefaultInstance()
          : ingressRuleValue_;
    }
    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to route requests for this IngressRule.
     * If unspecified, the rule defaults to a http catch-all. Whether that sends
     * just traffic matching the host to the default backend or all traffic to the
     * default backend, is left to the controller fulfilling the Ingress. Http is
     * currently the only supported IngressRuleValue.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder
        getIngressRuleValueOrBuilder() {
      return ingressRuleValue_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.getDefaultInstance()
          : ingressRuleValue_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, host_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getIngressRuleValue());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, host_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getIngressRuleValue());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressRule)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressRule other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressRule) obj;

      boolean result = true;
      result = result && (hasHost() == other.hasHost());
      if (hasHost()) {
        result = result && getHost().equals(other.getHost());
      }
      result = result && (hasIngressRuleValue() == other.hasIngressRuleValue());
      if (hasIngressRuleValue()) {
        result = result && getIngressRuleValue().equals(other.getIngressRuleValue());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHost()) {
        hash = (37 * hash) + HOST_FIELD_NUMBER;
        hash = (53 * hash) + getHost().hashCode();
      }
      if (hasIngressRuleValue()) {
        hash = (37 * hash) + INGRESSRULEVALUE_FIELD_NUMBER;
        hash = (53 * hash) + getIngressRuleValue().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressRule represents the rules mapping the paths under a specified host to
     * the related backend services. Incoming requests are first evaluated for a host
     * match, then routed to the backend associated with the matching IngressRuleValue.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressRule}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressRule)
        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressRule.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressRule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getIngressRuleValueFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        host_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (ingressRuleValueBuilder_ == null) {
          ingressRuleValue_ = null;
        } else {
          ingressRuleValueBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressRule_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressRule.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressRule result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressRule result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressRule(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.host_ = host_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (ingressRuleValueBuilder_ == null) {
          result.ingressRuleValue_ = ingressRuleValue_;
        } else {
          result.ingressRuleValue_ = ingressRuleValueBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressRule) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressRule) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IngressRule other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.IngressRule.getDefaultInstance())
          return this;
        if (other.hasHost()) {
          bitField0_ |= 0x00000001;
          host_ = other.host_;
          onChanged();
        }
        if (other.hasIngressRuleValue()) {
          mergeIngressRuleValue(other.getIngressRuleValue());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressRule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressRule) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object host_ = "";
      /**
       *
       *
       * <pre>
       * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
       * Note the following deviations from the "host" part of the
       * URI as defined in RFC 3986:
       * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
       *    the IP in the Spec of the parent Ingress.
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * Incoming requests are matched against the host before the
       * IngressRuleValue. If the host is unspecified, the Ingress routes all
       * traffic based on the specified IngressRuleValue.
       * Host can be "precise" which is a domain name without the terminating dot of
       * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
       * prefixed with a single wildcard label (e.g. "*.foo.com").
       * The wildcard character '*' must appear by itself as the first DNS label and
       * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
       * Requests will be matched against the Host field in the following way:
       * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
       * 2. If Host is a wildcard, then the request matches this rule if the http host header
       * is to equal to the suffix (removing the first label) of the wildcard rule.
       * +optional
       * </pre>
       *
       * <code>optional string host = 1;</code>
       */
      public boolean hasHost() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
       * Note the following deviations from the "host" part of the
       * URI as defined in RFC 3986:
       * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
       *    the IP in the Spec of the parent Ingress.
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * Incoming requests are matched against the host before the
       * IngressRuleValue. If the host is unspecified, the Ingress routes all
       * traffic based on the specified IngressRuleValue.
       * Host can be "precise" which is a domain name without the terminating dot of
       * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
       * prefixed with a single wildcard label (e.g. "*.foo.com").
       * The wildcard character '*' must appear by itself as the first DNS label and
       * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
       * Requests will be matched against the Host field in the following way:
       * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
       * 2. If Host is a wildcard, then the request matches this rule if the http host header
       * is to equal to the suffix (removing the first label) of the wildcard rule.
       * +optional
       * </pre>
       *
       * <code>optional string host = 1;</code>
       */
      public java.lang.String getHost() {
        java.lang.Object ref = host_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            host_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
       * Note the following deviations from the "host" part of the
       * URI as defined in RFC 3986:
       * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
       *    the IP in the Spec of the parent Ingress.
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * Incoming requests are matched against the host before the
       * IngressRuleValue. If the host is unspecified, the Ingress routes all
       * traffic based on the specified IngressRuleValue.
       * Host can be "precise" which is a domain name without the terminating dot of
       * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
       * prefixed with a single wildcard label (e.g. "*.foo.com").
       * The wildcard character '*' must appear by itself as the first DNS label and
       * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
       * Requests will be matched against the Host field in the following way:
       * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
       * 2. If Host is a wildcard, then the request matches this rule if the http host header
       * is to equal to the suffix (removing the first label) of the wildcard rule.
       * +optional
       * </pre>
       *
       * <code>optional string host = 1;</code>
       */
      public com.google.protobuf.ByteString getHostBytes() {
        java.lang.Object ref = host_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          host_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
       * Note the following deviations from the "host" part of the
       * URI as defined in RFC 3986:
       * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
       *    the IP in the Spec of the parent Ingress.
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * Incoming requests are matched against the host before the
       * IngressRuleValue. If the host is unspecified, the Ingress routes all
       * traffic based on the specified IngressRuleValue.
       * Host can be "precise" which is a domain name without the terminating dot of
       * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
       * prefixed with a single wildcard label (e.g. "*.foo.com").
       * The wildcard character '*' must appear by itself as the first DNS label and
       * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
       * Requests will be matched against the Host field in the following way:
       * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
       * 2. If Host is a wildcard, then the request matches this rule if the http host header
       * is to equal to the suffix (removing the first label) of the wildcard rule.
       * +optional
       * </pre>
       *
       * <code>optional string host = 1;</code>
       */
      public Builder setHost(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        host_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
       * Note the following deviations from the "host" part of the
       * URI as defined in RFC 3986:
       * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
       *    the IP in the Spec of the parent Ingress.
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * Incoming requests are matched against the host before the
       * IngressRuleValue. If the host is unspecified, the Ingress routes all
       * traffic based on the specified IngressRuleValue.
       * Host can be "precise" which is a domain name without the terminating dot of
       * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
       * prefixed with a single wildcard label (e.g. "*.foo.com").
       * The wildcard character '*' must appear by itself as the first DNS label and
       * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
       * Requests will be matched against the Host field in the following way:
       * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
       * 2. If Host is a wildcard, then the request matches this rule if the http host header
       * is to equal to the suffix (removing the first label) of the wildcard rule.
       * +optional
       * </pre>
       *
       * <code>optional string host = 1;</code>
       */
      public Builder clearHost() {
        bitField0_ = (bitField0_ & ~0x00000001);
        host_ = getDefaultInstance().getHost();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
       * Note the following deviations from the "host" part of the
       * URI as defined in RFC 3986:
       * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
       *    the IP in the Spec of the parent Ingress.
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * Incoming requests are matched against the host before the
       * IngressRuleValue. If the host is unspecified, the Ingress routes all
       * traffic based on the specified IngressRuleValue.
       * Host can be "precise" which is a domain name without the terminating dot of
       * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
       * prefixed with a single wildcard label (e.g. "*.foo.com").
       * The wildcard character '*' must appear by itself as the first DNS label and
       * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
       * Requests will be matched against the Host field in the following way:
       * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
       * 2. If Host is a wildcard, then the request matches this rule if the http host header
       * is to equal to the suffix (removing the first label) of the wildcard rule.
       * +optional
       * </pre>
       *
       * <code>optional string host = 1;</code>
       */
      public Builder setHostBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        host_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue ingressRuleValue_ =
          null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder>
          ingressRuleValueBuilder_;
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public boolean hasIngressRuleValue() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue getIngressRuleValue() {
        if (ingressRuleValueBuilder_ == null) {
          return ingressRuleValue_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.getDefaultInstance()
              : ingressRuleValue_;
        } else {
          return ingressRuleValueBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public Builder setIngressRuleValue(
          io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue value) {
        if (ingressRuleValueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ingressRuleValue_ = value;
          onChanged();
        } else {
          ingressRuleValueBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public Builder setIngressRuleValue(
          io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder builderForValue) {
        if (ingressRuleValueBuilder_ == null) {
          ingressRuleValue_ = builderForValue.build();
          onChanged();
        } else {
          ingressRuleValueBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public Builder mergeIngressRuleValue(
          io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue value) {
        if (ingressRuleValueBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && ingressRuleValue_ != null
              && ingressRuleValue_
                  != io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue
                      .getDefaultInstance()) {
            ingressRuleValue_ =
                io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.newBuilder(
                        ingressRuleValue_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            ingressRuleValue_ = value;
          }
          onChanged();
        } else {
          ingressRuleValueBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public Builder clearIngressRuleValue() {
        if (ingressRuleValueBuilder_ == null) {
          ingressRuleValue_ = null;
          onChanged();
        } else {
          ingressRuleValueBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder
          getIngressRuleValueBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getIngressRuleValueFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder
          getIngressRuleValueOrBuilder() {
        if (ingressRuleValueBuilder_ != null) {
          return ingressRuleValueBuilder_.getMessageOrBuilder();
        } else {
          return ingressRuleValue_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.getDefaultInstance()
              : ingressRuleValue_;
        }
      }
      /**
       *
       *
       * <pre>
       * IngressRuleValue represents a rule to route requests for this IngressRule.
       * If unspecified, the rule defaults to a http catch-all. Whether that sends
       * just traffic matching the host to the default backend or all traffic to the
       * default backend, is left to the controller fulfilling the Ingress. Http is
       * currently the only supported IngressRuleValue.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder>
          getIngressRuleValueFieldBuilder() {
        if (ingressRuleValueBuilder_ == null) {
          ingressRuleValueBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder>(
                  getIngressRuleValue(), getParentForChildren(), isClean());
          ingressRuleValue_ = null;
        }
        return ingressRuleValueBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressRule)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressRule)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressRule DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressRule();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRule getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressRule> PARSER =
        new com.google.protobuf.AbstractParser<IngressRule>() {
          @java.lang.Override
          public IngressRule parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressRule(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressRule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressRule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressRule getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressRuleValueOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressRuleValue)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * http is a list of http selectors pointing to backends.
     * A path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'.
     * A backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
     */
    boolean hasHttp();
    /**
     *
     *
     * <pre>
     * http is a list of http selectors pointing to backends.
     * A path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'.
     * A backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue getHttp();
    /**
     *
     *
     * <pre>
     * http is a list of http selectors pointing to backends.
     * A path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'.
     * A backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder getHttpOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * IngressRuleValue represents a rule to apply against incoming requests. If the
   * rule is satisfied, the request is routed to the specified backend. Currently
   * mixing different types of rules in a single Ingress is disallowed, so exactly
   * one of the following must be set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressRuleValue}
   */
  public static final class IngressRuleValue extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressRuleValue)
      IngressRuleValueOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressRuleValue.newBuilder() to construct.
    private IngressRuleValue(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressRuleValue() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressRuleValue(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = http_.toBuilder();
                }
                http_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(http_);
                  http_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder.class);
    }

    private int bitField0_;
    public static final int HTTP_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue http_;
    /**
     *
     *
     * <pre>
     * http is a list of http selectors pointing to backends.
     * A path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'.
     * A backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
     */
    public boolean hasHttp() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * http is a list of http selectors pointing to backends.
     * A path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'.
     * A backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue getHttp() {
      return http_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.getDefaultInstance()
          : http_;
    }
    /**
     *
     *
     * <pre>
     * http is a list of http selectors pointing to backends.
     * A path is matched against the path of an incoming request. Currently it can
     * contain characters disallowed from the conventional "path" part of a URL
     * as defined by RFC 3986. Paths must begin with a '/'.
     * A backend defines the referenced service endpoint to which the traffic
     * will be forwarded to.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder
        getHttpOrBuilder() {
      return http_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.getDefaultInstance()
          : http_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getHttp());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getHttp());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue) obj;

      boolean result = true;
      result = result && (hasHttp() == other.hasHttp());
      if (hasHttp()) {
        result = result && getHttp().equals(other.getHttp());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHttp()) {
        hash = (37 * hash) + HTTP_FIELD_NUMBER;
        hash = (53 * hash) + getHttp().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressRuleValue represents a rule to apply against incoming requests. If the
     * rule is satisfied, the request is routed to the specified backend. Currently
     * mixing different types of rules in a single Ingress is disallowed, so exactly
     * one of the following must be set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressRuleValue}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressRuleValue)
        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValueOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getHttpFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (httpBuilder_ == null) {
          http_ = null;
        } else {
          httpBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (httpBuilder_ == null) {
          result.http_ = http_;
        } else {
          result.http_ = httpBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue.getDefaultInstance())
          return this;
        if (other.hasHttp()) {
          mergeHttp(other.getHttp());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue http_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder>
          httpBuilder_;
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public boolean hasHttp() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue getHttp() {
        if (httpBuilder_ == null) {
          return http_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
                  .getDefaultInstance()
              : http_;
        } else {
          return httpBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public Builder setHttp(
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue value) {
        if (httpBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          http_ = value;
          onChanged();
        } else {
          httpBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public Builder setHttp(
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder
              builderForValue) {
        if (httpBuilder_ == null) {
          http_ = builderForValue.build();
          onChanged();
        } else {
          httpBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public Builder mergeHttp(
          io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue value) {
        if (httpBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && http_ != null
              && http_
                  != io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
                      .getDefaultInstance()) {
            http_ =
                io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.newBuilder(http_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            http_ = value;
          }
          onChanged();
        } else {
          httpBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public Builder clearHttp() {
        if (httpBuilder_ == null) {
          http_ = null;
          onChanged();
        } else {
          httpBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder
          getHttpBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getHttpFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder
          getHttpOrBuilder() {
        if (httpBuilder_ != null) {
          return httpBuilder_.getMessageOrBuilder();
        } else {
          return http_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue
                  .getDefaultInstance()
              : http_;
        }
      }
      /**
       *
       *
       * <pre>
       * http is a list of http selectors pointing to backends.
       * A path is matched against the path of an incoming request. Currently it can
       * contain characters disallowed from the conventional "path" part of a URL
       * as defined by RFC 3986. Paths must begin with a '/'.
       * A backend defines the referenced service endpoint to which the traffic
       * will be forwarded to.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.HTTPIngressRuleValue http = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder>
          getHttpFieldBuilder() {
        if (httpBuilder_ == null) {
          httpBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue,
                  io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValue.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.HTTPIngressRuleValueOrBuilder>(
                  getHttp(), getParentForChildren(), isClean());
          http_ = null;
        }
        return httpBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressRuleValue)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressRuleValue)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressRuleValue> PARSER =
        new com.google.protobuf.AbstractParser<IngressRuleValue>() {
          @java.lang.Override
          public IngressRuleValue parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressRuleValue(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressRuleValue> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressRuleValue> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleValue
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressSpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * IngressClassName is the name of the IngressClass cluster resource. The
     * associated IngressClass defines which controller will implement the
     * resource. This replaces the deprecated `kubernetes.io/ingress.class`
     * annotation. For backwards compatibility, when that annotation is set, it
     * must be given precedence over this field. The controller may emit a
     * warning if the field and annotation have different values.
     * Implementations of this API should ignore Ingresses without a class
     * specified. An IngressClass resource may be marked as default, which can
     * be used to set a default value for this field. For more information,
     * refer to the IngressClass documentation.
     * +optional
     * </pre>
     *
     * <code>optional string ingressClassName = 4;</code>
     */
    boolean hasIngressClassName();
    /**
     *
     *
     * <pre>
     * IngressClassName is the name of the IngressClass cluster resource. The
     * associated IngressClass defines which controller will implement the
     * resource. This replaces the deprecated `kubernetes.io/ingress.class`
     * annotation. For backwards compatibility, when that annotation is set, it
     * must be given precedence over this field. The controller may emit a
     * warning if the field and annotation have different values.
     * Implementations of this API should ignore Ingresses without a class
     * specified. An IngressClass resource may be marked as default, which can
     * be used to set a default value for this field. For more information,
     * refer to the IngressClass documentation.
     * +optional
     * </pre>
     *
     * <code>optional string ingressClassName = 4;</code>
     */
    java.lang.String getIngressClassName();
    /**
     *
     *
     * <pre>
     * IngressClassName is the name of the IngressClass cluster resource. The
     * associated IngressClass defines which controller will implement the
     * resource. This replaces the deprecated `kubernetes.io/ingress.class`
     * annotation. For backwards compatibility, when that annotation is set, it
     * must be given precedence over this field. The controller may emit a
     * warning if the field and annotation have different values.
     * Implementations of this API should ignore Ingresses without a class
     * specified. An IngressClass resource may be marked as default, which can
     * be used to set a default value for this field. For more information,
     * refer to the IngressClass documentation.
     * +optional
     * </pre>
     *
     * <code>optional string ingressClassName = 4;</code>
     */
    com.google.protobuf.ByteString getIngressClassNameBytes();

    /**
     *
     *
     * <pre>
     * A default backend capable of servicing requests that don't match any
     * rule. At least one of 'backend' or 'rules' must be specified. This field
     * is optional to allow the loadbalancer controller or defaulting logic to
     * specify a global default.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
     */
    boolean hasBackend();
    /**
     *
     *
     * <pre>
     * A default backend capable of servicing requests that don't match any
     * rule. At least one of 'backend' or 'rules' must be specified. This field
     * is optional to allow the loadbalancer controller or defaulting logic to
     * specify a global default.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getBackend();
    /**
     *
     *
     * <pre>
     * A default backend capable of servicing requests that don't match any
     * rule. At least one of 'backend' or 'rules' must be specified. This field
     * is optional to allow the loadbalancer controller or defaulting logic to
     * specify a global default.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder getBackendOrBuilder();

    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS> getTlsList();
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressTLS getTls(int index);
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    int getTlsCount();
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder>
        getTlsOrBuilderList();
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder getTlsOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressRule> getRulesList();
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressRule getRules(int index);
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    int getRulesCount();
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder>
        getRulesOrBuilderList();
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder getRulesOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * IngressSpec describes the Ingress the user wishes to exist.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressSpec}
   */
  public static final class IngressSpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressSpec)
      IngressSpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressSpec.newBuilder() to construct.
    private IngressSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressSpec() {
      ingressClassName_ = "";
      tls_ = java.util.Collections.emptyList();
      rules_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = backend_.toBuilder();
                }
                backend_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(backend_);
                  backend_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                  tls_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.IngressTLS>();
                  mutable_bitField0_ |= 0x00000004;
                }
                tls_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.PARSER,
                        extensionRegistry));
                break;
              }
            case 26:
              {
                if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                  rules_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.IngressRule>();
                  mutable_bitField0_ |= 0x00000008;
                }
                rules_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IngressRule.PARSER,
                        extensionRegistry));
                break;
              }
            case 34:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                ingressClassName_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          tls_ = java.util.Collections.unmodifiableList(tls_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder.class);
    }

    private int bitField0_;
    public static final int INGRESSCLASSNAME_FIELD_NUMBER = 4;
    private volatile java.lang.Object ingressClassName_;
    /**
     *
     *
     * <pre>
     * IngressClassName is the name of the IngressClass cluster resource. The
     * associated IngressClass defines which controller will implement the
     * resource. This replaces the deprecated `kubernetes.io/ingress.class`
     * annotation. For backwards compatibility, when that annotation is set, it
     * must be given precedence over this field. The controller may emit a
     * warning if the field and annotation have different values.
     * Implementations of this API should ignore Ingresses without a class
     * specified. An IngressClass resource may be marked as default, which can
     * be used to set a default value for this field. For more information,
     * refer to the IngressClass documentation.
     * +optional
     * </pre>
     *
     * <code>optional string ingressClassName = 4;</code>
     */
    public boolean hasIngressClassName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * IngressClassName is the name of the IngressClass cluster resource. The
     * associated IngressClass defines which controller will implement the
     * resource. This replaces the deprecated `kubernetes.io/ingress.class`
     * annotation. For backwards compatibility, when that annotation is set, it
     * must be given precedence over this field. The controller may emit a
     * warning if the field and annotation have different values.
     * Implementations of this API should ignore Ingresses without a class
     * specified. An IngressClass resource may be marked as default, which can
     * be used to set a default value for this field. For more information,
     * refer to the IngressClass documentation.
     * +optional
     * </pre>
     *
     * <code>optional string ingressClassName = 4;</code>
     */
    public java.lang.String getIngressClassName() {
      java.lang.Object ref = ingressClassName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          ingressClassName_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * IngressClassName is the name of the IngressClass cluster resource. The
     * associated IngressClass defines which controller will implement the
     * resource. This replaces the deprecated `kubernetes.io/ingress.class`
     * annotation. For backwards compatibility, when that annotation is set, it
     * must be given precedence over this field. The controller may emit a
     * warning if the field and annotation have different values.
     * Implementations of this API should ignore Ingresses without a class
     * specified. An IngressClass resource may be marked as default, which can
     * be used to set a default value for this field. For more information,
     * refer to the IngressClass documentation.
     * +optional
     * </pre>
     *
     * <code>optional string ingressClassName = 4;</code>
     */
    public com.google.protobuf.ByteString getIngressClassNameBytes() {
      java.lang.Object ref = ingressClassName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        ingressClassName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BACKEND_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Extensions.IngressBackend backend_;
    /**
     *
     *
     * <pre>
     * A default backend capable of servicing requests that don't match any
     * rule. At least one of 'backend' or 'rules' must be specified. This field
     * is optional to allow the loadbalancer controller or defaulting logic to
     * specify a global default.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
     */
    public boolean hasBackend() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * A default backend capable of servicing requests that don't match any
     * rule. At least one of 'backend' or 'rules' must be specified. This field
     * is optional to allow the loadbalancer controller or defaulting logic to
     * specify a global default.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getBackend() {
      return backend_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
          : backend_;
    }
    /**
     *
     *
     * <pre>
     * A default backend capable of servicing requests that don't match any
     * rule. At least one of 'backend' or 'rules' must be specified. This field
     * is optional to allow the loadbalancer controller or defaulting logic to
     * specify a global default.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder
        getBackendOrBuilder() {
      return backend_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
          : backend_;
    }

    public static final int TLS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS> tls_;
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS> getTlsList() {
      return tls_;
    }
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder>
        getTlsOrBuilderList() {
      return tls_;
    }
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    public int getTlsCount() {
      return tls_.size();
    }
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS getTls(int index) {
      return tls_.get(index);
    }
    /**
     *
     *
     * <pre>
     * TLS configuration. Currently the Ingress only supports a single TLS
     * port, 443. If multiple members of this list specify different hosts, they
     * will be multiplexed on the same port according to the hostname specified
     * through the SNI TLS extension, if the ingress controller fulfilling the
     * ingress supports SNI.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder getTlsOrBuilder(
        int index) {
      return tls_.get(index);
    }

    public static final int RULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressRule> rules_;
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressRule> getRulesList() {
      return rules_;
    }
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder>
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressRule getRules(int index) {
      return rules_.get(index);
    }
    /**
     *
     *
     * <pre>
     * A list of host rules used to configure the Ingress. If unspecified, or
     * no rule matches, all traffic is sent to the default backend.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(1, getBackend());
      }
      for (int i = 0; i < tls_.size(); i++) {
        output.writeMessage(2, tls_.get(i));
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, ingressClassName_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getBackend());
      }
      for (int i = 0; i < tls_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, tls_.get(i));
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, ingressClassName_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressSpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressSpec) obj;

      boolean result = true;
      result = result && (hasIngressClassName() == other.hasIngressClassName());
      if (hasIngressClassName()) {
        result = result && getIngressClassName().equals(other.getIngressClassName());
      }
      result = result && (hasBackend() == other.hasBackend());
      if (hasBackend()) {
        result = result && getBackend().equals(other.getBackend());
      }
      result = result && getTlsList().equals(other.getTlsList());
      result = result && getRulesList().equals(other.getRulesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasIngressClassName()) {
        hash = (37 * hash) + INGRESSCLASSNAME_FIELD_NUMBER;
        hash = (53 * hash) + getIngressClassName().hashCode();
      }
      if (hasBackend()) {
        hash = (37 * hash) + BACKEND_FIELD_NUMBER;
        hash = (53 * hash) + getBackend().hashCode();
      }
      if (getTlsCount() > 0) {
        hash = (37 * hash) + TLS_FIELD_NUMBER;
        hash = (53 * hash) + getTlsList().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressSpec describes the Ingress the user wishes to exist.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressSpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressSpec)
        io.kubernetes.client.proto.V1beta1Extensions.IngressSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getBackendFieldBuilder();
          getTlsFieldBuilder();
          getRulesFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        ingressClassName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (backendBuilder_ == null) {
          backend_ = null;
        } else {
          backendBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (tlsBuilder_ == null) {
          tls_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          tlsBuilder_.clear();
        }
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressSpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.ingressClassName_ = ingressClassName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (backendBuilder_ == null) {
          result.backend_ = backend_;
        } else {
          result.backend_ = backendBuilder_.build();
        }
        if (tlsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            tls_ = java.util.Collections.unmodifiableList(tls_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.tls_ = tls_;
        } else {
          result.tls_ = tlsBuilder_.build();
        }
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressSpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IngressSpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.IngressSpec.getDefaultInstance())
          return this;
        if (other.hasIngressClassName()) {
          bitField0_ |= 0x00000001;
          ingressClassName_ = other.ingressClassName_;
          onChanged();
        }
        if (other.hasBackend()) {
          mergeBackend(other.getBackend());
        }
        if (tlsBuilder_ == null) {
          if (!other.tls_.isEmpty()) {
            if (tls_.isEmpty()) {
              tls_ = other.tls_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureTlsIsMutable();
              tls_.addAll(other.tls_);
            }
            onChanged();
          }
        } else {
          if (!other.tls_.isEmpty()) {
            if (tlsBuilder_.isEmpty()) {
              tlsBuilder_.dispose();
              tlsBuilder_ = null;
              tls_ = other.tls_;
              bitField0_ = (bitField0_ & ~0x00000004);
              tlsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getTlsFieldBuilder()
                      : null;
            } else {
              tlsBuilder_.addAllMessages(other.tls_);
            }
          }
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000008);
              rulesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getRulesFieldBuilder()
                      : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object ingressClassName_ = "";
      /**
       *
       *
       * <pre>
       * IngressClassName is the name of the IngressClass cluster resource. The
       * associated IngressClass defines which controller will implement the
       * resource. This replaces the deprecated `kubernetes.io/ingress.class`
       * annotation. For backwards compatibility, when that annotation is set, it
       * must be given precedence over this field. The controller may emit a
       * warning if the field and annotation have different values.
       * Implementations of this API should ignore Ingresses without a class
       * specified. An IngressClass resource may be marked as default, which can
       * be used to set a default value for this field. For more information,
       * refer to the IngressClass documentation.
       * +optional
       * </pre>
       *
       * <code>optional string ingressClassName = 4;</code>
       */
      public boolean hasIngressClassName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * IngressClassName is the name of the IngressClass cluster resource. The
       * associated IngressClass defines which controller will implement the
       * resource. This replaces the deprecated `kubernetes.io/ingress.class`
       * annotation. For backwards compatibility, when that annotation is set, it
       * must be given precedence over this field. The controller may emit a
       * warning if the field and annotation have different values.
       * Implementations of this API should ignore Ingresses without a class
       * specified. An IngressClass resource may be marked as default, which can
       * be used to set a default value for this field. For more information,
       * refer to the IngressClass documentation.
       * +optional
       * </pre>
       *
       * <code>optional string ingressClassName = 4;</code>
       */
      public java.lang.String getIngressClassName() {
        java.lang.Object ref = ingressClassName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            ingressClassName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * IngressClassName is the name of the IngressClass cluster resource. The
       * associated IngressClass defines which controller will implement the
       * resource. This replaces the deprecated `kubernetes.io/ingress.class`
       * annotation. For backwards compatibility, when that annotation is set, it
       * must be given precedence over this field. The controller may emit a
       * warning if the field and annotation have different values.
       * Implementations of this API should ignore Ingresses without a class
       * specified. An IngressClass resource may be marked as default, which can
       * be used to set a default value for this field. For more information,
       * refer to the IngressClass documentation.
       * +optional
       * </pre>
       *
       * <code>optional string ingressClassName = 4;</code>
       */
      public com.google.protobuf.ByteString getIngressClassNameBytes() {
        java.lang.Object ref = ingressClassName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          ingressClassName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * IngressClassName is the name of the IngressClass cluster resource. The
       * associated IngressClass defines which controller will implement the
       * resource. This replaces the deprecated `kubernetes.io/ingress.class`
       * annotation. For backwards compatibility, when that annotation is set, it
       * must be given precedence over this field. The controller may emit a
       * warning if the field and annotation have different values.
       * Implementations of this API should ignore Ingresses without a class
       * specified. An IngressClass resource may be marked as default, which can
       * be used to set a default value for this field. For more information,
       * refer to the IngressClass documentation.
       * +optional
       * </pre>
       *
       * <code>optional string ingressClassName = 4;</code>
       */
      public Builder setIngressClassName(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        ingressClassName_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * IngressClassName is the name of the IngressClass cluster resource. The
       * associated IngressClass defines which controller will implement the
       * resource. This replaces the deprecated `kubernetes.io/ingress.class`
       * annotation. For backwards compatibility, when that annotation is set, it
       * must be given precedence over this field. The controller may emit a
       * warning if the field and annotation have different values.
       * Implementations of this API should ignore Ingresses without a class
       * specified. An IngressClass resource may be marked as default, which can
       * be used to set a default value for this field. For more information,
       * refer to the IngressClass documentation.
       * +optional
       * </pre>
       *
       * <code>optional string ingressClassName = 4;</code>
       */
      public Builder clearIngressClassName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        ingressClassName_ = getDefaultInstance().getIngressClassName();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * IngressClassName is the name of the IngressClass cluster resource. The
       * associated IngressClass defines which controller will implement the
       * resource. This replaces the deprecated `kubernetes.io/ingress.class`
       * annotation. For backwards compatibility, when that annotation is set, it
       * must be given precedence over this field. The controller may emit a
       * warning if the field and annotation have different values.
       * Implementations of this API should ignore Ingresses without a class
       * specified. An IngressClass resource may be marked as default, which can
       * be used to set a default value for this field. For more information,
       * refer to the IngressClass documentation.
       * +optional
       * </pre>
       *
       * <code>optional string ingressClassName = 4;</code>
       */
      public Builder setIngressClassNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        ingressClassName_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.IngressBackend backend_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder>
          backendBuilder_;
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public boolean hasBackend() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend getBackend() {
        if (backendBuilder_ == null) {
          return backend_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
              : backend_;
        } else {
          return backendBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public Builder setBackend(io.kubernetes.client.proto.V1beta1Extensions.IngressBackend value) {
        if (backendBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          backend_ = value;
          onChanged();
        } else {
          backendBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public Builder setBackend(
          io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder builderForValue) {
        if (backendBuilder_ == null) {
          backend_ = builderForValue.build();
          onChanged();
        } else {
          backendBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public Builder mergeBackend(
          io.kubernetes.client.proto.V1beta1Extensions.IngressBackend value) {
        if (backendBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && backend_ != null
              && backend_
                  != io.kubernetes.client.proto.V1beta1Extensions.IngressBackend
                      .getDefaultInstance()) {
            backend_ =
                io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.newBuilder(backend_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            backend_ = value;
          }
          onChanged();
        } else {
          backendBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public Builder clearBackend() {
        if (backendBuilder_ == null) {
          backend_ = null;
          onChanged();
        } else {
          backendBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder
          getBackendBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getBackendFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder
          getBackendOrBuilder() {
        if (backendBuilder_ != null) {
          return backendBuilder_.getMessageOrBuilder();
        } else {
          return backend_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.getDefaultInstance()
              : backend_;
        }
      }
      /**
       *
       *
       * <pre>
       * A default backend capable of servicing requests that don't match any
       * rule. At least one of 'backend' or 'rules' must be specified. This field
       * is optional to allow the loadbalancer controller or defaulting logic to
       * specify a global default.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IngressBackend backend = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder>
          getBackendFieldBuilder() {
        if (backendBuilder_ == null) {
          backendBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressBackend,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressBackend.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressBackendOrBuilder>(
                  getBackend(), getParentForChildren(), isClean());
          backend_ = null;
        }
        return backendBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS> tls_ =
          java.util.Collections.emptyList();

      private void ensureTlsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          tls_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS>(
                  tls_);
          bitField0_ |= 0x00000004;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLS,
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder>
          tlsBuilder_;

      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS> getTlsList() {
        if (tlsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tls_);
        } else {
          return tlsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public int getTlsCount() {
        if (tlsBuilder_ == null) {
          return tls_.size();
        } else {
          return tlsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS getTls(int index) {
        if (tlsBuilder_ == null) {
          return tls_.get(index);
        } else {
          return tlsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder setTls(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IngressTLS value) {
        if (tlsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsIsMutable();
          tls_.set(index, value);
          onChanged();
        } else {
          tlsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder setTls(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder builderForValue) {
        if (tlsBuilder_ == null) {
          ensureTlsIsMutable();
          tls_.set(index, builderForValue.build());
          onChanged();
        } else {
          tlsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder addTls(io.kubernetes.client.proto.V1beta1Extensions.IngressTLS value) {
        if (tlsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsIsMutable();
          tls_.add(value);
          onChanged();
        } else {
          tlsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder addTls(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IngressTLS value) {
        if (tlsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsIsMutable();
          tls_.add(index, value);
          onChanged();
        } else {
          tlsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder addTls(
          io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder builderForValue) {
        if (tlsBuilder_ == null) {
          ensureTlsIsMutable();
          tls_.add(builderForValue.build());
          onChanged();
        } else {
          tlsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder addTls(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder builderForValue) {
        if (tlsBuilder_ == null) {
          ensureTlsIsMutable();
          tls_.add(index, builderForValue.build());
          onChanged();
        } else {
          tlsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder addAllTls(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressTLS>
              values) {
        if (tlsBuilder_ == null) {
          ensureTlsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, tls_);
          onChanged();
        } else {
          tlsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder clearTls() {
        if (tlsBuilder_ == null) {
          tls_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          tlsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public Builder removeTls(int index) {
        if (tlsBuilder_ == null) {
          ensureTlsIsMutable();
          tls_.remove(index);
          onChanged();
        } else {
          tlsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder getTlsBuilder(
          int index) {
        return getTlsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder getTlsOrBuilder(
          int index) {
        if (tlsBuilder_ == null) {
          return tls_.get(index);
        } else {
          return tlsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder>
          getTlsOrBuilderList() {
        if (tlsBuilder_ != null) {
          return tlsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tls_);
        }
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder addTlsBuilder() {
        return getTlsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder addTlsBuilder(
          int index) {
        return getTlsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * TLS configuration. Currently the Ingress only supports a single TLS
       * port, 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressTLS tls = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder>
          getTlsBuilderList() {
        return getTlsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLS,
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder>
          getTlsFieldBuilder() {
        if (tlsBuilder_ == null) {
          tlsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressTLS,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder>(
                  tls_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          tls_ = null;
        }
        return tlsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressRule> rules_ =
          java.util.Collections.emptyList();

      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          rules_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.IngressRule>(
                  rules_);
          bitField0_ |= 0x00000008;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressRule,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder>
          rulesBuilder_;

      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressRule>
          getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IngressRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder setRules(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1beta1Extensions.IngressRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IngressRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder addRules(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.IngressRule>
              values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder>
          getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder addRulesBuilder() {
        return getRulesFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.IngressRule.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.IngressRule.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * A list of host rules used to configure the Ingress. If unspecified, or
       * no rule matches, all traffic is sent to the default backend.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IngressRule rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder>
          getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IngressRule,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder>
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IngressRule,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressRule.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IngressRuleOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000008) == 0x00000008),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressSpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressSpec DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressSpec> PARSER =
        new com.google.protobuf.AbstractParser<IngressSpec>() {
          @java.lang.Override
          public IngressSpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressSpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * LoadBalancer contains the current status of the load-balancer.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
     */
    boolean hasLoadBalancer();
    /**
     *
     *
     * <pre>
     * LoadBalancer contains the current status of the load-balancer.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
     */
    io.kubernetes.client.proto.V1.LoadBalancerStatus getLoadBalancer();
    /**
     *
     *
     * <pre>
     * LoadBalancer contains the current status of the load-balancer.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
     */
    io.kubernetes.client.proto.V1.LoadBalancerStatusOrBuilder getLoadBalancerOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * IngressStatus describe the current state of the Ingress.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressStatus}
   */
  public static final class IngressStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressStatus)
      IngressStatusOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressStatus.newBuilder() to construct.
    private IngressStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressStatus() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.V1.LoadBalancerStatus.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = loadBalancer_.toBuilder();
                }
                loadBalancer_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.LoadBalancerStatus.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(loadBalancer_);
                  loadBalancer_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder.class);
    }

    private int bitField0_;
    public static final int LOADBALANCER_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1.LoadBalancerStatus loadBalancer_;
    /**
     *
     *
     * <pre>
     * LoadBalancer contains the current status of the load-balancer.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
     */
    public boolean hasLoadBalancer() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * LoadBalancer contains the current status of the load-balancer.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
     */
    public io.kubernetes.client.proto.V1.LoadBalancerStatus getLoadBalancer() {
      return loadBalancer_ == null
          ? io.kubernetes.client.proto.V1.LoadBalancerStatus.getDefaultInstance()
          : loadBalancer_;
    }
    /**
     *
     *
     * <pre>
     * LoadBalancer contains the current status of the load-balancer.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
     */
    public io.kubernetes.client.proto.V1.LoadBalancerStatusOrBuilder getLoadBalancerOrBuilder() {
      return loadBalancer_ == null
          ? io.kubernetes.client.proto.V1.LoadBalancerStatus.getDefaultInstance()
          : loadBalancer_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getLoadBalancer());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getLoadBalancer());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressStatus other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressStatus) obj;

      boolean result = true;
      result = result && (hasLoadBalancer() == other.hasLoadBalancer());
      if (hasLoadBalancer()) {
        result = result && getLoadBalancer().equals(other.getLoadBalancer());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasLoadBalancer()) {
        hash = (37 * hash) + LOADBALANCER_FIELD_NUMBER;
        hash = (53 * hash) + getLoadBalancer().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressStatus describe the current state of the Ingress.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressStatus}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressStatus)
        io.kubernetes.client.proto.V1beta1Extensions.IngressStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getLoadBalancerFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (loadBalancerBuilder_ == null) {
          loadBalancer_ = null;
        } else {
          loadBalancerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressStatus result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (loadBalancerBuilder_ == null) {
          result.loadBalancer_ = loadBalancer_;
        } else {
          result.loadBalancer_ = loadBalancerBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IngressStatus other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.IngressStatus.getDefaultInstance())
          return this;
        if (other.hasLoadBalancer()) {
          mergeLoadBalancer(other.getLoadBalancer());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.V1.LoadBalancerStatus loadBalancer_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.LoadBalancerStatus,
              io.kubernetes.client.proto.V1.LoadBalancerStatus.Builder,
              io.kubernetes.client.proto.V1.LoadBalancerStatusOrBuilder>
          loadBalancerBuilder_;
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public boolean hasLoadBalancer() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public io.kubernetes.client.proto.V1.LoadBalancerStatus getLoadBalancer() {
        if (loadBalancerBuilder_ == null) {
          return loadBalancer_ == null
              ? io.kubernetes.client.proto.V1.LoadBalancerStatus.getDefaultInstance()
              : loadBalancer_;
        } else {
          return loadBalancerBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public Builder setLoadBalancer(io.kubernetes.client.proto.V1.LoadBalancerStatus value) {
        if (loadBalancerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          loadBalancer_ = value;
          onChanged();
        } else {
          loadBalancerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public Builder setLoadBalancer(
          io.kubernetes.client.proto.V1.LoadBalancerStatus.Builder builderForValue) {
        if (loadBalancerBuilder_ == null) {
          loadBalancer_ = builderForValue.build();
          onChanged();
        } else {
          loadBalancerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public Builder mergeLoadBalancer(io.kubernetes.client.proto.V1.LoadBalancerStatus value) {
        if (loadBalancerBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && loadBalancer_ != null
              && loadBalancer_
                  != io.kubernetes.client.proto.V1.LoadBalancerStatus.getDefaultInstance()) {
            loadBalancer_ =
                io.kubernetes.client.proto.V1.LoadBalancerStatus.newBuilder(loadBalancer_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            loadBalancer_ = value;
          }
          onChanged();
        } else {
          loadBalancerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public Builder clearLoadBalancer() {
        if (loadBalancerBuilder_ == null) {
          loadBalancer_ = null;
          onChanged();
        } else {
          loadBalancerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public io.kubernetes.client.proto.V1.LoadBalancerStatus.Builder getLoadBalancerBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getLoadBalancerFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      public io.kubernetes.client.proto.V1.LoadBalancerStatusOrBuilder getLoadBalancerOrBuilder() {
        if (loadBalancerBuilder_ != null) {
          return loadBalancerBuilder_.getMessageOrBuilder();
        } else {
          return loadBalancer_ == null
              ? io.kubernetes.client.proto.V1.LoadBalancerStatus.getDefaultInstance()
              : loadBalancer_;
        }
      }
      /**
       *
       *
       * <pre>
       * LoadBalancer contains the current status of the load-balancer.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.LoadBalancerStatus,
              io.kubernetes.client.proto.V1.LoadBalancerStatus.Builder,
              io.kubernetes.client.proto.V1.LoadBalancerStatusOrBuilder>
          getLoadBalancerFieldBuilder() {
        if (loadBalancerBuilder_ == null) {
          loadBalancerBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1.LoadBalancerStatus,
                  io.kubernetes.client.proto.V1.LoadBalancerStatus.Builder,
                  io.kubernetes.client.proto.V1.LoadBalancerStatusOrBuilder>(
                  getLoadBalancer(), getParentForChildren(), isClean());
          loadBalancer_ = null;
        }
        return loadBalancerBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressStatus)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressStatus
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressStatus> PARSER =
        new com.google.protobuf.AbstractParser<IngressStatus>() {
          @java.lang.Override
          public IngressStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressStatus(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface IngressTLSOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.IngressTLS)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    java.util.List<java.lang.String> getHostsList();
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    int getHostsCount();
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    java.lang.String getHosts(int index);
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    com.google.protobuf.ByteString getHostsBytes(int index);

    /**
     *
     *
     * <pre>
     * SecretName is the name of the secret used to terminate SSL traffic on 443.
     * Field is left optional to allow SSL routing based on SNI hostname alone.
     * If the SNI host in a listener conflicts with the "Host" header field used
     * by an IngressRule, the SNI host is used for termination and value of the
     * Host header is used for routing.
     * +optional
     * </pre>
     *
     * <code>optional string secretName = 2;</code>
     */
    boolean hasSecretName();
    /**
     *
     *
     * <pre>
     * SecretName is the name of the secret used to terminate SSL traffic on 443.
     * Field is left optional to allow SSL routing based on SNI hostname alone.
     * If the SNI host in a listener conflicts with the "Host" header field used
     * by an IngressRule, the SNI host is used for termination and value of the
     * Host header is used for routing.
     * +optional
     * </pre>
     *
     * <code>optional string secretName = 2;</code>
     */
    java.lang.String getSecretName();
    /**
     *
     *
     * <pre>
     * SecretName is the name of the secret used to terminate SSL traffic on 443.
     * Field is left optional to allow SSL routing based on SNI hostname alone.
     * If the SNI host in a listener conflicts with the "Host" header field used
     * by an IngressRule, the SNI host is used for termination and value of the
     * Host header is used for routing.
     * +optional
     * </pre>
     *
     * <code>optional string secretName = 2;</code>
     */
    com.google.protobuf.ByteString getSecretNameBytes();
  }
  /**
   *
   *
   * <pre>
   * IngressTLS describes the transport layer security associated with an Ingress.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressTLS}
   */
  public static final class IngressTLS extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.IngressTLS)
      IngressTLSOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use IngressTLS.newBuilder() to construct.
    private IngressTLS(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private IngressTLS() {
      hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      secretName_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private IngressTLS(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  hosts_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000001;
                }
                hosts_.add(bs);
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                secretName_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          hosts_ = hosts_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.class,
              io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder.class);
    }

    private int bitField0_;
    public static final int HOSTS_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList hosts_;
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList getHostsList() {
      return hosts_;
    }
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    public int getHostsCount() {
      return hosts_.size();
    }
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    public java.lang.String getHosts(int index) {
      return hosts_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Hosts are a list of hosts included in the TLS certificate. The values in
     * this list must match the name/s used in the tlsSecret. Defaults to the
     * wildcard host setting for the loadbalancer controller fulfilling this
     * Ingress, if left unspecified.
     * +optional
     * </pre>
     *
     * <code>repeated string hosts = 1;</code>
     */
    public com.google.protobuf.ByteString getHostsBytes(int index) {
      return hosts_.getByteString(index);
    }

    public static final int SECRETNAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object secretName_;
    /**
     *
     *
     * <pre>
     * SecretName is the name of the secret used to terminate SSL traffic on 443.
     * Field is left optional to allow SSL routing based on SNI hostname alone.
     * If the SNI host in a listener conflicts with the "Host" header field used
     * by an IngressRule, the SNI host is used for termination and value of the
     * Host header is used for routing.
     * +optional
     * </pre>
     *
     * <code>optional string secretName = 2;</code>
     */
    public boolean hasSecretName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * SecretName is the name of the secret used to terminate SSL traffic on 443.
     * Field is left optional to allow SSL routing based on SNI hostname alone.
     * If the SNI host in a listener conflicts with the "Host" header field used
     * by an IngressRule, the SNI host is used for termination and value of the
     * Host header is used for routing.
     * +optional
     * </pre>
     *
     * <code>optional string secretName = 2;</code>
     */
    public java.lang.String getSecretName() {
      java.lang.Object ref = secretName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          secretName_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * SecretName is the name of the secret used to terminate SSL traffic on 443.
     * Field is left optional to allow SSL routing based on SNI hostname alone.
     * If the SNI host in a listener conflicts with the "Host" header field used
     * by an IngressRule, the SNI host is used for termination and value of the
     * Host header is used for routing.
     * +optional
     * </pre>
     *
     * <code>optional string secretName = 2;</code>
     */
    public com.google.protobuf.ByteString getSecretNameBytes() {
      java.lang.Object ref = secretName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        secretName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < hosts_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, hosts_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, secretName_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < hosts_.size(); i++) {
          dataSize += computeStringSizeNoTag(hosts_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getHostsList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, secretName_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressTLS)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.IngressTLS other =
          (io.kubernetes.client.proto.V1beta1Extensions.IngressTLS) obj;

      boolean result = true;
      result = result && getHostsList().equals(other.getHostsList());
      result = result && (hasSecretName() == other.hasSecretName());
      if (hasSecretName()) {
        result = result && getSecretName().equals(other.getSecretName());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getHostsCount() > 0) {
        hash = (37 * hash) + HOSTS_FIELD_NUMBER;
        hash = (53 * hash) + getHostsList().hashCode();
      }
      if (hasSecretName()) {
        hash = (37 * hash) + SECRETNAME_FIELD_NUMBER;
        hash = (53 * hash) + getSecretName().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.IngressTLS prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * IngressTLS describes the transport layer security associated with an Ingress.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.IngressTLS}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.IngressTLS)
        io.kubernetes.client.proto.V1beta1Extensions.IngressTLSOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.class,
                io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        secretName_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS build() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressTLS result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.IngressTLS result =
            new io.kubernetes.client.proto.V1beta1Extensions.IngressTLS(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          hosts_ = hosts_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.hosts_ = hosts_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        result.secretName_ = secretName_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.IngressTLS) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.IngressTLS) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.IngressTLS other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.IngressTLS.getDefaultInstance())
          return this;
        if (!other.hosts_.isEmpty()) {
          if (hosts_.isEmpty()) {
            hosts_ = other.hosts_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureHostsIsMutable();
            hosts_.addAll(other.hosts_);
          }
          onChanged();
        }
        if (other.hasSecretName()) {
          bitField0_ |= 0x00000002;
          secretName_ = other.secretName_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.IngressTLS parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.IngressTLS) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.LazyStringList hosts_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureHostsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          hosts_ = new com.google.protobuf.LazyStringArrayList(hosts_);
          bitField0_ |= 0x00000001;
        }
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList getHostsList() {
        return hosts_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public int getHostsCount() {
        return hosts_.size();
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public java.lang.String getHosts(int index) {
        return hosts_.get(index);
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public com.google.protobuf.ByteString getHostsBytes(int index) {
        return hosts_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public Builder setHosts(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHostsIsMutable();
        hosts_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public Builder addHosts(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHostsIsMutable();
        hosts_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public Builder addAllHosts(java.lang.Iterable<java.lang.String> values) {
        ensureHostsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, hosts_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public Builder clearHosts() {
        hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Hosts are a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       * +optional
       * </pre>
       *
       * <code>repeated string hosts = 1;</code>
       */
      public Builder addHostsBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHostsIsMutable();
        hosts_.add(value);
        onChanged();
        return this;
      }

      private java.lang.Object secretName_ = "";
      /**
       *
       *
       * <pre>
       * SecretName is the name of the secret used to terminate SSL traffic on 443.
       * Field is left optional to allow SSL routing based on SNI hostname alone.
       * If the SNI host in a listener conflicts with the "Host" header field used
       * by an IngressRule, the SNI host is used for termination and value of the
       * Host header is used for routing.
       * +optional
       * </pre>
       *
       * <code>optional string secretName = 2;</code>
       */
      public boolean hasSecretName() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * SecretName is the name of the secret used to terminate SSL traffic on 443.
       * Field is left optional to allow SSL routing based on SNI hostname alone.
       * If the SNI host in a listener conflicts with the "Host" header field used
       * by an IngressRule, the SNI host is used for termination and value of the
       * Host header is used for routing.
       * +optional
       * </pre>
       *
       * <code>optional string secretName = 2;</code>
       */
      public java.lang.String getSecretName() {
        java.lang.Object ref = secretName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            secretName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * SecretName is the name of the secret used to terminate SSL traffic on 443.
       * Field is left optional to allow SSL routing based on SNI hostname alone.
       * If the SNI host in a listener conflicts with the "Host" header field used
       * by an IngressRule, the SNI host is used for termination and value of the
       * Host header is used for routing.
       * +optional
       * </pre>
       *
       * <code>optional string secretName = 2;</code>
       */
      public com.google.protobuf.ByteString getSecretNameBytes() {
        java.lang.Object ref = secretName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          secretName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * SecretName is the name of the secret used to terminate SSL traffic on 443.
       * Field is left optional to allow SSL routing based on SNI hostname alone.
       * If the SNI host in a listener conflicts with the "Host" header field used
       * by an IngressRule, the SNI host is used for termination and value of the
       * Host header is used for routing.
       * +optional
       * </pre>
       *
       * <code>optional string secretName = 2;</code>
       */
      public Builder setSecretName(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        secretName_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * SecretName is the name of the secret used to terminate SSL traffic on 443.
       * Field is left optional to allow SSL routing based on SNI hostname alone.
       * If the SNI host in a listener conflicts with the "Host" header field used
       * by an IngressRule, the SNI host is used for termination and value of the
       * Host header is used for routing.
       * +optional
       * </pre>
       *
       * <code>optional string secretName = 2;</code>
       */
      public Builder clearSecretName() {
        bitField0_ = (bitField0_ & ~0x00000002);
        secretName_ = getDefaultInstance().getSecretName();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * SecretName is the name of the secret used to terminate SSL traffic on 443.
       * Field is left optional to allow SSL routing based on SNI hostname alone.
       * If the SNI host in a listener conflicts with the "Host" header field used
       * by an IngressRule, the SNI host is used for termination and value of the
       * Host header is used for routing.
       * +optional
       * </pre>
       *
       * <code>optional string secretName = 2;</code>
       */
      public Builder setSecretNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        secretName_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.IngressTLS)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.IngressTLS)
    private static final io.kubernetes.client.proto.V1beta1Extensions.IngressTLS DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.IngressTLS();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.IngressTLS getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<IngressTLS> PARSER =
        new com.google.protobuf.AbstractParser<IngressTLS>() {
          @java.lang.Override
          public IngressTLS parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new IngressTLS(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<IngressTLS> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IngressTLS> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.IngressTLS getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicyOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Specification of the desired behavior for this NetworkPolicy.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior for this NetworkPolicy.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec getSpec();
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior for this NetworkPolicy.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder getSpecOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy.
   * NetworkPolicy describes what network traffic is allowed for a set of Pods
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicy}
   */
  public static final class NetworkPolicy extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicy)
      NetworkPolicyOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicy.newBuilder() to construct.
    private NetworkPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicy() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec spec_;
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior for this NetworkPolicy.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior for this NetworkPolicy.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * Specification of the desired behavior for this NetworkPolicy.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder
        getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.getDefaultInstance()
          : spec_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy.
     * NetworkPolicy describes what network traffic is allowed for a set of Pods
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicy}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicy)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public Builder mergeSpec(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec
                      .getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder
          getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder
          getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * Specification of the desired behavior for this NetworkPolicy.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.NetworkPolicySpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicy)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicy> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicy>() {
          @java.lang.Override
          public NetworkPolicy parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicy(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicyEgressRuleOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort> getPortsList();
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort getPorts(int index);
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    int getPortsCount();
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
        getPortsOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder getPortsOrBuilder(
        int index);

    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer> getToList();
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer getTo(int index);
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    int getToCount();
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
        getToOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder getToOrBuilder(
        int index);
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by networking/v1/NetworkPolicyEgressRule.
   * NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
   * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
   * This type is beta-level in 1.8
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule}
   */
  public static final class NetworkPolicyEgressRule extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule)
      NetworkPolicyEgressRuleOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicyEgressRule.newBuilder() to construct.
    private NetworkPolicyEgressRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicyEgressRule() {
      ports_ = java.util.Collections.emptyList();
      to_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicyEgressRule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  ports_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>();
                  mutable_bitField0_ |= 0x00000001;
                }
                ports_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.PARSER,
                        extensionRegistry));
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  to_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>();
                  mutable_bitField0_ |= 0x00000002;
                }
                to_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          ports_ = java.util.Collections.unmodifiableList(ports_);
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          to_ = java.util.Collections.unmodifiableList(to_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder.class);
    }

    public static final int PORTS_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort> ports_;
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
        getPortsList() {
      return ports_;
    }
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
        getPortsOrBuilderList() {
      return ports_;
    }
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public int getPortsCount() {
      return ports_.size();
    }
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort getPorts(int index) {
      return ports_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of destination ports for outgoing traffic.
     * Each item in this list is combined using a logical OR. If this field is
     * empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows
     * traffic only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder
        getPortsOrBuilder(int index) {
      return ports_.get(index);
    }

    public static final int TO_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer> to_;
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>
        getToList() {
      return to_;
    }
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
        getToOrBuilderList() {
      return to_;
    }
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    public int getToCount() {
      return to_.size();
    }
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer getTo(int index) {
      return to_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of destinations for outgoing traffic of pods selected for this rule.
     * Items in this list are combined using a logical OR operation. If this field is
     * empty or missing, this rule matches all destinations (traffic not restricted by
     * destination). If this field is present and contains at least one item, this rule
     * allows traffic only if the traffic matches at least one item in the to list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder getToOrBuilder(
        int index) {
      return to_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < ports_.size(); i++) {
        output.writeMessage(1, ports_.get(i));
      }
      for (int i = 0; i < to_.size(); i++) {
        output.writeMessage(2, to_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < ports_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, ports_.get(i));
      }
      for (int i = 0; i < to_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, to_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule) obj;

      boolean result = true;
      result = result && getPortsList().equals(other.getPortsList());
      result = result && getToList().equals(other.getToList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getPortsCount() > 0) {
        hash = (37 * hash) + PORTS_FIELD_NUMBER;
        hash = (53 * hash) + getPortsList().hashCode();
      }
      if (getToCount() > 0) {
        hash = (37 * hash) + TO_FIELD_NUMBER;
        hash = (53 * hash) + getToList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by networking/v1/NetworkPolicyEgressRule.
     * NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
     * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
     * This type is beta-level in 1.8
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getPortsFieldBuilder();
          getToFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (portsBuilder_ == null) {
          ports_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          portsBuilder_.clear();
        }
        if (toBuilder_ == null) {
          to_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          toBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule(this);
        int from_bitField0_ = bitField0_;
        if (portsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            ports_ = java.util.Collections.unmodifiableList(ports_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.ports_ = ports_;
        } else {
          result.ports_ = portsBuilder_.build();
        }
        if (toBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            to_ = java.util.Collections.unmodifiableList(to_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.to_ = to_;
        } else {
          result.to_ = toBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
                .getDefaultInstance()) return this;
        if (portsBuilder_ == null) {
          if (!other.ports_.isEmpty()) {
            if (ports_.isEmpty()) {
              ports_ = other.ports_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensurePortsIsMutable();
              ports_.addAll(other.ports_);
            }
            onChanged();
          }
        } else {
          if (!other.ports_.isEmpty()) {
            if (portsBuilder_.isEmpty()) {
              portsBuilder_.dispose();
              portsBuilder_ = null;
              ports_ = other.ports_;
              bitField0_ = (bitField0_ & ~0x00000001);
              portsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getPortsFieldBuilder()
                      : null;
            } else {
              portsBuilder_.addAllMessages(other.ports_);
            }
          }
        }
        if (toBuilder_ == null) {
          if (!other.to_.isEmpty()) {
            if (to_.isEmpty()) {
              to_ = other.to_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureToIsMutable();
              to_.addAll(other.to_);
            }
            onChanged();
          }
        } else {
          if (!other.to_.isEmpty()) {
            if (toBuilder_.isEmpty()) {
              toBuilder_.dispose();
              toBuilder_ = null;
              to_ = other.to_;
              bitField0_ = (bitField0_ & ~0x00000002);
              toBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getToFieldBuilder()
                      : null;
            } else {
              toBuilder_.addAllMessages(other.to_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
          ports_ = java.util.Collections.emptyList();

      private void ensurePortsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          ports_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>(ports_);
          bitField0_ |= 0x00000001;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
          portsBuilder_;

      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
          getPortsList() {
        if (portsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ports_);
        } else {
          return portsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public int getPortsCount() {
        if (portsBuilder_ == null) {
          return ports_.size();
        } else {
          return portsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort getPorts(int index) {
        if (portsBuilder_ == null) {
          return ports_.get(index);
        } else {
          return portsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder setPorts(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.set(index, value);
          onChanged();
        } else {
          portsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder setPorts(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.set(index, builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.add(value);
          onChanged();
        } else {
          portsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.add(index, value);
          onChanged();
        } else {
          portsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.add(builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.add(index, builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addAllPorts(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
              values) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ports_);
          onChanged();
        } else {
          portsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder clearPorts() {
        if (portsBuilder_ == null) {
          ports_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          portsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder removePorts(int index) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.remove(index);
          onChanged();
        } else {
          portsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder getPortsBuilder(
          int index) {
        return getPortsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder
          getPortsOrBuilder(int index) {
        if (portsBuilder_ == null) {
          return ports_.get(index);
        } else {
          return portsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
          getPortsOrBuilderList() {
        if (portsBuilder_ != null) {
          return portsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ports_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder
          addPortsBuilder() {
        return getPortsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder addPortsBuilder(
          int index) {
        return getPortsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of destination ports for outgoing traffic.
       * Each item in this list is combined using a logical OR. If this field is
       * empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows
       * traffic only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder>
          getPortsBuilderList() {
        return getPortsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
          getPortsFieldBuilder() {
        if (portsBuilder_ == null) {
          portsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>(
                  ports_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          ports_ = null;
        }
        return portsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer> to_ =
          java.util.Collections.emptyList();

      private void ensureToIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          to_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>(to_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
          toBuilder_;

      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>
          getToList() {
        if (toBuilder_ == null) {
          return java.util.Collections.unmodifiableList(to_);
        } else {
          return toBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public int getToCount() {
        if (toBuilder_ == null) {
          return to_.size();
        } else {
          return toBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer getTo(int index) {
        if (toBuilder_ == null) {
          return to_.get(index);
        } else {
          return toBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder setTo(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer value) {
        if (toBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureToIsMutable();
          to_.set(index, value);
          onChanged();
        } else {
          toBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder setTo(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder builderForValue) {
        if (toBuilder_ == null) {
          ensureToIsMutable();
          to_.set(index, builderForValue.build());
          onChanged();
        } else {
          toBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder addTo(io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer value) {
        if (toBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureToIsMutable();
          to_.add(value);
          onChanged();
        } else {
          toBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder addTo(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer value) {
        if (toBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureToIsMutable();
          to_.add(index, value);
          onChanged();
        } else {
          toBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder addTo(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder builderForValue) {
        if (toBuilder_ == null) {
          ensureToIsMutable();
          to_.add(builderForValue.build());
          onChanged();
        } else {
          toBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder addTo(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder builderForValue) {
        if (toBuilder_ == null) {
          ensureToIsMutable();
          to_.add(index, builderForValue.build());
          onChanged();
        } else {
          toBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder addAllTo(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>
              values) {
        if (toBuilder_ == null) {
          ensureToIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, to_);
          onChanged();
        } else {
          toBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder clearTo() {
        if (toBuilder_ == null) {
          to_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          toBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public Builder removeTo(int index) {
        if (toBuilder_ == null) {
          ensureToIsMutable();
          to_.remove(index);
          onChanged();
        } else {
          toBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder getToBuilder(
          int index) {
        return getToFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder getToOrBuilder(
          int index) {
        if (toBuilder_ == null) {
          return to_.get(index);
        } else {
          return toBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
          getToOrBuilderList() {
        if (toBuilder_ != null) {
          return toBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(to_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder addToBuilder() {
        return getToFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder addToBuilder(
          int index) {
        return getToFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of destinations for outgoing traffic of pods selected for this rule.
       * Items in this list are combined using a logical OR operation. If this field is
       * empty or missing, this rule matches all destinations (traffic not restricted by
       * destination). If this field is present and contains at least one item, this rule
       * allows traffic only if the traffic matches at least one item in the to list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer to = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder>
          getToBuilderList() {
        return getToFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
          getToFieldBuilder() {
        if (toBuilder_ == null) {
          toBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>(
                  to_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          to_ = null;
        }
        return toBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicyEgressRule> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicyEgressRule>() {
          @java.lang.Override
          public NetworkPolicyEgressRule parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicyEgressRule(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicyEgressRule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicyEgressRule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicyIngressRuleOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort> getPortsList();
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort getPorts(int index);
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    int getPortsCount();
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
        getPortsOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder getPortsOrBuilder(
        int index);

    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer> getFromList();
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer getFrom(int index);
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    int getFromCount();
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
        getFromOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder getFromOrBuilder(
        int index);
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by networking/v1/NetworkPolicyIngressRule.
   * This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule}
   */
  public static final class NetworkPolicyIngressRule extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule)
      NetworkPolicyIngressRuleOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicyIngressRule.newBuilder() to construct.
    private NetworkPolicyIngressRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicyIngressRule() {
      ports_ = java.util.Collections.emptyList();
      from_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicyIngressRule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  ports_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>();
                  mutable_bitField0_ |= 0x00000001;
                }
                ports_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.PARSER,
                        extensionRegistry));
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  from_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>();
                  mutable_bitField0_ |= 0x00000002;
                }
                from_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          ports_ = java.util.Collections.unmodifiableList(ports_);
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          from_ = java.util.Collections.unmodifiableList(from_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder.class);
    }

    public static final int PORTS_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort> ports_;
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
        getPortsList() {
      return ports_;
    }
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
        getPortsOrBuilderList() {
      return ports_;
    }
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public int getPortsCount() {
      return ports_.size();
    }
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort getPorts(int index) {
      return ports_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of ports which should be made accessible on the pods selected for this rule.
     * Each item in this list is combined using a logical OR.
     * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
     * If this field is present and contains at least one item, then this rule allows traffic
     * only if the traffic matches at least one port in the list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder
        getPortsOrBuilder(int index) {
      return ports_.get(index);
    }

    public static final int FROM_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer> from_;
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>
        getFromList() {
      return from_;
    }
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
        getFromOrBuilderList() {
      return from_;
    }
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    public int getFromCount() {
      return from_.size();
    }
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer getFrom(int index) {
      return from_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of sources which should be able to access the pods selected for this rule.
     * Items in this list are combined using a logical OR operation.
     * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
     * If this field is present and contains at least one item, this rule allows traffic only if the
     * traffic matches at least one item in the from list.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder getFromOrBuilder(
        int index) {
      return from_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < ports_.size(); i++) {
        output.writeMessage(1, ports_.get(i));
      }
      for (int i = 0; i < from_.size(); i++) {
        output.writeMessage(2, from_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < ports_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, ports_.get(i));
      }
      for (int i = 0; i < from_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, from_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule) obj;

      boolean result = true;
      result = result && getPortsList().equals(other.getPortsList());
      result = result && getFromList().equals(other.getFromList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getPortsCount() > 0) {
        hash = (37 * hash) + PORTS_FIELD_NUMBER;
        hash = (53 * hash) + getPortsList().hashCode();
      }
      if (getFromCount() > 0) {
        hash = (37 * hash) + FROM_FIELD_NUMBER;
        hash = (53 * hash) + getFromList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by networking/v1/NetworkPolicyIngressRule.
     * This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
                    .class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getPortsFieldBuilder();
          getFromFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (portsBuilder_ == null) {
          ports_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          portsBuilder_.clear();
        }
        if (fromBuilder_ == null) {
          from_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          fromBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule(this);
        int from_bitField0_ = bitField0_;
        if (portsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            ports_ = java.util.Collections.unmodifiableList(ports_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.ports_ = ports_;
        } else {
          result.ports_ = portsBuilder_.build();
        }
        if (fromBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            from_ = java.util.Collections.unmodifiableList(from_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.from_ = from_;
        } else {
          result.from_ = fromBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other
            instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
                .getDefaultInstance()) return this;
        if (portsBuilder_ == null) {
          if (!other.ports_.isEmpty()) {
            if (ports_.isEmpty()) {
              ports_ = other.ports_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensurePortsIsMutable();
              ports_.addAll(other.ports_);
            }
            onChanged();
          }
        } else {
          if (!other.ports_.isEmpty()) {
            if (portsBuilder_.isEmpty()) {
              portsBuilder_.dispose();
              portsBuilder_ = null;
              ports_ = other.ports_;
              bitField0_ = (bitField0_ & ~0x00000001);
              portsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getPortsFieldBuilder()
                      : null;
            } else {
              portsBuilder_.addAllMessages(other.ports_);
            }
          }
        }
        if (fromBuilder_ == null) {
          if (!other.from_.isEmpty()) {
            if (from_.isEmpty()) {
              from_ = other.from_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureFromIsMutable();
              from_.addAll(other.from_);
            }
            onChanged();
          }
        } else {
          if (!other.from_.isEmpty()) {
            if (fromBuilder_.isEmpty()) {
              fromBuilder_.dispose();
              fromBuilder_ = null;
              from_ = other.from_;
              bitField0_ = (bitField0_ & ~0x00000002);
              fromBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getFromFieldBuilder()
                      : null;
            } else {
              fromBuilder_.addAllMessages(other.from_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
          ports_ = java.util.Collections.emptyList();

      private void ensurePortsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          ports_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>(ports_);
          bitField0_ |= 0x00000001;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
          portsBuilder_;

      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
          getPortsList() {
        if (portsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ports_);
        } else {
          return portsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public int getPortsCount() {
        if (portsBuilder_ == null) {
          return ports_.size();
        } else {
          return portsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort getPorts(int index) {
        if (portsBuilder_ == null) {
          return ports_.get(index);
        } else {
          return portsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder setPorts(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.set(index, value);
          onChanged();
        } else {
          portsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder setPorts(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.set(index, builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.add(value);
          onChanged();
        } else {
          portsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort value) {
        if (portsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePortsIsMutable();
          ports_.add(index, value);
          onChanged();
        } else {
          portsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.add(builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addPorts(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder builderForValue) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.add(index, builderForValue.build());
          onChanged();
        } else {
          portsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder addAllPorts(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort>
              values) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ports_);
          onChanged();
        } else {
          portsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder clearPorts() {
        if (portsBuilder_ == null) {
          ports_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          portsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public Builder removePorts(int index) {
        if (portsBuilder_ == null) {
          ensurePortsIsMutable();
          ports_.remove(index);
          onChanged();
        } else {
          portsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder getPortsBuilder(
          int index) {
        return getPortsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder
          getPortsOrBuilder(int index) {
        if (portsBuilder_ == null) {
          return ports_.get(index);
        } else {
          return portsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
          getPortsOrBuilderList() {
        if (portsBuilder_ != null) {
          return portsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ports_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder
          addPortsBuilder() {
        return getPortsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder addPortsBuilder(
          int index) {
        return getPortsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of ports which should be made accessible on the pods selected for this rule.
       * Each item in this list is combined using a logical OR.
       * If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
       * If this field is present and contains at least one item, then this rule allows traffic
       * only if the traffic matches at least one port in the list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPort ports = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder>
          getPortsBuilderList() {
        return getPortsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>
          getPortsFieldBuilder() {
        if (portsBuilder_ == null) {
          portsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder>(
                  ports_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          ports_ = null;
        }
        return portsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer> from_ =
          java.util.Collections.emptyList();

      private void ensureFromIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          from_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>(from_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
          fromBuilder_;

      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>
          getFromList() {
        if (fromBuilder_ == null) {
          return java.util.Collections.unmodifiableList(from_);
        } else {
          return fromBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public int getFromCount() {
        if (fromBuilder_ == null) {
          return from_.size();
        } else {
          return fromBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer getFrom(int index) {
        if (fromBuilder_ == null) {
          return from_.get(index);
        } else {
          return fromBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder setFrom(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer value) {
        if (fromBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFromIsMutable();
          from_.set(index, value);
          onChanged();
        } else {
          fromBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder setFrom(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder builderForValue) {
        if (fromBuilder_ == null) {
          ensureFromIsMutable();
          from_.set(index, builderForValue.build());
          onChanged();
        } else {
          fromBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder addFrom(io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer value) {
        if (fromBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFromIsMutable();
          from_.add(value);
          onChanged();
        } else {
          fromBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder addFrom(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer value) {
        if (fromBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFromIsMutable();
          from_.add(index, value);
          onChanged();
        } else {
          fromBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder addFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder builderForValue) {
        if (fromBuilder_ == null) {
          ensureFromIsMutable();
          from_.add(builderForValue.build());
          onChanged();
        } else {
          fromBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder addFrom(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder builderForValue) {
        if (fromBuilder_ == null) {
          ensureFromIsMutable();
          from_.add(index, builderForValue.build());
          onChanged();
        } else {
          fromBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder addAllFrom(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer>
              values) {
        if (fromBuilder_ == null) {
          ensureFromIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, from_);
          onChanged();
        } else {
          fromBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder clearFrom() {
        if (fromBuilder_ == null) {
          from_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          fromBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public Builder removeFrom(int index) {
        if (fromBuilder_ == null) {
          ensureFromIsMutable();
          from_.remove(index);
          onChanged();
        } else {
          fromBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder getFromBuilder(
          int index) {
        return getFromFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder
          getFromOrBuilder(int index) {
        if (fromBuilder_ == null) {
          return from_.get(index);
        } else {
          return fromBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
          getFromOrBuilderList() {
        if (fromBuilder_ != null) {
          return fromBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(from_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder
          addFromBuilder() {
        return getFromFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder addFromBuilder(
          int index) {
        return getFromFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of sources which should be able to access the pods selected for this rule.
       * Items in this list are combined using a logical OR operation.
       * If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
       * If this field is present and contains at least one item, this rule allows traffic only if the
       * traffic matches at least one item in the from list.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyPeer from = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder>
          getFromBuilderList() {
        return getFromFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>
          getFromFieldBuilder() {
        if (fromBuilder_ == null) {
          fromBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder>(
                  from_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          from_ = null;
        }
        return fromBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE =
          new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicyIngressRule> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicyIngressRule>() {
          @java.lang.Override
          public NetworkPolicyIngressRule parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicyIngressRule(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicyIngressRule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicyIngressRule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicyListOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicyList)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy> getItemsList();
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy getItems(int index);
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    int getItemsCount();
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder>
        getItemsOrBuilderList();
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by networking/v1/NetworkPolicyList.
   * Network Policy List is a list of NetworkPolicy objects.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyList}
   */
  public static final class NetworkPolicyList extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyList)
      NetworkPolicyListOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicyList.newBuilder() to construct.
    private NetworkPolicyList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicyList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicyList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  items_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy>();
                  mutable_bitField0_ |= 0x00000002;
                }
                items_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy> items_;
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy>
        getItemsList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder>
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy getItems(int index) {
      return items_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && getItemsList().equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by networking/v1/NetworkPolicyList.
     * Network Policy List is a list of NetworkPolicy objects.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyList}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyList)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getItemsFieldBuilder()
                      : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ListMeta,
                  io.kubernetes.client.proto.Meta.ListMeta.Builder,
                  io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy> items_ =
          java.util.Collections.emptyList();

      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy>(
                  items_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder>
          itemsBuilder_;

      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy>
          getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder setItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder addItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy>
              values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder>
          getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder addItemsBuilder() {
        return getItemsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder>
          getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder>
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicy.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyList)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicyList> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicyList>() {
          @java.lang.Override
          public NetworkPolicyList parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicyList(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicyList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicyList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyList
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicyPeerOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicyPeer)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * This is a label selector which selects Pods. This field follows standard label
     * selector semantics; if present but empty, it selects all pods.
     * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    boolean hasPodSelector();
    /**
     *
     *
     * <pre>
     * This is a label selector which selects Pods. This field follows standard label
     * selector semantics; if present but empty, it selects all pods.
     * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getPodSelector();
    /**
     *
     *
     * <pre>
     * This is a label selector which selects Pods. This field follows standard label
     * selector semantics; if present but empty, it selects all pods.
     * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getPodSelectorOrBuilder();

    /**
     *
     *
     * <pre>
     * Selects Namespaces using cluster-scoped labels. This field follows standard label
     * selector semantics; if present but empty, it selects all namespaces.
     * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
     * </code>
     */
    boolean hasNamespaceSelector();
    /**
     *
     *
     * <pre>
     * Selects Namespaces using cluster-scoped labels. This field follows standard label
     * selector semantics; if present but empty, it selects all namespaces.
     * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
     * </code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     *
     *
     * <pre>
     * Selects Namespaces using cluster-scoped labels. This field follows standard label
     * selector semantics; if present but empty, it selects all namespaces.
     * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
     * </code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     *
     *
     * <pre>
     * IPBlock defines policy on a particular IPBlock. If this field is set then
     * neither of the other fields can be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
     */
    boolean hasIpBlock();
    /**
     *
     *
     * <pre>
     * IPBlock defines policy on a particular IPBlock. If this field is set then
     * neither of the other fields can be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IPBlock getIpBlock();
    /**
     *
     *
     * <pre>
     * IPBlock defines policy on a particular IPBlock. If this field is set then
     * neither of the other fields can be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder getIpBlockOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by networking/v1/NetworkPolicyPeer.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyPeer}
   */
  public static final class NetworkPolicyPeer extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyPeer)
      NetworkPolicyPeerOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicyPeer.newBuilder() to construct.
    private NetworkPolicyPeer(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicyPeer() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicyPeer(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = podSelector_.toBuilder();
                }
                podSelector_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(podSelector_);
                  podSelector_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = namespaceSelector_.toBuilder();
                }
                namespaceSelector_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(namespaceSelector_);
                  namespaceSelector_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = ipBlock_.toBuilder();
                }
                ipBlock_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IPBlock.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(ipBlock_);
                  ipBlock_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder.class);
    }

    private int bitField0_;
    public static final int PODSELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector podSelector_;
    /**
     *
     *
     * <pre>
     * This is a label selector which selects Pods. This field follows standard label
     * selector semantics; if present but empty, it selects all pods.
     * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    public boolean hasPodSelector() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * This is a label selector which selects Pods. This field follows standard label
     * selector semantics; if present but empty, it selects all pods.
     * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getPodSelector() {
      return podSelector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : podSelector_;
    }
    /**
     *
     *
     * <pre>
     * This is a label selector which selects Pods. This field follows standard label
     * selector semantics; if present but empty, it selects all pods.
     * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getPodSelectorOrBuilder() {
      return podSelector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : podSelector_;
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     *
     *
     * <pre>
     * Selects Namespaces using cluster-scoped labels. This field follows standard label
     * selector semantics; if present but empty, it selects all namespaces.
     * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
     * </code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Selects Namespaces using cluster-scoped labels. This field follows standard label
     * selector semantics; if present but empty, it selects all namespaces.
     * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
     * </code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : namespaceSelector_;
    }
    /**
     *
     *
     * <pre>
     * Selects Namespaces using cluster-scoped labels. This field follows standard label
     * selector semantics; if present but empty, it selects all namespaces.
     * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
     * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
     * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
     * </code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : namespaceSelector_;
    }

    public static final int IPBLOCK_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.IPBlock ipBlock_;
    /**
     *
     *
     * <pre>
     * IPBlock defines policy on a particular IPBlock. If this field is set then
     * neither of the other fields can be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
     */
    public boolean hasIpBlock() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * IPBlock defines policy on a particular IPBlock. If this field is set then
     * neither of the other fields can be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IPBlock getIpBlock() {
      return ipBlock_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance()
          : ipBlock_;
    }
    /**
     *
     *
     * <pre>
     * IPBlock defines policy on a particular IPBlock. If this field is set then
     * neither of the other fields can be.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder getIpBlockOrBuilder() {
      return ipBlock_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance()
          : ipBlock_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getPodSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getIpBlock());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getPodSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getIpBlock());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer) obj;

      boolean result = true;
      result = result && (hasPodSelector() == other.hasPodSelector());
      if (hasPodSelector()) {
        result = result && getPodSelector().equals(other.getPodSelector());
      }
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector().equals(other.getNamespaceSelector());
      }
      result = result && (hasIpBlock() == other.hasIpBlock());
      if (hasIpBlock()) {
        result = result && getIpBlock().equals(other.getIpBlock());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPodSelector()) {
        hash = (37 * hash) + PODSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getPodSelector().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasIpBlock()) {
        hash = (37 * hash) + IPBLOCK_FIELD_NUMBER;
        hash = (53 * hash) + getIpBlock().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by networking/v1/NetworkPolicyPeer.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyPeer}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyPeer)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeerOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getPodSelectorFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getIpBlockFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (podSelectorBuilder_ == null) {
          podSelector_ = null;
        } else {
          podSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (ipBlockBuilder_ == null) {
          ipBlock_ = null;
        } else {
          ipBlockBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (podSelectorBuilder_ == null) {
          result.podSelector_ = podSelector_;
        } else {
          result.podSelector_ = podSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (ipBlockBuilder_ == null) {
          result.ipBlock_ = ipBlock_;
        } else {
          result.ipBlock_ = ipBlockBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer.getDefaultInstance())
          return this;
        if (other.hasPodSelector()) {
          mergePodSelector(other.getPodSelector());
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasIpBlock()) {
          mergeIpBlock(other.getIpBlock());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector podSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          podSelectorBuilder_;
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public boolean hasPodSelector() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getPodSelector() {
        if (podSelectorBuilder_ == null) {
          return podSelector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : podSelector_;
        } else {
          return podSelectorBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder setPodSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (podSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          podSelector_ = value;
          onChanged();
        } else {
          podSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder setPodSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (podSelectorBuilder_ == null) {
          podSelector_ = builderForValue.build();
          onChanged();
        } else {
          podSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder mergePodSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (podSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && podSelector_ != null
              && podSelector_
                  != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            podSelector_ =
                io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(podSelector_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            podSelector_ = value;
          }
          onChanged();
        } else {
          podSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder clearPodSelector() {
        if (podSelectorBuilder_ == null) {
          podSelector_ = null;
          onChanged();
        } else {
          podSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getPodSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getPodSelectorFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getPodSelectorOrBuilder() {
        if (podSelectorBuilder_ != null) {
          return podSelectorBuilder_.getMessageOrBuilder();
        } else {
          return podSelector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : podSelector_;
        }
      }
      /**
       *
       *
       * <pre>
       * This is a label selector which selects Pods. This field follows standard label
       * selector semantics; if present but empty, it selects all pods.
       * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          getPodSelectorFieldBuilder() {
        if (podSelectorBuilder_ == null) {
          podSelectorBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.LabelSelector,
                  io.kubernetes.client.proto.Meta.LabelSelector.Builder,
                  io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getPodSelector(), getParentForChildren(), isClean());
          podSelector_ = null;
        }
        return podSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          namespaceSelectorBuilder_;
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && namespaceSelector_ != null
              && namespaceSelector_
                  != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
                io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder
          getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : namespaceSelector_;
        }
      }
      /**
       *
       *
       * <pre>
       * Selects Namespaces using cluster-scoped labels. This field follows standard label
       * selector semantics; if present but empty, it selects all namespaces.
       * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
       * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
       * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.LabelSelector,
                  io.kubernetes.client.proto.Meta.LabelSelector.Builder,
                  io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(), getParentForChildren(), isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.IPBlock ipBlock_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IPBlock,
              io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder>
          ipBlockBuilder_;
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public boolean hasIpBlock() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IPBlock getIpBlock() {
        if (ipBlockBuilder_ == null) {
          return ipBlock_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance()
              : ipBlock_;
        } else {
          return ipBlockBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public Builder setIpBlock(io.kubernetes.client.proto.V1beta1Extensions.IPBlock value) {
        if (ipBlockBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ipBlock_ = value;
          onChanged();
        } else {
          ipBlockBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public Builder setIpBlock(
          io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder builderForValue) {
        if (ipBlockBuilder_ == null) {
          ipBlock_ = builderForValue.build();
          onChanged();
        } else {
          ipBlockBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public Builder mergeIpBlock(io.kubernetes.client.proto.V1beta1Extensions.IPBlock value) {
        if (ipBlockBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && ipBlock_ != null
              && ipBlock_
                  != io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance()) {
            ipBlock_ =
                io.kubernetes.client.proto.V1beta1Extensions.IPBlock.newBuilder(ipBlock_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            ipBlock_ = value;
          }
          onChanged();
        } else {
          ipBlockBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public Builder clearIpBlock() {
        if (ipBlockBuilder_ == null) {
          ipBlock_ = null;
          onChanged();
        } else {
          ipBlockBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder getIpBlockBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getIpBlockFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder getIpBlockOrBuilder() {
        if (ipBlockBuilder_ != null) {
          return ipBlockBuilder_.getMessageOrBuilder();
        } else {
          return ipBlock_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.IPBlock.getDefaultInstance()
              : ipBlock_;
        }
      }
      /**
       *
       *
       * <pre>
       * IPBlock defines policy on a particular IPBlock. If this field is set then
       * neither of the other fields can be.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.IPBlock ipBlock = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IPBlock,
              io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder>
          getIpBlockFieldBuilder() {
        if (ipBlockBuilder_ == null) {
          ipBlockBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IPBlock,
                  io.kubernetes.client.proto.V1beta1Extensions.IPBlock.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IPBlockOrBuilder>(
                  getIpBlock(), getParentForChildren(), isClean());
          ipBlock_ = null;
        }
        return ipBlockBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyPeer)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyPeer)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicyPeer> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicyPeer>() {
          @java.lang.Override
          public NetworkPolicyPeer parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicyPeer(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicyPeer> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicyPeer> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPeer
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicyPortOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicyPort)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     * +optional
     * </pre>
     *
     * <code>optional string protocol = 1;</code>
     */
    boolean hasProtocol();
    /**
     *
     *
     * <pre>
     * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     * +optional
     * </pre>
     *
     * <code>optional string protocol = 1;</code>
     */
    java.lang.String getProtocol();
    /**
     *
     *
     * <pre>
     * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     * +optional
     * </pre>
     *
     * <code>optional string protocol = 1;</code>
     */
    com.google.protobuf.ByteString getProtocolBytes();

    /**
     *
     *
     * <pre>
     * The port on the given protocol. This can either be a numerical or named
     * port on a pod. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
     */
    boolean hasPort();
    /**
     *
     *
     * <pre>
     * The port on the given protocol. This can either be a numerical or named
     * port on a pod. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getPort();
    /**
     *
     *
     * <pre>
     * The port on the given protocol. This can either be a numerical or named
     * port on a pod. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getPortOrBuilder();

    /**
     *
     *
     * <pre>
     * If set, indicates that the range of ports from port to endPort, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     * This feature is in Beta state and is enabled by default.
     * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
     * +optional
     * </pre>
     *
     * <code>optional int32 endPort = 3;</code>
     */
    boolean hasEndPort();
    /**
     *
     *
     * <pre>
     * If set, indicates that the range of ports from port to endPort, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     * This feature is in Beta state and is enabled by default.
     * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
     * +optional
     * </pre>
     *
     * <code>optional int32 endPort = 3;</code>
     */
    int getEndPort();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by networking/v1/NetworkPolicyPort.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyPort}
   */
  public static final class NetworkPolicyPort extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyPort)
      NetworkPolicyPortOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicyPort.newBuilder() to construct.
    private NetworkPolicyPort(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicyPort() {
      protocol_ = "";
      endPort_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicyPort(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                protocol_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = port_.toBuilder();
                }
                port_ =
                    input.readMessage(
                        io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(port_);
                  port_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 24:
              {
                bitField0_ |= 0x00000004;
                endPort_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder.class);
    }

    private int bitField0_;
    public static final int PROTOCOL_FIELD_NUMBER = 1;
    private volatile java.lang.Object protocol_;
    /**
     *
     *
     * <pre>
     * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     * +optional
     * </pre>
     *
     * <code>optional string protocol = 1;</code>
     */
    public boolean hasProtocol() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     * +optional
     * </pre>
     *
     * <code>optional string protocol = 1;</code>
     */
    public java.lang.String getProtocol() {
      java.lang.Object ref = protocol_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          protocol_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
     * If not specified, this field defaults to TCP.
     * +optional
     * </pre>
     *
     * <code>optional string protocol = 1;</code>
     */
    public com.google.protobuf.ByteString getProtocolBytes() {
      java.lang.Object ref = protocol_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        protocol_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PORT_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString port_;
    /**
     *
     *
     * <pre>
     * The port on the given protocol. This can either be a numerical or named
     * port on a pod. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
     */
    public boolean hasPort() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The port on the given protocol. This can either be a numerical or named
     * port on a pod. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getPort() {
      return port_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : port_;
    }
    /**
     *
     *
     * <pre>
     * The port on the given protocol. This can either be a numerical or named
     * port on a pod. If this field is not provided, this matches all port names and
     * numbers.
     * If present, only traffic on the specified protocol AND port will be matched.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getPortOrBuilder() {
      return port_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : port_;
    }

    public static final int ENDPORT_FIELD_NUMBER = 3;
    private int endPort_;
    /**
     *
     *
     * <pre>
     * If set, indicates that the range of ports from port to endPort, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     * This feature is in Beta state and is enabled by default.
     * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
     * +optional
     * </pre>
     *
     * <code>optional int32 endPort = 3;</code>
     */
    public boolean hasEndPort() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * If set, indicates that the range of ports from port to endPort, inclusive,
     * should be allowed by the policy. This field cannot be defined if the port field
     * is not defined or if the port field is defined as a named (string) port.
     * The endPort must be equal or greater than port.
     * This feature is in Beta state and is enabled by default.
     * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
     * +optional
     * </pre>
     *
     * <code>optional int32 endPort = 3;</code>
     */
    public int getEndPort() {
      return endPort_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, protocol_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getPort());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, endPort_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, protocol_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getPort());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(3, endPort_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort) obj;

      boolean result = true;
      result = result && (hasProtocol() == other.hasProtocol());
      if (hasProtocol()) {
        result = result && getProtocol().equals(other.getProtocol());
      }
      result = result && (hasPort() == other.hasPort());
      if (hasPort()) {
        result = result && getPort().equals(other.getPort());
      }
      result = result && (hasEndPort() == other.hasEndPort());
      if (hasEndPort()) {
        result = result && (getEndPort() == other.getEndPort());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasProtocol()) {
        hash = (37 * hash) + PROTOCOL_FIELD_NUMBER;
        hash = (53 * hash) + getProtocol().hashCode();
      }
      if (hasPort()) {
        hash = (37 * hash) + PORT_FIELD_NUMBER;
        hash = (53 * hash) + getPort().hashCode();
      }
      if (hasEndPort()) {
        hash = (37 * hash) + ENDPORT_FIELD_NUMBER;
        hash = (53 * hash) + getEndPort();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by networking/v1/NetworkPolicyPort.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicyPort}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicyPort)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPortOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getPortFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        protocol_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (portBuilder_ == null) {
          port_ = null;
        } else {
          portBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        endPort_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.protocol_ = protocol_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (portBuilder_ == null) {
          result.port_ = port_;
        } else {
          result.port_ = portBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.endPort_ = endPort_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort.getDefaultInstance())
          return this;
        if (other.hasProtocol()) {
          bitField0_ |= 0x00000001;
          protocol_ = other.protocol_;
          onChanged();
        }
        if (other.hasPort()) {
          mergePort(other.getPort());
        }
        if (other.hasEndPort()) {
          setEndPort(other.getEndPort());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object protocol_ = "";
      /**
       *
       *
       * <pre>
       * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
       * If not specified, this field defaults to TCP.
       * +optional
       * </pre>
       *
       * <code>optional string protocol = 1;</code>
       */
      public boolean hasProtocol() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
       * If not specified, this field defaults to TCP.
       * +optional
       * </pre>
       *
       * <code>optional string protocol = 1;</code>
       */
      public java.lang.String getProtocol() {
        java.lang.Object ref = protocol_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            protocol_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
       * If not specified, this field defaults to TCP.
       * +optional
       * </pre>
       *
       * <code>optional string protocol = 1;</code>
       */
      public com.google.protobuf.ByteString getProtocolBytes() {
        java.lang.Object ref = protocol_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          protocol_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
       * If not specified, this field defaults to TCP.
       * +optional
       * </pre>
       *
       * <code>optional string protocol = 1;</code>
       */
      public Builder setProtocol(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        protocol_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
       * If not specified, this field defaults to TCP.
       * +optional
       * </pre>
       *
       * <code>optional string protocol = 1;</code>
       */
      public Builder clearProtocol() {
        bitField0_ = (bitField0_ & ~0x00000001);
        protocol_ = getDefaultInstance().getProtocol();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
       * If not specified, this field defaults to TCP.
       * +optional
       * </pre>
       *
       * <code>optional string protocol = 1;</code>
       */
      public Builder setProtocolBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        protocol_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString port_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          portBuilder_;
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public boolean hasPort() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getPort() {
        if (portBuilder_ == null) {
          return port_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : port_;
        } else {
          return portBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public Builder setPort(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (portBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          port_ = value;
          onChanged();
        } else {
          portBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public Builder setPort(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (portBuilder_ == null) {
          port_ = builderForValue.build();
          onChanged();
        } else {
          portBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public Builder mergePort(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (portBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && port_ != null
              && port_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            port_ =
                io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(port_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            port_ = value;
          }
          onChanged();
        } else {
          portBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public Builder clearPort() {
        if (portBuilder_ == null) {
          port_ = null;
          onChanged();
        } else {
          portBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getPortBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getPortFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getPortOrBuilder() {
        if (portBuilder_ != null) {
          return portBuilder_.getMessageOrBuilder();
        } else {
          return port_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : port_;
        }
      }
      /**
       *
       *
       * <pre>
       * The port on the given protocol. This can either be a numerical or named
       * port on a pod. If this field is not provided, this matches all port names and
       * numbers.
       * If present, only traffic on the specified protocol AND port will be matched.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          getPortFieldBuilder() {
        if (portBuilder_ == null) {
          portBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.IntStr.IntOrString,
                  io.kubernetes.client.proto.IntStr.IntOrString.Builder,
                  io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getPort(), getParentForChildren(), isClean());
          port_ = null;
        }
        return portBuilder_;
      }

      private int endPort_;
      /**
       *
       *
       * <pre>
       * If set, indicates that the range of ports from port to endPort, inclusive,
       * should be allowed by the policy. This field cannot be defined if the port field
       * is not defined or if the port field is defined as a named (string) port.
       * The endPort must be equal or greater than port.
       * This feature is in Beta state and is enabled by default.
       * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
       * +optional
       * </pre>
       *
       * <code>optional int32 endPort = 3;</code>
       */
      public boolean hasEndPort() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * If set, indicates that the range of ports from port to endPort, inclusive,
       * should be allowed by the policy. This field cannot be defined if the port field
       * is not defined or if the port field is defined as a named (string) port.
       * The endPort must be equal or greater than port.
       * This feature is in Beta state and is enabled by default.
       * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
       * +optional
       * </pre>
       *
       * <code>optional int32 endPort = 3;</code>
       */
      public int getEndPort() {
        return endPort_;
      }
      /**
       *
       *
       * <pre>
       * If set, indicates that the range of ports from port to endPort, inclusive,
       * should be allowed by the policy. This field cannot be defined if the port field
       * is not defined or if the port field is defined as a named (string) port.
       * The endPort must be equal or greater than port.
       * This feature is in Beta state and is enabled by default.
       * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
       * +optional
       * </pre>
       *
       * <code>optional int32 endPort = 3;</code>
       */
      public Builder setEndPort(int value) {
        bitField0_ |= 0x00000004;
        endPort_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * If set, indicates that the range of ports from port to endPort, inclusive,
       * should be allowed by the policy. This field cannot be defined if the port field
       * is not defined or if the port field is defined as a named (string) port.
       * The endPort must be equal or greater than port.
       * This feature is in Beta state and is enabled by default.
       * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
       * +optional
       * </pre>
       *
       * <code>optional int32 endPort = 3;</code>
       */
      public Builder clearEndPort() {
        bitField0_ = (bitField0_ & ~0x00000004);
        endPort_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyPort)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicyPort)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicyPort> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicyPort>() {
          @java.lang.Override
          public NetworkPolicyPort parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicyPort(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicyPort> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicyPort> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyPort
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NetworkPolicySpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.NetworkPolicySpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
     * is applied to any pods selected by this field. Multiple network policies can select the
     * same set of pods.  In this case, the ingress rules for each are combined additively.
     * This field is NOT optional and follows standard label selector semantics.
     * An empty podSelector matches all pods in this namespace.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    boolean hasPodSelector();
    /**
     *
     *
     * <pre>
     * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
     * is applied to any pods selected by this field. Multiple network policies can select the
     * same set of pods.  In this case, the ingress rules for each are combined additively.
     * This field is NOT optional and follows standard label selector semantics.
     * An empty podSelector matches all pods in this namespace.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getPodSelector();
    /**
     *
     *
     * <pre>
     * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
     * is applied to any pods selected by this field. Multiple network policies can select the
     * same set of pods.  In this case, the ingress rules for each are combined additively.
     * This field is NOT optional and follows standard label selector semantics.
     * An empty podSelector matches all pods in this namespace.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getPodSelectorOrBuilder();

    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>
        getIngressList();
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule getIngress(int index);
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    int getIngressCount();
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    java.util.List<
            ? extends
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder>
        getIngressOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder
        getIngressOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>
        getEgressList();
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule getEgress(int index);
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    int getEgressCount();
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder>
        getEgressOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder
        getEgressOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    java.util.List<java.lang.String> getPolicyTypesList();
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    int getPolicyTypesCount();
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    java.lang.String getPolicyTypes(int index);
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    com.google.protobuf.ByteString getPolicyTypesBytes(int index);
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by networking/v1/NetworkPolicySpec.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicySpec}
   */
  public static final class NetworkPolicySpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.NetworkPolicySpec)
      NetworkPolicySpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use NetworkPolicySpec.newBuilder() to construct.
    private NetworkPolicySpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NetworkPolicySpec() {
      ingress_ = java.util.Collections.emptyList();
      egress_ = java.util.Collections.emptyList();
      policyTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private NetworkPolicySpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = podSelector_.toBuilder();
                }
                podSelector_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(podSelector_);
                  podSelector_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  ingress_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>();
                  mutable_bitField0_ |= 0x00000002;
                }
                ingress_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
                            .PARSER,
                        extensionRegistry));
                break;
              }
            case 26:
              {
                if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                  egress_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>();
                  mutable_bitField0_ |= 0x00000004;
                }
                egress_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.PARSER,
                        extensionRegistry));
                break;
              }
            case 34:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                  policyTypes_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000008;
                }
                policyTypes_.add(bs);
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          ingress_ = java.util.Collections.unmodifiableList(ingress_);
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          egress_ = java.util.Collections.unmodifiableList(egress_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          policyTypes_ = policyTypes_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder.class);
    }

    private int bitField0_;
    public static final int PODSELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector podSelector_;
    /**
     *
     *
     * <pre>
     * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
     * is applied to any pods selected by this field. Multiple network policies can select the
     * same set of pods.  In this case, the ingress rules for each are combined additively.
     * This field is NOT optional and follows standard label selector semantics.
     * An empty podSelector matches all pods in this namespace.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    public boolean hasPodSelector() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
     * is applied to any pods selected by this field. Multiple network policies can select the
     * same set of pods.  In this case, the ingress rules for each are combined additively.
     * This field is NOT optional and follows standard label selector semantics.
     * An empty podSelector matches all pods in this namespace.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getPodSelector() {
      return podSelector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : podSelector_;
    }
    /**
     *
     *
     * <pre>
     * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
     * is applied to any pods selected by this field. Multiple network policies can select the
     * same set of pods.  In this case, the ingress rules for each are combined additively.
     * This field is NOT optional and follows standard label selector semantics.
     * An empty podSelector matches all pods in this namespace.
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getPodSelectorOrBuilder() {
      return podSelector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : podSelector_;
    }

    public static final int INGRESS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>
        ingress_;
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>
        getIngressList() {
      return ingress_;
    }
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    public java.util.List<
            ? extends
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder>
        getIngressOrBuilderList() {
      return ingress_;
    }
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    public int getIngressCount() {
      return ingress_.size();
    }
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule getIngress(
        int index) {
      return ingress_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of ingress rules to be applied to the selected pods.
     * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
     * OR if the traffic source is the pod's local node,
     * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
     * objects whose podSelector matches the pod.
     * If this field is empty then this NetworkPolicy does not allow any traffic
     * (and serves solely to ensure that the pods it selects are isolated by default).
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder
        getIngressOrBuilder(int index) {
      return ingress_.get(index);
    }

    public static final int EGRESS_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>
        egress_;
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>
        getEgressList() {
      return egress_;
    }
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder>
        getEgressOrBuilderList() {
      return egress_;
    }
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    public int getEgressCount() {
      return egress_.size();
    }
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule getEgress(
        int index) {
      return egress_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of egress rules to be applied to the selected pods. Outgoing traffic is
     * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
     * otherwise allows the traffic), OR if the traffic matches at least one egress rule
     * across all of the NetworkPolicy objects whose podSelector matches the pod. If
     * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
     * solely to ensure that the pods it selects are isolated by default).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder
        getEgressOrBuilder(int index) {
      return egress_.get(index);
    }

    public static final int POLICYTYPES_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList policyTypes_;
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList getPolicyTypesList() {
      return policyTypes_;
    }
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    public int getPolicyTypesCount() {
      return policyTypes_.size();
    }
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    public java.lang.String getPolicyTypes(int index) {
      return policyTypes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of rule types that the NetworkPolicy relates to.
     * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
     * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
     * policies that contain an Egress section are assumed to affect Egress, and all policies
     * (whether or not they contain an Ingress section) are assumed to affect Ingress.
     * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
     * Likewise, if you want to write a policy that specifies that no egress is allowed,
     * you must specify a policyTypes value that include "Egress" (since such a policy would not include
     * an Egress section and would otherwise default to just [ "Ingress" ]).
     * This field is beta-level in 1.8
     * +optional
     * </pre>
     *
     * <code>repeated string policyTypes = 4;</code>
     */
    public com.google.protobuf.ByteString getPolicyTypesBytes(int index) {
      return policyTypes_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getPodSelector());
      }
      for (int i = 0; i < ingress_.size(); i++) {
        output.writeMessage(2, ingress_.get(i));
      }
      for (int i = 0; i < egress_.size(); i++) {
        output.writeMessage(3, egress_.get(i));
      }
      for (int i = 0; i < policyTypes_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, policyTypes_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getPodSelector());
      }
      for (int i = 0; i < ingress_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, ingress_.get(i));
      }
      for (int i = 0; i < egress_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, egress_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < policyTypes_.size(); i++) {
          dataSize += computeStringSizeNoTag(policyTypes_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getPolicyTypesList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec) obj;

      boolean result = true;
      result = result && (hasPodSelector() == other.hasPodSelector());
      if (hasPodSelector()) {
        result = result && getPodSelector().equals(other.getPodSelector());
      }
      result = result && getIngressList().equals(other.getIngressList());
      result = result && getEgressList().equals(other.getEgressList());
      result = result && getPolicyTypesList().equals(other.getPolicyTypesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPodSelector()) {
        hash = (37 * hash) + PODSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getPodSelector().hashCode();
      }
      if (getIngressCount() > 0) {
        hash = (37 * hash) + INGRESS_FIELD_NUMBER;
        hash = (53 * hash) + getIngressList().hashCode();
      }
      if (getEgressCount() > 0) {
        hash = (37 * hash) + EGRESS_FIELD_NUMBER;
        hash = (53 * hash) + getEgressList().hashCode();
      }
      if (getPolicyTypesCount() > 0) {
        hash = (37 * hash) + POLICYTYPES_FIELD_NUMBER;
        hash = (53 * hash) + getPolicyTypesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by networking/v1/NetworkPolicySpec.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.NetworkPolicySpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.NetworkPolicySpec)
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getPodSelectorFieldBuilder();
          getIngressFieldBuilder();
          getEgressFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (podSelectorBuilder_ == null) {
          podSelector_ = null;
        } else {
          podSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (ingressBuilder_ == null) {
          ingress_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          ingressBuilder_.clear();
        }
        if (egressBuilder_ == null) {
          egress_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          egressBuilder_.clear();
        }
        policyTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (podSelectorBuilder_ == null) {
          result.podSelector_ = podSelector_;
        } else {
          result.podSelector_ = podSelectorBuilder_.build();
        }
        if (ingressBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            ingress_ = java.util.Collections.unmodifiableList(ingress_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.ingress_ = ingress_;
        } else {
          result.ingress_ = ingressBuilder_.build();
        }
        if (egressBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            egress_ = java.util.Collections.unmodifiableList(egress_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.egress_ = egress_;
        } else {
          result.egress_ = egressBuilder_.build();
        }
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          policyTypes_ = policyTypes_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.policyTypes_ = policyTypes_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec.getDefaultInstance())
          return this;
        if (other.hasPodSelector()) {
          mergePodSelector(other.getPodSelector());
        }
        if (ingressBuilder_ == null) {
          if (!other.ingress_.isEmpty()) {
            if (ingress_.isEmpty()) {
              ingress_ = other.ingress_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureIngressIsMutable();
              ingress_.addAll(other.ingress_);
            }
            onChanged();
          }
        } else {
          if (!other.ingress_.isEmpty()) {
            if (ingressBuilder_.isEmpty()) {
              ingressBuilder_.dispose();
              ingressBuilder_ = null;
              ingress_ = other.ingress_;
              bitField0_ = (bitField0_ & ~0x00000002);
              ingressBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getIngressFieldBuilder()
                      : null;
            } else {
              ingressBuilder_.addAllMessages(other.ingress_);
            }
          }
        }
        if (egressBuilder_ == null) {
          if (!other.egress_.isEmpty()) {
            if (egress_.isEmpty()) {
              egress_ = other.egress_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureEgressIsMutable();
              egress_.addAll(other.egress_);
            }
            onChanged();
          }
        } else {
          if (!other.egress_.isEmpty()) {
            if (egressBuilder_.isEmpty()) {
              egressBuilder_.dispose();
              egressBuilder_ = null;
              egress_ = other.egress_;
              bitField0_ = (bitField0_ & ~0x00000004);
              egressBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getEgressFieldBuilder()
                      : null;
            } else {
              egressBuilder_.addAllMessages(other.egress_);
            }
          }
        }
        if (!other.policyTypes_.isEmpty()) {
          if (policyTypes_.isEmpty()) {
            policyTypes_ = other.policyTypes_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensurePolicyTypesIsMutable();
            policyTypes_.addAll(other.policyTypes_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector podSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          podSelectorBuilder_;
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public boolean hasPodSelector() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getPodSelector() {
        if (podSelectorBuilder_ == null) {
          return podSelector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : podSelector_;
        } else {
          return podSelectorBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder setPodSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (podSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          podSelector_ = value;
          onChanged();
        } else {
          podSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder setPodSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (podSelectorBuilder_ == null) {
          podSelector_ = builderForValue.build();
          onChanged();
        } else {
          podSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder mergePodSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (podSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && podSelector_ != null
              && podSelector_
                  != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            podSelector_ =
                io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(podSelector_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            podSelector_ = value;
          }
          onChanged();
        } else {
          podSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public Builder clearPodSelector() {
        if (podSelectorBuilder_ == null) {
          podSelector_ = null;
          onChanged();
        } else {
          podSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getPodSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getPodSelectorFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getPodSelectorOrBuilder() {
        if (podSelectorBuilder_ != null) {
          return podSelectorBuilder_.getMessageOrBuilder();
        } else {
          return podSelector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : podSelector_;
        }
      }
      /**
       *
       *
       * <pre>
       * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
       * is applied to any pods selected by this field. Multiple network policies can select the
       * same set of pods.  In this case, the ingress rules for each are combined additively.
       * This field is NOT optional and follows standard label selector semantics.
       * An empty podSelector matches all pods in this namespace.
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          getPodSelectorFieldBuilder() {
        if (podSelectorBuilder_ == null) {
          podSelectorBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.LabelSelector,
                  io.kubernetes.client.proto.Meta.LabelSelector.Builder,
                  io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getPodSelector(), getParentForChildren(), isClean());
          podSelector_ = null;
        }
        return podSelectorBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>
          ingress_ = java.util.Collections.emptyList();

      private void ensureIngressIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          ingress_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>(ingress_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder>
          ingressBuilder_;

      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>
          getIngressList() {
        if (ingressBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ingress_);
        } else {
          return ingressBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public int getIngressCount() {
        if (ingressBuilder_ == null) {
          return ingress_.size();
        } else {
          return ingressBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule getIngress(
          int index) {
        if (ingressBuilder_ == null) {
          return ingress_.get(index);
        } else {
          return ingressBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder setIngress(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule value) {
        if (ingressBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIngressIsMutable();
          ingress_.set(index, value);
          onChanged();
        } else {
          ingressBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder setIngress(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
              builderForValue) {
        if (ingressBuilder_ == null) {
          ensureIngressIsMutable();
          ingress_.set(index, builderForValue.build());
          onChanged();
        } else {
          ingressBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder addIngress(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule value) {
        if (ingressBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIngressIsMutable();
          ingress_.add(value);
          onChanged();
        } else {
          ingressBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder addIngress(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule value) {
        if (ingressBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIngressIsMutable();
          ingress_.add(index, value);
          onChanged();
        } else {
          ingressBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder addIngress(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
              builderForValue) {
        if (ingressBuilder_ == null) {
          ensureIngressIsMutable();
          ingress_.add(builderForValue.build());
          onChanged();
        } else {
          ingressBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder addIngress(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
              builderForValue) {
        if (ingressBuilder_ == null) {
          ensureIngressIsMutable();
          ingress_.add(index, builderForValue.build());
          onChanged();
        } else {
          ingressBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder addAllIngress(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule>
              values) {
        if (ingressBuilder_ == null) {
          ensureIngressIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ingress_);
          onChanged();
        } else {
          ingressBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder clearIngress() {
        if (ingressBuilder_ == null) {
          ingress_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          ingressBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public Builder removeIngress(int index) {
        if (ingressBuilder_ == null) {
          ensureIngressIsMutable();
          ingress_.remove(index);
          onChanged();
        } else {
          ingressBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
          getIngressBuilder(int index) {
        return getIngressFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder
          getIngressOrBuilder(int index) {
        if (ingressBuilder_ == null) {
          return ingress_.get(index);
        } else {
          return ingressBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public java.util.List<
              ? extends
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder>
          getIngressOrBuilderList() {
        if (ingressBuilder_ != null) {
          return ingressBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ingress_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
          addIngressBuilder() {
        return getIngressFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder
          addIngressBuilder(int index) {
        return getIngressFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of ingress rules to be applied to the selected pods.
       * Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
       * OR if the traffic source is the pod's local node,
       * OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
       * objects whose podSelector matches the pod.
       * If this field is empty then this NetworkPolicy does not allow any traffic
       * (and serves solely to ensure that the pods it selects are isolated by default).
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;</code>
       */
      public java.util.List<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder>
          getIngressBuilderList() {
        return getIngressFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder>
          getIngressFieldBuilder() {
        if (ingressBuilder_ == null) {
          ingressBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRule.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyIngressRuleOrBuilder>(
                  ingress_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          ingress_ = null;
        }
        return ingressBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>
          egress_ = java.util.Collections.emptyList();

      private void ensureEgressIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          egress_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>(egress_);
          bitField0_ |= 0x00000004;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder>
          egressBuilder_;

      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>
          getEgressList() {
        if (egressBuilder_ == null) {
          return java.util.Collections.unmodifiableList(egress_);
        } else {
          return egressBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public int getEgressCount() {
        if (egressBuilder_ == null) {
          return egress_.size();
        } else {
          return egressBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule getEgress(
          int index) {
        if (egressBuilder_ == null) {
          return egress_.get(index);
        } else {
          return egressBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder setEgress(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule value) {
        if (egressBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEgressIsMutable();
          egress_.set(index, value);
          onChanged();
        } else {
          egressBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder setEgress(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder
              builderForValue) {
        if (egressBuilder_ == null) {
          ensureEgressIsMutable();
          egress_.set(index, builderForValue.build());
          onChanged();
        } else {
          egressBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder addEgress(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule value) {
        if (egressBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEgressIsMutable();
          egress_.add(value);
          onChanged();
        } else {
          egressBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder addEgress(
          int index, io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule value) {
        if (egressBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEgressIsMutable();
          egress_.add(index, value);
          onChanged();
        } else {
          egressBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder addEgress(
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder
              builderForValue) {
        if (egressBuilder_ == null) {
          ensureEgressIsMutable();
          egress_.add(builderForValue.build());
          onChanged();
        } else {
          egressBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder addEgress(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder
              builderForValue) {
        if (egressBuilder_ == null) {
          ensureEgressIsMutable();
          egress_.add(index, builderForValue.build());
          onChanged();
        } else {
          egressBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder addAllEgress(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule>
              values) {
        if (egressBuilder_ == null) {
          ensureEgressIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, egress_);
          onChanged();
        } else {
          egressBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder clearEgress() {
        if (egressBuilder_ == null) {
          egress_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          egressBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public Builder removeEgress(int index) {
        if (egressBuilder_ == null) {
          ensureEgressIsMutable();
          egress_.remove(index);
          onChanged();
        } else {
          egressBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder
          getEgressBuilder(int index) {
        return getEgressFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder
          getEgressOrBuilder(int index) {
        if (egressBuilder_ == null) {
          return egress_.get(index);
        } else {
          return egressBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public java.util.List<
              ? extends
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder>
          getEgressOrBuilderList() {
        if (egressBuilder_ != null) {
          return egressBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(egress_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder
          addEgressBuilder() {
        return getEgressFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder
          addEgressBuilder(int index) {
        return getEgressFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of egress rules to be applied to the selected pods. Outgoing traffic is
       * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
       * otherwise allows the traffic), OR if the traffic matches at least one egress rule
       * across all of the NetworkPolicy objects whose podSelector matches the pod. If
       * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
       * solely to ensure that the pods it selects are isolated by default).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;</code>
       */
      public java.util.List<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder>
          getEgressBuilderList() {
        return getEgressFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder>
          getEgressFieldBuilder() {
        if (egressBuilder_ == null) {
          egressBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRule.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicyEgressRuleOrBuilder>(
                  egress_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          egress_ = null;
        }
        return egressBuilder_;
      }

      private com.google.protobuf.LazyStringList policyTypes_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensurePolicyTypesIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          policyTypes_ = new com.google.protobuf.LazyStringArrayList(policyTypes_);
          bitField0_ |= 0x00000008;
        }
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList getPolicyTypesList() {
        return policyTypes_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public int getPolicyTypesCount() {
        return policyTypes_.size();
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public java.lang.String getPolicyTypes(int index) {
        return policyTypes_.get(index);
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public com.google.protobuf.ByteString getPolicyTypesBytes(int index) {
        return policyTypes_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public Builder setPolicyTypes(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePolicyTypesIsMutable();
        policyTypes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public Builder addPolicyTypes(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePolicyTypesIsMutable();
        policyTypes_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public Builder addAllPolicyTypes(java.lang.Iterable<java.lang.String> values) {
        ensurePolicyTypesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, policyTypes_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public Builder clearPolicyTypes() {
        policyTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of rule types that the NetworkPolicy relates to.
       * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
       * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
       * policies that contain an Egress section are assumed to affect Egress, and all policies
       * (whether or not they contain an Ingress section) are assumed to affect Ingress.
       * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
       * Likewise, if you want to write a policy that specifies that no egress is allowed,
       * you must specify a policyTypes value that include "Egress" (since such a policy would not include
       * an Egress section and would otherwise default to just [ "Ingress" ]).
       * This field is beta-level in 1.8
       * +optional
       * </pre>
       *
       * <code>repeated string policyTypes = 4;</code>
       */
      public Builder addPolicyTypesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePolicyTypesIsMutable();
        policyTypes_.add(value);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.NetworkPolicySpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.NetworkPolicySpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<NetworkPolicySpec> PARSER =
        new com.google.protobuf.AbstractParser<NetworkPolicySpec>() {
          @java.lang.Override
          public NetworkPolicySpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new NetworkPolicySpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<NetworkPolicySpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NetworkPolicySpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.NetworkPolicySpec
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PodSecurityPolicyOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.PodSecurityPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * spec defines the policy enforced.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * spec defines the policy enforced.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec getSpec();
    /**
     *
     *
     * <pre>
     * spec defines the policy enforced.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder getSpecOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * PodSecurityPolicy governs the ability to make requests that affect the Security Context
   * that will be applied to a pod and container.
   * Deprecated: use PodSecurityPolicy from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.PodSecurityPolicy}
   */
  public static final class PodSecurityPolicy extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.PodSecurityPolicy)
      PodSecurityPolicyOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use PodSecurityPolicy.newBuilder() to construct.
    private PodSecurityPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PodSecurityPolicy() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private PodSecurityPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.class,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec spec_;
    /**
     *
     *
     * <pre>
     * spec defines the policy enforced.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * spec defines the policy enforced.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * spec defines the policy enforced.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder
        getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.getDefaultInstance()
          : spec_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy other =
          (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * PodSecurityPolicy governs the ability to make requests that affect the Security Context
     * that will be applied to a pod and container.
     * Deprecated: use PodSecurityPolicy from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.PodSecurityPolicy}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.PodSecurityPolicy)
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.class,
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy build() {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy result =
            new io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
                  .getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder
              builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public Builder mergeSpec(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
                      .getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder
          getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder
          getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
                  .getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * spec defines the policy enforced.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec,
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.PodSecurityPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.PodSecurityPolicy)
    private static final io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<PodSecurityPolicy> PARSER =
        new com.google.protobuf.AbstractParser<PodSecurityPolicy>() {
          @java.lang.Override
          public PodSecurityPolicy parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new PodSecurityPolicy(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<PodSecurityPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodSecurityPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PodSecurityPolicyListOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.PodSecurityPolicyList)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy> getItemsList();
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy getItems(int index);
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    int getItemsCount();
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder>
        getItemsOrBuilderList();
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   *
   *
   * <pre>
   * PodSecurityPolicyList is a list of PodSecurityPolicy objects.
   * Deprecated: use PodSecurityPolicyList from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.PodSecurityPolicyList}
   */
  public static final class PodSecurityPolicyList extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.PodSecurityPolicyList)
      PodSecurityPolicyListOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use PodSecurityPolicyList.newBuilder() to construct.
    private PodSecurityPolicyList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PodSecurityPolicyList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private PodSecurityPolicyList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  items_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy>();
                  mutable_bitField0_ |= 0x00000002;
                }
                items_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList.class,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy> items_;
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy>
        getItemsList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder>
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy getItems(int index) {
      return items_.get(index);
    }
    /**
     *
     *
     * <pre>
     * items is a list of schema objects.
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder
        getItemsOrBuilder(int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList other =
          (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && getItemsList().equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * PodSecurityPolicyList is a list of PodSecurityPolicy objects.
     * Deprecated: use PodSecurityPolicyList from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.PodSecurityPolicyList}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.PodSecurityPolicyList)
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList.class,
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList build() {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList result =
            new io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
                .getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getItemsFieldBuilder()
                      : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ListMeta,
                  io.kubernetes.client.proto.Meta.ListMeta.Builder,
                  io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy>
          items_ = java.util.Collections.emptyList();

      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy>(items_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder>
          itemsBuilder_;

      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy>
          getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder setItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder addItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy>
              values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder
          getItemsOrBuilder(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder>
          getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder
          addItemsBuilder() {
        return getItemsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * items is a list of schema objects.
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.PodSecurityPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder>
          getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder>
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy,
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicy.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.PodSecurityPolicyList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.PodSecurityPolicyList)
    private static final io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<PodSecurityPolicyList> PARSER =
        new com.google.protobuf.AbstractParser<PodSecurityPolicyList>() {
          @java.lang.Override
          public PodSecurityPolicyList parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new PodSecurityPolicyList(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<PodSecurityPolicyList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodSecurityPolicyList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicyList
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PodSecurityPolicySpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * privileged determines if a pod can request to be run as privileged.
     * +optional
     * </pre>
     *
     * <code>optional bool privileged = 1;</code>
     */
    boolean hasPrivileged();
    /**
     *
     *
     * <pre>
     * privileged determines if a pod can request to be run as privileged.
     * +optional
     * </pre>
     *
     * <code>optional bool privileged = 1;</code>
     */
    boolean getPrivileged();

    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    java.util.List<java.lang.String> getDefaultAddCapabilitiesList();
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    int getDefaultAddCapabilitiesCount();
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    java.lang.String getDefaultAddCapabilities(int index);
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    com.google.protobuf.ByteString getDefaultAddCapabilitiesBytes(int index);

    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    java.util.List<java.lang.String> getRequiredDropCapabilitiesList();
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    int getRequiredDropCapabilitiesCount();
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    java.lang.String getRequiredDropCapabilities(int index);
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    com.google.protobuf.ByteString getRequiredDropCapabilitiesBytes(int index);

    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    java.util.List<java.lang.String> getAllowedCapabilitiesList();
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    int getAllowedCapabilitiesCount();
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    java.lang.String getAllowedCapabilities(int index);
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    com.google.protobuf.ByteString getAllowedCapabilitiesBytes(int index);

    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    java.util.List<java.lang.String> getVolumesList();
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    int getVolumesCount();
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    java.lang.String getVolumes(int index);
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    com.google.protobuf.ByteString getVolumesBytes(int index);

    /**
     *
     *
     * <pre>
     * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostNetwork = 6;</code>
     */
    boolean hasHostNetwork();
    /**
     *
     *
     * <pre>
     * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostNetwork = 6;</code>
     */
    boolean getHostNetwork();

    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange> getHostPortsList();
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.HostPortRange getHostPorts(int index);
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    int getHostPortsCount();
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder>
        getHostPortsOrBuilderList();
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder getHostPortsOrBuilder(
        int index);

    /**
     *
     *
     * <pre>
     * hostPID determines if the policy allows the use of HostPID in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostPID = 8;</code>
     */
    boolean hasHostPID();
    /**
     *
     *
     * <pre>
     * hostPID determines if the policy allows the use of HostPID in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostPID = 8;</code>
     */
    boolean getHostPID();

    /**
     *
     *
     * <pre>
     * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostIPC = 9;</code>
     */
    boolean hasHostIPC();
    /**
     *
     *
     * <pre>
     * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostIPC = 9;</code>
     */
    boolean getHostIPC();

    /**
     *
     *
     * <pre>
     * seLinux is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
     */
    boolean hasSeLinux();
    /**
     *
     *
     * <pre>
     * seLinux is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions getSeLinux();
    /**
     *
     *
     * <pre>
     * seLinux is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder
        getSeLinuxOrBuilder();

    /**
     *
     *
     * <pre>
     * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;</code>
     */
    boolean hasRunAsUser();
    /**
     *
     *
     * <pre>
     * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions getRunAsUser();
    /**
     *
     *
     * <pre>
     * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder
        getRunAsUserOrBuilder();

    /**
     *
     *
     * <pre>
     * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
     * RunAsGroup feature gate to be enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
     * </code>
     */
    boolean hasRunAsGroup();
    /**
     *
     *
     * <pre>
     * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
     * RunAsGroup feature gate to be enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions getRunAsGroup();
    /**
     *
     *
     * <pre>
     * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
     * RunAsGroup feature gate to be enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder
        getRunAsGroupOrBuilder();

    /**
     *
     *
     * <pre>
     * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
     * </pre>
     *
     * <code>
     * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
     * </code>
     */
    boolean hasSupplementalGroups();
    /**
     *
     *
     * <pre>
     * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
     * </pre>
     *
     * <code>
     * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        getSupplementalGroups();
    /**
     *
     *
     * <pre>
     * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
     * </pre>
     *
     * <code>
     * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptionsOrBuilder
        getSupplementalGroupsOrBuilder();

    /**
     *
     *
     * <pre>
     * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
     */
    boolean hasFsGroup();
    /**
     *
     *
     * <pre>
     * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions getFsGroup();
    /**
     *
     *
     * <pre>
     * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder
        getFsGroupOrBuilder();

    /**
     *
     *
     * <pre>
     * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
     * system.  If the container specifically requests to run with a non-read only root file system
     * the PSP should deny the pod.
     * If set to false the container may run with a read only root file system if it wishes but it
     * will not be forced to.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnlyRootFilesystem = 14;</code>
     */
    boolean hasReadOnlyRootFilesystem();
    /**
     *
     *
     * <pre>
     * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
     * system.  If the container specifically requests to run with a non-read only root file system
     * the PSP should deny the pod.
     * If set to false the container may run with a read only root file system if it wishes but it
     * will not be forced to.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnlyRootFilesystem = 14;</code>
     */
    boolean getReadOnlyRootFilesystem();

    /**
     *
     *
     * <pre>
     * defaultAllowPrivilegeEscalation controls the default setting for whether a
     * process can gain more privileges than its parent process.
     * +optional
     * </pre>
     *
     * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
     */
    boolean hasDefaultAllowPrivilegeEscalation();
    /**
     *
     *
     * <pre>
     * defaultAllowPrivilegeEscalation controls the default setting for whether a
     * process can gain more privileges than its parent process.
     * +optional
     * </pre>
     *
     * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
     */
    boolean getDefaultAllowPrivilegeEscalation();

    /**
     *
     *
     * <pre>
     * allowPrivilegeEscalation determines if a pod can request to allow
     * privilege escalation. If unspecified, defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool allowPrivilegeEscalation = 16;</code>
     */
    boolean hasAllowPrivilegeEscalation();
    /**
     *
     *
     * <pre>
     * allowPrivilegeEscalation determines if a pod can request to allow
     * privilege escalation. If unspecified, defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool allowPrivilegeEscalation = 16;</code>
     */
    boolean getAllowPrivilegeEscalation();

    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>
        getAllowedHostPathsList();
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath getAllowedHostPaths(int index);
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    int getAllowedHostPathsCount();
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder>
        getAllowedHostPathsOrBuilderList();
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder
        getAllowedHostPathsOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>
        getAllowedFlexVolumesList();
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume getAllowedFlexVolumes(int index);
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    int getAllowedFlexVolumesCount();
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder>
        getAllowedFlexVolumesOrBuilderList();
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder
        getAllowedFlexVolumesOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>
        getAllowedCSIDriversList();
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver getAllowedCSIDrivers(int index);
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    int getAllowedCSIDriversCount();
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder>
        getAllowedCSIDriversOrBuilderList();
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder
        getAllowedCSIDriversOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    java.util.List<java.lang.String> getAllowedUnsafeSysctlsList();
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    int getAllowedUnsafeSysctlsCount();
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    java.lang.String getAllowedUnsafeSysctls(int index);
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    com.google.protobuf.ByteString getAllowedUnsafeSysctlsBytes(int index);

    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    java.util.List<java.lang.String> getForbiddenSysctlsList();
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    int getForbiddenSysctlsCount();
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    java.lang.String getForbiddenSysctls(int index);
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    com.google.protobuf.ByteString getForbiddenSysctlsBytes(int index);

    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    java.util.List<java.lang.String> getAllowedProcMountTypesList();
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    int getAllowedProcMountTypesCount();
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    java.lang.String getAllowedProcMountTypes(int index);
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    com.google.protobuf.ByteString getAllowedProcMountTypesBytes(int index);

    /**
     *
     *
     * <pre>
     * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
     * If this field is omitted, the pod's runtimeClassName field is unrestricted.
     * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
     * </code>
     */
    boolean hasRuntimeClass();
    /**
     *
     *
     * <pre>
     * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
     * If this field is omitted, the pod's runtimeClassName field is unrestricted.
     * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions getRuntimeClass();
    /**
     *
     *
     * <pre>
     * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
     * If this field is omitted, the pod's runtimeClassName field is unrestricted.
     * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
     * </code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptionsOrBuilder
        getRuntimeClassOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * PodSecurityPolicySpec defines the policy enforced.
   * Deprecated: use PodSecurityPolicySpec from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec}
   */
  public static final class PodSecurityPolicySpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec)
      PodSecurityPolicySpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use PodSecurityPolicySpec.newBuilder() to construct.
    private PodSecurityPolicySpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PodSecurityPolicySpec() {
      privileged_ = false;
      defaultAddCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      requiredDropCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      allowedCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      volumes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      hostNetwork_ = false;
      hostPorts_ = java.util.Collections.emptyList();
      hostPID_ = false;
      hostIPC_ = false;
      readOnlyRootFilesystem_ = false;
      defaultAllowPrivilegeEscalation_ = false;
      allowPrivilegeEscalation_ = false;
      allowedHostPaths_ = java.util.Collections.emptyList();
      allowedFlexVolumes_ = java.util.Collections.emptyList();
      allowedCSIDrivers_ = java.util.Collections.emptyList();
      allowedUnsafeSysctls_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      forbiddenSysctls_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      allowedProcMountTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private PodSecurityPolicySpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                privileged_ = input.readBool();
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  defaultAddCapabilities_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000002;
                }
                defaultAddCapabilities_.add(bs);
                break;
              }
            case 26:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                  requiredDropCapabilities_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000004;
                }
                requiredDropCapabilities_.add(bs);
                break;
              }
            case 34:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                  allowedCapabilities_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000008;
                }
                allowedCapabilities_.add(bs);
                break;
              }
            case 42:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                  volumes_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000010;
                }
                volumes_.add(bs);
                break;
              }
            case 48:
              {
                bitField0_ |= 0x00000002;
                hostNetwork_ = input.readBool();
                break;
              }
            case 58:
              {
                if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                  hostPorts_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.HostPortRange>();
                  mutable_bitField0_ |= 0x00000040;
                }
                hostPorts_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.PARSER,
                        extensionRegistry));
                break;
              }
            case 64:
              {
                bitField0_ |= 0x00000004;
                hostPID_ = input.readBool();
                break;
              }
            case 72:
              {
                bitField0_ |= 0x00000008;
                hostIPC_ = input.readBool();
                break;
              }
            case 82:
              {
                io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000010) == 0x00000010)) {
                  subBuilder = seLinux_.toBuilder();
                }
                seLinux_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(seLinux_);
                  seLinux_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000010;
                break;
              }
            case 90:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000020) == 0x00000020)) {
                  subBuilder = runAsUser_.toBuilder();
                }
                runAsUser_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
                            .PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(runAsUser_);
                  runAsUser_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000020;
                break;
              }
            case 98:
              {
                io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                        .Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000080) == 0x00000080)) {
                  subBuilder = supplementalGroups_.toBuilder();
                }
                supplementalGroups_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions
                            .SupplementalGroupsStrategyOptions.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(supplementalGroups_);
                  supplementalGroups_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000080;
                break;
              }
            case 106:
              {
                io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000100) == 0x00000100)) {
                  subBuilder = fsGroup_.toBuilder();
                }
                fsGroup_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(fsGroup_);
                  fsGroup_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000100;
                break;
              }
            case 112:
              {
                bitField0_ |= 0x00000200;
                readOnlyRootFilesystem_ = input.readBool();
                break;
              }
            case 120:
              {
                bitField0_ |= 0x00000400;
                defaultAllowPrivilegeEscalation_ = input.readBool();
                break;
              }
            case 128:
              {
                bitField0_ |= 0x00000800;
                allowPrivilegeEscalation_ = input.readBool();
                break;
              }
            case 138:
              {
                if (!((mutable_bitField0_ & 0x00020000) == 0x00020000)) {
                  allowedHostPaths_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>();
                  mutable_bitField0_ |= 0x00020000;
                }
                allowedHostPaths_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.PARSER,
                        extensionRegistry));
                break;
              }
            case 146:
              {
                if (!((mutable_bitField0_ & 0x00040000) == 0x00040000)) {
                  allowedFlexVolumes_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>();
                  mutable_bitField0_ |= 0x00040000;
                }
                allowedFlexVolumes_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.PARSER,
                        extensionRegistry));
                break;
              }
            case 154:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00100000) == 0x00100000)) {
                  allowedUnsafeSysctls_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00100000;
                }
                allowedUnsafeSysctls_.add(bs);
                break;
              }
            case 162:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00200000) == 0x00200000)) {
                  forbiddenSysctls_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00200000;
                }
                forbiddenSysctls_.add(bs);
                break;
              }
            case 170:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00400000) == 0x00400000)) {
                  allowedProcMountTypes_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00400000;
                }
                allowedProcMountTypes_.add(bs);
                break;
              }
            case 178:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00000040) == 0x00000040)) {
                  subBuilder = runAsGroup_.toBuilder();
                }
                runAsGroup_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
                            .PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(runAsGroup_);
                  runAsGroup_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000040;
                break;
              }
            case 186:
              {
                if (!((mutable_bitField0_ & 0x00080000) == 0x00080000)) {
                  allowedCSIDrivers_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>();
                  mutable_bitField0_ |= 0x00080000;
                }
                allowedCSIDrivers_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.PARSER,
                        extensionRegistry));
                break;
              }
            case 194:
              {
                io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder
                    subBuilder = null;
                if (((bitField0_ & 0x00001000) == 0x00001000)) {
                  subBuilder = runtimeClass_.toBuilder();
                }
                runtimeClass_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
                            .PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(runtimeClass_);
                  runtimeClass_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00001000;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          defaultAddCapabilities_ = defaultAddCapabilities_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          requiredDropCapabilities_ = requiredDropCapabilities_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          allowedCapabilities_ = allowedCapabilities_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          volumes_ = volumes_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          hostPorts_ = java.util.Collections.unmodifiableList(hostPorts_);
        }
        if (((mutable_bitField0_ & 0x00020000) == 0x00020000)) {
          allowedHostPaths_ = java.util.Collections.unmodifiableList(allowedHostPaths_);
        }
        if (((mutable_bitField0_ & 0x00040000) == 0x00040000)) {
          allowedFlexVolumes_ = java.util.Collections.unmodifiableList(allowedFlexVolumes_);
        }
        if (((mutable_bitField0_ & 0x00100000) == 0x00100000)) {
          allowedUnsafeSysctls_ = allowedUnsafeSysctls_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00200000) == 0x00200000)) {
          forbiddenSysctls_ = forbiddenSysctls_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00400000) == 0x00400000)) {
          allowedProcMountTypes_ = allowedProcMountTypes_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00080000) == 0x00080000)) {
          allowedCSIDrivers_ = java.util.Collections.unmodifiableList(allowedCSIDrivers_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder.class);
    }

    private int bitField0_;
    public static final int PRIVILEGED_FIELD_NUMBER = 1;
    private boolean privileged_;
    /**
     *
     *
     * <pre>
     * privileged determines if a pod can request to be run as privileged.
     * +optional
     * </pre>
     *
     * <code>optional bool privileged = 1;</code>
     */
    public boolean hasPrivileged() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * privileged determines if a pod can request to be run as privileged.
     * +optional
     * </pre>
     *
     * <code>optional bool privileged = 1;</code>
     */
    public boolean getPrivileged() {
      return privileged_;
    }

    public static final int DEFAULTADDCAPABILITIES_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList defaultAddCapabilities_;
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList getDefaultAddCapabilitiesList() {
      return defaultAddCapabilities_;
    }
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    public int getDefaultAddCapabilitiesCount() {
      return defaultAddCapabilities_.size();
    }
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    public java.lang.String getDefaultAddCapabilities(int index) {
      return defaultAddCapabilities_.get(index);
    }
    /**
     *
     *
     * <pre>
     * defaultAddCapabilities is the default set of capabilities that will be added to the container
     * unless the pod spec specifically drops the capability.  You may not list a capability in both
     * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
     * allowed, and need not be included in the allowedCapabilities list.
     * +optional
     * </pre>
     *
     * <code>repeated string defaultAddCapabilities = 2;</code>
     */
    public com.google.protobuf.ByteString getDefaultAddCapabilitiesBytes(int index) {
      return defaultAddCapabilities_.getByteString(index);
    }

    public static final int REQUIREDDROPCAPABILITIES_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList requiredDropCapabilities_;
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    public com.google.protobuf.ProtocolStringList getRequiredDropCapabilitiesList() {
      return requiredDropCapabilities_;
    }
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    public int getRequiredDropCapabilitiesCount() {
      return requiredDropCapabilities_.size();
    }
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    public java.lang.String getRequiredDropCapabilities(int index) {
      return requiredDropCapabilities_.get(index);
    }
    /**
     *
     *
     * <pre>
     * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
     * are required to be dropped and cannot be added.
     * +optional
     * </pre>
     *
     * <code>repeated string requiredDropCapabilities = 3;</code>
     */
    public com.google.protobuf.ByteString getRequiredDropCapabilitiesBytes(int index) {
      return requiredDropCapabilities_.getByteString(index);
    }

    public static final int ALLOWEDCAPABILITIES_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList allowedCapabilities_;
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList getAllowedCapabilitiesList() {
      return allowedCapabilities_;
    }
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    public int getAllowedCapabilitiesCount() {
      return allowedCapabilities_.size();
    }
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    public java.lang.String getAllowedCapabilities(int index) {
      return allowedCapabilities_.get(index);
    }
    /**
     *
     *
     * <pre>
     * allowedCapabilities is a list of capabilities that can be requested to add to the container.
     * Capabilities in this field may be added at the pod author's discretion.
     * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedCapabilities = 4;</code>
     */
    public com.google.protobuf.ByteString getAllowedCapabilitiesBytes(int index) {
      return allowedCapabilities_.getByteString(index);
    }

    public static final int VOLUMES_FIELD_NUMBER = 5;
    private com.google.protobuf.LazyStringList volumes_;
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    public com.google.protobuf.ProtocolStringList getVolumesList() {
      return volumes_;
    }
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    public int getVolumesCount() {
      return volumes_.size();
    }
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    public java.lang.String getVolumes(int index) {
      return volumes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * volumes is an allowlist of volume plugins. Empty indicates that
     * no volumes may be used. To allow all volumes you may use '*'.
     * +optional
     * </pre>
     *
     * <code>repeated string volumes = 5;</code>
     */
    public com.google.protobuf.ByteString getVolumesBytes(int index) {
      return volumes_.getByteString(index);
    }

    public static final int HOSTNETWORK_FIELD_NUMBER = 6;
    private boolean hostNetwork_;
    /**
     *
     *
     * <pre>
     * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostNetwork = 6;</code>
     */
    public boolean hasHostNetwork() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostNetwork = 6;</code>
     */
    public boolean getHostNetwork() {
      return hostNetwork_;
    }

    public static final int HOSTPORTS_FIELD_NUMBER = 7;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange> hostPorts_;
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange>
        getHostPortsList() {
      return hostPorts_;
    }
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder>
        getHostPortsOrBuilderList() {
      return hostPorts_;
    }
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    public int getHostPortsCount() {
      return hostPorts_.size();
    }
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange getHostPorts(int index) {
      return hostPorts_.get(index);
    }
    /**
     *
     *
     * <pre>
     * hostPorts determines which host port ranges are allowed to be exposed.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder
        getHostPortsOrBuilder(int index) {
      return hostPorts_.get(index);
    }

    public static final int HOSTPID_FIELD_NUMBER = 8;
    private boolean hostPID_;
    /**
     *
     *
     * <pre>
     * hostPID determines if the policy allows the use of HostPID in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostPID = 8;</code>
     */
    public boolean hasHostPID() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * hostPID determines if the policy allows the use of HostPID in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostPID = 8;</code>
     */
    public boolean getHostPID() {
      return hostPID_;
    }

    public static final int HOSTIPC_FIELD_NUMBER = 9;
    private boolean hostIPC_;
    /**
     *
     *
     * <pre>
     * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostIPC = 9;</code>
     */
    public boolean hasHostIPC() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
     * +optional
     * </pre>
     *
     * <code>optional bool hostIPC = 9;</code>
     */
    public boolean getHostIPC() {
      return hostIPC_;
    }

    public static final int SELINUX_FIELD_NUMBER = 10;
    private io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions seLinux_;
    /**
     *
     *
     * <pre>
     * seLinux is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
     */
    public boolean hasSeLinux() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * seLinux is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions getSeLinux() {
      return seLinux_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.getDefaultInstance()
          : seLinux_;
    }
    /**
     *
     *
     * <pre>
     * seLinux is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder
        getSeLinuxOrBuilder() {
      return seLinux_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.getDefaultInstance()
          : seLinux_;
    }

    public static final int RUNASUSER_FIELD_NUMBER = 11;
    private io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions runAsUser_;
    /**
     *
     *
     * <pre>
     * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;</code>
     */
    public boolean hasRunAsUser() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     *
     *
     * <pre>
     * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions getRunAsUser() {
      return runAsUser_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
              .getDefaultInstance()
          : runAsUser_;
    }
    /**
     *
     *
     * <pre>
     * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder
        getRunAsUserOrBuilder() {
      return runAsUser_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
              .getDefaultInstance()
          : runAsUser_;
    }

    public static final int RUNASGROUP_FIELD_NUMBER = 22;
    private io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions runAsGroup_;
    /**
     *
     *
     * <pre>
     * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
     * RunAsGroup feature gate to be enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
     * </code>
     */
    public boolean hasRunAsGroup() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     *
     *
     * <pre>
     * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
     * RunAsGroup feature gate to be enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions getRunAsGroup() {
      return runAsGroup_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
              .getDefaultInstance()
          : runAsGroup_;
    }
    /**
     *
     *
     * <pre>
     * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
     * RunAsGroup feature gate to be enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder
        getRunAsGroupOrBuilder() {
      return runAsGroup_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
              .getDefaultInstance()
          : runAsGroup_;
    }

    public static final int SUPPLEMENTALGROUPS_FIELD_NUMBER = 12;
    private io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        supplementalGroups_;
    /**
     *
     *
     * <pre>
     * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
     * </pre>
     *
     * <code>
     * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
     * </code>
     */
    public boolean hasSupplementalGroups() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     *
     *
     * <pre>
     * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
     * </pre>
     *
     * <code>
     * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        getSupplementalGroups() {
      return supplementalGroups_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
              .getDefaultInstance()
          : supplementalGroups_;
    }
    /**
     *
     *
     * <pre>
     * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
     * </pre>
     *
     * <code>
     * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptionsOrBuilder
        getSupplementalGroupsOrBuilder() {
      return supplementalGroups_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
              .getDefaultInstance()
          : supplementalGroups_;
    }

    public static final int FSGROUP_FIELD_NUMBER = 13;
    private io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions fsGroup_;
    /**
     *
     *
     * <pre>
     * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
     */
    public boolean hasFsGroup() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     *
     *
     * <pre>
     * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions getFsGroup() {
      return fsGroup_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.getDefaultInstance()
          : fsGroup_;
    }
    /**
     *
     *
     * <pre>
     * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder
        getFsGroupOrBuilder() {
      return fsGroup_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.getDefaultInstance()
          : fsGroup_;
    }

    public static final int READONLYROOTFILESYSTEM_FIELD_NUMBER = 14;
    private boolean readOnlyRootFilesystem_;
    /**
     *
     *
     * <pre>
     * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
     * system.  If the container specifically requests to run with a non-read only root file system
     * the PSP should deny the pod.
     * If set to false the container may run with a read only root file system if it wishes but it
     * will not be forced to.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnlyRootFilesystem = 14;</code>
     */
    public boolean hasReadOnlyRootFilesystem() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     *
     *
     * <pre>
     * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
     * system.  If the container specifically requests to run with a non-read only root file system
     * the PSP should deny the pod.
     * If set to false the container may run with a read only root file system if it wishes but it
     * will not be forced to.
     * +optional
     * </pre>
     *
     * <code>optional bool readOnlyRootFilesystem = 14;</code>
     */
    public boolean getReadOnlyRootFilesystem() {
      return readOnlyRootFilesystem_;
    }

    public static final int DEFAULTALLOWPRIVILEGEESCALATION_FIELD_NUMBER = 15;
    private boolean defaultAllowPrivilegeEscalation_;
    /**
     *
     *
     * <pre>
     * defaultAllowPrivilegeEscalation controls the default setting for whether a
     * process can gain more privileges than its parent process.
     * +optional
     * </pre>
     *
     * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
     */
    public boolean hasDefaultAllowPrivilegeEscalation() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     *
     *
     * <pre>
     * defaultAllowPrivilegeEscalation controls the default setting for whether a
     * process can gain more privileges than its parent process.
     * +optional
     * </pre>
     *
     * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
     */
    public boolean getDefaultAllowPrivilegeEscalation() {
      return defaultAllowPrivilegeEscalation_;
    }

    public static final int ALLOWPRIVILEGEESCALATION_FIELD_NUMBER = 16;
    private boolean allowPrivilegeEscalation_;
    /**
     *
     *
     * <pre>
     * allowPrivilegeEscalation determines if a pod can request to allow
     * privilege escalation. If unspecified, defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool allowPrivilegeEscalation = 16;</code>
     */
    public boolean hasAllowPrivilegeEscalation() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     *
     *
     * <pre>
     * allowPrivilegeEscalation determines if a pod can request to allow
     * privilege escalation. If unspecified, defaults to true.
     * +optional
     * </pre>
     *
     * <code>optional bool allowPrivilegeEscalation = 16;</code>
     */
    public boolean getAllowPrivilegeEscalation() {
      return allowPrivilegeEscalation_;
    }

    public static final int ALLOWEDHOSTPATHS_FIELD_NUMBER = 17;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>
        allowedHostPaths_;
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>
        getAllowedHostPathsList() {
      return allowedHostPaths_;
    }
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder>
        getAllowedHostPathsOrBuilderList() {
      return allowedHostPaths_;
    }
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    public int getAllowedHostPathsCount() {
      return allowedHostPaths_.size();
    }
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath getAllowedHostPaths(
        int index) {
      return allowedHostPaths_.get(index);
    }
    /**
     *
     *
     * <pre>
     * allowedHostPaths is an allowlist of host paths. Empty indicates
     * that all host paths may be used.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder
        getAllowedHostPathsOrBuilder(int index) {
      return allowedHostPaths_.get(index);
    }

    public static final int ALLOWEDFLEXVOLUMES_FIELD_NUMBER = 18;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>
        allowedFlexVolumes_;
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>
        getAllowedFlexVolumesList() {
      return allowedFlexVolumes_;
    }
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder>
        getAllowedFlexVolumesOrBuilderList() {
      return allowedFlexVolumes_;
    }
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    public int getAllowedFlexVolumesCount() {
      return allowedFlexVolumes_.size();
    }
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume getAllowedFlexVolumes(
        int index) {
      return allowedFlexVolumes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
     * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
     * is allowed in the "volumes" field.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder
        getAllowedFlexVolumesOrBuilder(int index) {
      return allowedFlexVolumes_.get(index);
    }

    public static final int ALLOWEDCSIDRIVERS_FIELD_NUMBER = 23;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>
        allowedCSIDrivers_;
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>
        getAllowedCSIDriversList() {
      return allowedCSIDrivers_;
    }
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder>
        getAllowedCSIDriversOrBuilderList() {
      return allowedCSIDrivers_;
    }
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    public int getAllowedCSIDriversCount() {
      return allowedCSIDrivers_.size();
    }
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver getAllowedCSIDrivers(
        int index) {
      return allowedCSIDrivers_.get(index);
    }
    /**
     *
     *
     * <pre>
     * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
     * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder
        getAllowedCSIDriversOrBuilder(int index) {
      return allowedCSIDrivers_.get(index);
    }

    public static final int ALLOWEDUNSAFESYSCTLS_FIELD_NUMBER = 19;
    private com.google.protobuf.LazyStringList allowedUnsafeSysctls_;
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    public com.google.protobuf.ProtocolStringList getAllowedUnsafeSysctlsList() {
      return allowedUnsafeSysctls_;
    }
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    public int getAllowedUnsafeSysctlsCount() {
      return allowedUnsafeSysctls_.size();
    }
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    public java.lang.String getAllowedUnsafeSysctls(int index) {
      return allowedUnsafeSysctls_.get(index);
    }
    /**
     *
     *
     * <pre>
     * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
     * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
     * Examples:
     * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedUnsafeSysctls = 19;</code>
     */
    public com.google.protobuf.ByteString getAllowedUnsafeSysctlsBytes(int index) {
      return allowedUnsafeSysctls_.getByteString(index);
    }

    public static final int FORBIDDENSYSCTLS_FIELD_NUMBER = 20;
    private com.google.protobuf.LazyStringList forbiddenSysctls_;
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    public com.google.protobuf.ProtocolStringList getForbiddenSysctlsList() {
      return forbiddenSysctls_;
    }
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    public int getForbiddenSysctlsCount() {
      return forbiddenSysctls_.size();
    }
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    public java.lang.String getForbiddenSysctls(int index) {
      return forbiddenSysctls_.get(index);
    }
    /**
     *
     *
     * <pre>
     * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
     * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
     * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
     * Examples:
     * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
     * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
     * +optional
     * </pre>
     *
     * <code>repeated string forbiddenSysctls = 20;</code>
     */
    public com.google.protobuf.ByteString getForbiddenSysctlsBytes(int index) {
      return forbiddenSysctls_.getByteString(index);
    }

    public static final int ALLOWEDPROCMOUNTTYPES_FIELD_NUMBER = 21;
    private com.google.protobuf.LazyStringList allowedProcMountTypes_;
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    public com.google.protobuf.ProtocolStringList getAllowedProcMountTypesList() {
      return allowedProcMountTypes_;
    }
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    public int getAllowedProcMountTypesCount() {
      return allowedProcMountTypes_.size();
    }
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    public java.lang.String getAllowedProcMountTypes(int index) {
      return allowedProcMountTypes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
     * Empty or nil indicates that only the DefaultProcMountType may be used.
     * This requires the ProcMountType feature flag to be enabled.
     * +optional
     * </pre>
     *
     * <code>repeated string allowedProcMountTypes = 21;</code>
     */
    public com.google.protobuf.ByteString getAllowedProcMountTypesBytes(int index) {
      return allowedProcMountTypes_.getByteString(index);
    }

    public static final int RUNTIMECLASS_FIELD_NUMBER = 24;
    private io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions runtimeClass_;
    /**
     *
     *
     * <pre>
     * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
     * If this field is omitted, the pod's runtimeClassName field is unrestricted.
     * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
     * </code>
     */
    public boolean hasRuntimeClass() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     *
     *
     * <pre>
     * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
     * If this field is omitted, the pod's runtimeClassName field is unrestricted.
     * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        getRuntimeClass() {
      return runtimeClass_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
              .getDefaultInstance()
          : runtimeClass_;
    }
    /**
     *
     *
     * <pre>
     * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
     * If this field is omitted, the pod's runtimeClassName field is unrestricted.
     * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
     * </code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptionsOrBuilder
        getRuntimeClassOrBuilder() {
      return runtimeClass_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
              .getDefaultInstance()
          : runtimeClass_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBool(1, privileged_);
      }
      for (int i = 0; i < defaultAddCapabilities_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(
            output, 2, defaultAddCapabilities_.getRaw(i));
      }
      for (int i = 0; i < requiredDropCapabilities_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(
            output, 3, requiredDropCapabilities_.getRaw(i));
      }
      for (int i = 0; i < allowedCapabilities_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(
            output, 4, allowedCapabilities_.getRaw(i));
      }
      for (int i = 0; i < volumes_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, volumes_.getRaw(i));
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBool(6, hostNetwork_);
      }
      for (int i = 0; i < hostPorts_.size(); i++) {
        output.writeMessage(7, hostPorts_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(8, hostPID_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(9, hostIPC_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(10, getSeLinux());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(11, getRunAsUser());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeMessage(12, getSupplementalGroups());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(13, getFsGroup());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeBool(14, readOnlyRootFilesystem_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeBool(15, defaultAllowPrivilegeEscalation_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeBool(16, allowPrivilegeEscalation_);
      }
      for (int i = 0; i < allowedHostPaths_.size(); i++) {
        output.writeMessage(17, allowedHostPaths_.get(i));
      }
      for (int i = 0; i < allowedFlexVolumes_.size(); i++) {
        output.writeMessage(18, allowedFlexVolumes_.get(i));
      }
      for (int i = 0; i < allowedUnsafeSysctls_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(
            output, 19, allowedUnsafeSysctls_.getRaw(i));
      }
      for (int i = 0; i < forbiddenSysctls_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 20, forbiddenSysctls_.getRaw(i));
      }
      for (int i = 0; i < allowedProcMountTypes_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(
            output, 21, allowedProcMountTypes_.getRaw(i));
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeMessage(22, getRunAsGroup());
      }
      for (int i = 0; i < allowedCSIDrivers_.size(); i++) {
        output.writeMessage(23, allowedCSIDrivers_.get(i));
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeMessage(24, getRuntimeClass());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, privileged_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < defaultAddCapabilities_.size(); i++) {
          dataSize += computeStringSizeNoTag(defaultAddCapabilities_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDefaultAddCapabilitiesList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < requiredDropCapabilities_.size(); i++) {
          dataSize += computeStringSizeNoTag(requiredDropCapabilities_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getRequiredDropCapabilitiesList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < allowedCapabilities_.size(); i++) {
          dataSize += computeStringSizeNoTag(allowedCapabilities_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAllowedCapabilitiesList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < volumes_.size(); i++) {
          dataSize += computeStringSizeNoTag(volumes_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getVolumesList().size();
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(6, hostNetwork_);
      }
      for (int i = 0; i < hostPorts_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(7, hostPorts_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(8, hostPID_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(9, hostIPC_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(10, getSeLinux());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(11, getRunAsUser());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(12, getSupplementalGroups());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(13, getFsGroup());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(14, readOnlyRootFilesystem_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeBoolSize(
                15, defaultAllowPrivilegeEscalation_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeBoolSize(16, allowPrivilegeEscalation_);
      }
      for (int i = 0; i < allowedHostPaths_.size(); i++) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(17, allowedHostPaths_.get(i));
      }
      for (int i = 0; i < allowedFlexVolumes_.size(); i++) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                18, allowedFlexVolumes_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < allowedUnsafeSysctls_.size(); i++) {
          dataSize += computeStringSizeNoTag(allowedUnsafeSysctls_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getAllowedUnsafeSysctlsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < forbiddenSysctls_.size(); i++) {
          dataSize += computeStringSizeNoTag(forbiddenSysctls_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getForbiddenSysctlsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < allowedProcMountTypes_.size(); i++) {
          dataSize += computeStringSizeNoTag(allowedProcMountTypes_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getAllowedProcMountTypesList().size();
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(22, getRunAsGroup());
      }
      for (int i = 0; i < allowedCSIDrivers_.size(); i++) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(23, allowedCSIDrivers_.get(i));
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(24, getRuntimeClass());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec) obj;

      boolean result = true;
      result = result && (hasPrivileged() == other.hasPrivileged());
      if (hasPrivileged()) {
        result = result && (getPrivileged() == other.getPrivileged());
      }
      result =
          result && getDefaultAddCapabilitiesList().equals(other.getDefaultAddCapabilitiesList());
      result =
          result
              && getRequiredDropCapabilitiesList().equals(other.getRequiredDropCapabilitiesList());
      result = result && getAllowedCapabilitiesList().equals(other.getAllowedCapabilitiesList());
      result = result && getVolumesList().equals(other.getVolumesList());
      result = result && (hasHostNetwork() == other.hasHostNetwork());
      if (hasHostNetwork()) {
        result = result && (getHostNetwork() == other.getHostNetwork());
      }
      result = result && getHostPortsList().equals(other.getHostPortsList());
      result = result && (hasHostPID() == other.hasHostPID());
      if (hasHostPID()) {
        result = result && (getHostPID() == other.getHostPID());
      }
      result = result && (hasHostIPC() == other.hasHostIPC());
      if (hasHostIPC()) {
        result = result && (getHostIPC() == other.getHostIPC());
      }
      result = result && (hasSeLinux() == other.hasSeLinux());
      if (hasSeLinux()) {
        result = result && getSeLinux().equals(other.getSeLinux());
      }
      result = result && (hasRunAsUser() == other.hasRunAsUser());
      if (hasRunAsUser()) {
        result = result && getRunAsUser().equals(other.getRunAsUser());
      }
      result = result && (hasRunAsGroup() == other.hasRunAsGroup());
      if (hasRunAsGroup()) {
        result = result && getRunAsGroup().equals(other.getRunAsGroup());
      }
      result = result && (hasSupplementalGroups() == other.hasSupplementalGroups());
      if (hasSupplementalGroups()) {
        result = result && getSupplementalGroups().equals(other.getSupplementalGroups());
      }
      result = result && (hasFsGroup() == other.hasFsGroup());
      if (hasFsGroup()) {
        result = result && getFsGroup().equals(other.getFsGroup());
      }
      result = result && (hasReadOnlyRootFilesystem() == other.hasReadOnlyRootFilesystem());
      if (hasReadOnlyRootFilesystem()) {
        result = result && (getReadOnlyRootFilesystem() == other.getReadOnlyRootFilesystem());
      }
      result =
          result
              && (hasDefaultAllowPrivilegeEscalation()
                  == other.hasDefaultAllowPrivilegeEscalation());
      if (hasDefaultAllowPrivilegeEscalation()) {
        result =
            result
                && (getDefaultAllowPrivilegeEscalation()
                    == other.getDefaultAllowPrivilegeEscalation());
      }
      result = result && (hasAllowPrivilegeEscalation() == other.hasAllowPrivilegeEscalation());
      if (hasAllowPrivilegeEscalation()) {
        result = result && (getAllowPrivilegeEscalation() == other.getAllowPrivilegeEscalation());
      }
      result = result && getAllowedHostPathsList().equals(other.getAllowedHostPathsList());
      result = result && getAllowedFlexVolumesList().equals(other.getAllowedFlexVolumesList());
      result = result && getAllowedCSIDriversList().equals(other.getAllowedCSIDriversList());
      result = result && getAllowedUnsafeSysctlsList().equals(other.getAllowedUnsafeSysctlsList());
      result = result && getForbiddenSysctlsList().equals(other.getForbiddenSysctlsList());
      result =
          result && getAllowedProcMountTypesList().equals(other.getAllowedProcMountTypesList());
      result = result && (hasRuntimeClass() == other.hasRuntimeClass());
      if (hasRuntimeClass()) {
        result = result && getRuntimeClass().equals(other.getRuntimeClass());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPrivileged()) {
        hash = (37 * hash) + PRIVILEGED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getPrivileged());
      }
      if (getDefaultAddCapabilitiesCount() > 0) {
        hash = (37 * hash) + DEFAULTADDCAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getDefaultAddCapabilitiesList().hashCode();
      }
      if (getRequiredDropCapabilitiesCount() > 0) {
        hash = (37 * hash) + REQUIREDDROPCAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getRequiredDropCapabilitiesList().hashCode();
      }
      if (getAllowedCapabilitiesCount() > 0) {
        hash = (37 * hash) + ALLOWEDCAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedCapabilitiesList().hashCode();
      }
      if (getVolumesCount() > 0) {
        hash = (37 * hash) + VOLUMES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumesList().hashCode();
      }
      if (hasHostNetwork()) {
        hash = (37 * hash) + HOSTNETWORK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getHostNetwork());
      }
      if (getHostPortsCount() > 0) {
        hash = (37 * hash) + HOSTPORTS_FIELD_NUMBER;
        hash = (53 * hash) + getHostPortsList().hashCode();
      }
      if (hasHostPID()) {
        hash = (37 * hash) + HOSTPID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getHostPID());
      }
      if (hasHostIPC()) {
        hash = (37 * hash) + HOSTIPC_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getHostIPC());
      }
      if (hasSeLinux()) {
        hash = (37 * hash) + SELINUX_FIELD_NUMBER;
        hash = (53 * hash) + getSeLinux().hashCode();
      }
      if (hasRunAsUser()) {
        hash = (37 * hash) + RUNASUSER_FIELD_NUMBER;
        hash = (53 * hash) + getRunAsUser().hashCode();
      }
      if (hasRunAsGroup()) {
        hash = (37 * hash) + RUNASGROUP_FIELD_NUMBER;
        hash = (53 * hash) + getRunAsGroup().hashCode();
      }
      if (hasSupplementalGroups()) {
        hash = (37 * hash) + SUPPLEMENTALGROUPS_FIELD_NUMBER;
        hash = (53 * hash) + getSupplementalGroups().hashCode();
      }
      if (hasFsGroup()) {
        hash = (37 * hash) + FSGROUP_FIELD_NUMBER;
        hash = (53 * hash) + getFsGroup().hashCode();
      }
      if (hasReadOnlyRootFilesystem()) {
        hash = (37 * hash) + READONLYROOTFILESYSTEM_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getReadOnlyRootFilesystem());
      }
      if (hasDefaultAllowPrivilegeEscalation()) {
        hash = (37 * hash) + DEFAULTALLOWPRIVILEGEESCALATION_FIELD_NUMBER;
        hash =
            (53 * hash)
                + com.google.protobuf.Internal.hashBoolean(getDefaultAllowPrivilegeEscalation());
      }
      if (hasAllowPrivilegeEscalation()) {
        hash = (37 * hash) + ALLOWPRIVILEGEESCALATION_FIELD_NUMBER;
        hash =
            (53 * hash) + com.google.protobuf.Internal.hashBoolean(getAllowPrivilegeEscalation());
      }
      if (getAllowedHostPathsCount() > 0) {
        hash = (37 * hash) + ALLOWEDHOSTPATHS_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedHostPathsList().hashCode();
      }
      if (getAllowedFlexVolumesCount() > 0) {
        hash = (37 * hash) + ALLOWEDFLEXVOLUMES_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedFlexVolumesList().hashCode();
      }
      if (getAllowedCSIDriversCount() > 0) {
        hash = (37 * hash) + ALLOWEDCSIDRIVERS_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedCSIDriversList().hashCode();
      }
      if (getAllowedUnsafeSysctlsCount() > 0) {
        hash = (37 * hash) + ALLOWEDUNSAFESYSCTLS_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedUnsafeSysctlsList().hashCode();
      }
      if (getForbiddenSysctlsCount() > 0) {
        hash = (37 * hash) + FORBIDDENSYSCTLS_FIELD_NUMBER;
        hash = (53 * hash) + getForbiddenSysctlsList().hashCode();
      }
      if (getAllowedProcMountTypesCount() > 0) {
        hash = (37 * hash) + ALLOWEDPROCMOUNTTYPES_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedProcMountTypesList().hashCode();
      }
      if (hasRuntimeClass()) {
        hash = (37 * hash) + RUNTIMECLASS_FIELD_NUMBER;
        hash = (53 * hash) + getRuntimeClass().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * PodSecurityPolicySpec defines the policy enforced.
     * Deprecated: use PodSecurityPolicySpec from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec)
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getHostPortsFieldBuilder();
          getSeLinuxFieldBuilder();
          getRunAsUserFieldBuilder();
          getRunAsGroupFieldBuilder();
          getSupplementalGroupsFieldBuilder();
          getFsGroupFieldBuilder();
          getAllowedHostPathsFieldBuilder();
          getAllowedFlexVolumesFieldBuilder();
          getAllowedCSIDriversFieldBuilder();
          getRuntimeClassFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        privileged_ = false;
        bitField0_ = (bitField0_ & ~0x00000001);
        defaultAddCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        requiredDropCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        allowedCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        volumes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000010);
        hostNetwork_ = false;
        bitField0_ = (bitField0_ & ~0x00000020);
        if (hostPortsBuilder_ == null) {
          hostPorts_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
        } else {
          hostPortsBuilder_.clear();
        }
        hostPID_ = false;
        bitField0_ = (bitField0_ & ~0x00000080);
        hostIPC_ = false;
        bitField0_ = (bitField0_ & ~0x00000100);
        if (seLinuxBuilder_ == null) {
          seLinux_ = null;
        } else {
          seLinuxBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (runAsUserBuilder_ == null) {
          runAsUser_ = null;
        } else {
          runAsUserBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        if (runAsGroupBuilder_ == null) {
          runAsGroup_ = null;
        } else {
          runAsGroupBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        if (supplementalGroupsBuilder_ == null) {
          supplementalGroups_ = null;
        } else {
          supplementalGroupsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00001000);
        if (fsGroupBuilder_ == null) {
          fsGroup_ = null;
        } else {
          fsGroupBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        readOnlyRootFilesystem_ = false;
        bitField0_ = (bitField0_ & ~0x00004000);
        defaultAllowPrivilegeEscalation_ = false;
        bitField0_ = (bitField0_ & ~0x00008000);
        allowPrivilegeEscalation_ = false;
        bitField0_ = (bitField0_ & ~0x00010000);
        if (allowedHostPathsBuilder_ == null) {
          allowedHostPaths_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00020000);
        } else {
          allowedHostPathsBuilder_.clear();
        }
        if (allowedFlexVolumesBuilder_ == null) {
          allowedFlexVolumes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00040000);
        } else {
          allowedFlexVolumesBuilder_.clear();
        }
        if (allowedCSIDriversBuilder_ == null) {
          allowedCSIDrivers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00080000);
        } else {
          allowedCSIDriversBuilder_.clear();
        }
        allowedUnsafeSysctls_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00100000);
        forbiddenSysctls_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00200000);
        allowedProcMountTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00400000);
        if (runtimeClassBuilder_ == null) {
          runtimeClass_ = null;
        } else {
          runtimeClassBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00800000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.privileged_ = privileged_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          defaultAddCapabilities_ = defaultAddCapabilities_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.defaultAddCapabilities_ = defaultAddCapabilities_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          requiredDropCapabilities_ = requiredDropCapabilities_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.requiredDropCapabilities_ = requiredDropCapabilities_;
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          allowedCapabilities_ = allowedCapabilities_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.allowedCapabilities_ = allowedCapabilities_;
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
          volumes_ = volumes_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.volumes_ = volumes_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000002;
        }
        result.hostNetwork_ = hostNetwork_;
        if (hostPortsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040)) {
            hostPorts_ = java.util.Collections.unmodifiableList(hostPorts_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.hostPorts_ = hostPorts_;
        } else {
          result.hostPorts_ = hostPortsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000004;
        }
        result.hostPID_ = hostPID_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000008;
        }
        result.hostIPC_ = hostIPC_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000010;
        }
        if (seLinuxBuilder_ == null) {
          result.seLinux_ = seLinux_;
        } else {
          result.seLinux_ = seLinuxBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000020;
        }
        if (runAsUserBuilder_ == null) {
          result.runAsUser_ = runAsUser_;
        } else {
          result.runAsUser_ = runAsUserBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000040;
        }
        if (runAsGroupBuilder_ == null) {
          result.runAsGroup_ = runAsGroup_;
        } else {
          result.runAsGroup_ = runAsGroupBuilder_.build();
        }
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00000080;
        }
        if (supplementalGroupsBuilder_ == null) {
          result.supplementalGroups_ = supplementalGroups_;
        } else {
          result.supplementalGroups_ = supplementalGroupsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00000100;
        }
        if (fsGroupBuilder_ == null) {
          result.fsGroup_ = fsGroup_;
        } else {
          result.fsGroup_ = fsGroupBuilder_.build();
        }
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00000200;
        }
        result.readOnlyRootFilesystem_ = readOnlyRootFilesystem_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00000400;
        }
        result.defaultAllowPrivilegeEscalation_ = defaultAllowPrivilegeEscalation_;
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00000800;
        }
        result.allowPrivilegeEscalation_ = allowPrivilegeEscalation_;
        if (allowedHostPathsBuilder_ == null) {
          if (((bitField0_ & 0x00020000) == 0x00020000)) {
            allowedHostPaths_ = java.util.Collections.unmodifiableList(allowedHostPaths_);
            bitField0_ = (bitField0_ & ~0x00020000);
          }
          result.allowedHostPaths_ = allowedHostPaths_;
        } else {
          result.allowedHostPaths_ = allowedHostPathsBuilder_.build();
        }
        if (allowedFlexVolumesBuilder_ == null) {
          if (((bitField0_ & 0x00040000) == 0x00040000)) {
            allowedFlexVolumes_ = java.util.Collections.unmodifiableList(allowedFlexVolumes_);
            bitField0_ = (bitField0_ & ~0x00040000);
          }
          result.allowedFlexVolumes_ = allowedFlexVolumes_;
        } else {
          result.allowedFlexVolumes_ = allowedFlexVolumesBuilder_.build();
        }
        if (allowedCSIDriversBuilder_ == null) {
          if (((bitField0_ & 0x00080000) == 0x00080000)) {
            allowedCSIDrivers_ = java.util.Collections.unmodifiableList(allowedCSIDrivers_);
            bitField0_ = (bitField0_ & ~0x00080000);
          }
          result.allowedCSIDrivers_ = allowedCSIDrivers_;
        } else {
          result.allowedCSIDrivers_ = allowedCSIDriversBuilder_.build();
        }
        if (((bitField0_ & 0x00100000) == 0x00100000)) {
          allowedUnsafeSysctls_ = allowedUnsafeSysctls_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00100000);
        }
        result.allowedUnsafeSysctls_ = allowedUnsafeSysctls_;
        if (((bitField0_ & 0x00200000) == 0x00200000)) {
          forbiddenSysctls_ = forbiddenSysctls_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00200000);
        }
        result.forbiddenSysctls_ = forbiddenSysctls_;
        if (((bitField0_ & 0x00400000) == 0x00400000)) {
          allowedProcMountTypes_ = allowedProcMountTypes_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00400000);
        }
        result.allowedProcMountTypes_ = allowedProcMountTypes_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00001000;
        }
        if (runtimeClassBuilder_ == null) {
          result.runtimeClass_ = runtimeClass_;
        } else {
          result.runtimeClass_ = runtimeClassBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
                .getDefaultInstance()) return this;
        if (other.hasPrivileged()) {
          setPrivileged(other.getPrivileged());
        }
        if (!other.defaultAddCapabilities_.isEmpty()) {
          if (defaultAddCapabilities_.isEmpty()) {
            defaultAddCapabilities_ = other.defaultAddCapabilities_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureDefaultAddCapabilitiesIsMutable();
            defaultAddCapabilities_.addAll(other.defaultAddCapabilities_);
          }
          onChanged();
        }
        if (!other.requiredDropCapabilities_.isEmpty()) {
          if (requiredDropCapabilities_.isEmpty()) {
            requiredDropCapabilities_ = other.requiredDropCapabilities_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureRequiredDropCapabilitiesIsMutable();
            requiredDropCapabilities_.addAll(other.requiredDropCapabilities_);
          }
          onChanged();
        }
        if (!other.allowedCapabilities_.isEmpty()) {
          if (allowedCapabilities_.isEmpty()) {
            allowedCapabilities_ = other.allowedCapabilities_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureAllowedCapabilitiesIsMutable();
            allowedCapabilities_.addAll(other.allowedCapabilities_);
          }
          onChanged();
        }
        if (!other.volumes_.isEmpty()) {
          if (volumes_.isEmpty()) {
            volumes_ = other.volumes_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureVolumesIsMutable();
            volumes_.addAll(other.volumes_);
          }
          onChanged();
        }
        if (other.hasHostNetwork()) {
          setHostNetwork(other.getHostNetwork());
        }
        if (hostPortsBuilder_ == null) {
          if (!other.hostPorts_.isEmpty()) {
            if (hostPorts_.isEmpty()) {
              hostPorts_ = other.hostPorts_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureHostPortsIsMutable();
              hostPorts_.addAll(other.hostPorts_);
            }
            onChanged();
          }
        } else {
          if (!other.hostPorts_.isEmpty()) {
            if (hostPortsBuilder_.isEmpty()) {
              hostPortsBuilder_.dispose();
              hostPortsBuilder_ = null;
              hostPorts_ = other.hostPorts_;
              bitField0_ = (bitField0_ & ~0x00000040);
              hostPortsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getHostPortsFieldBuilder()
                      : null;
            } else {
              hostPortsBuilder_.addAllMessages(other.hostPorts_);
            }
          }
        }
        if (other.hasHostPID()) {
          setHostPID(other.getHostPID());
        }
        if (other.hasHostIPC()) {
          setHostIPC(other.getHostIPC());
        }
        if (other.hasSeLinux()) {
          mergeSeLinux(other.getSeLinux());
        }
        if (other.hasRunAsUser()) {
          mergeRunAsUser(other.getRunAsUser());
        }
        if (other.hasRunAsGroup()) {
          mergeRunAsGroup(other.getRunAsGroup());
        }
        if (other.hasSupplementalGroups()) {
          mergeSupplementalGroups(other.getSupplementalGroups());
        }
        if (other.hasFsGroup()) {
          mergeFsGroup(other.getFsGroup());
        }
        if (other.hasReadOnlyRootFilesystem()) {
          setReadOnlyRootFilesystem(other.getReadOnlyRootFilesystem());
        }
        if (other.hasDefaultAllowPrivilegeEscalation()) {
          setDefaultAllowPrivilegeEscalation(other.getDefaultAllowPrivilegeEscalation());
        }
        if (other.hasAllowPrivilegeEscalation()) {
          setAllowPrivilegeEscalation(other.getAllowPrivilegeEscalation());
        }
        if (allowedHostPathsBuilder_ == null) {
          if (!other.allowedHostPaths_.isEmpty()) {
            if (allowedHostPaths_.isEmpty()) {
              allowedHostPaths_ = other.allowedHostPaths_;
              bitField0_ = (bitField0_ & ~0x00020000);
            } else {
              ensureAllowedHostPathsIsMutable();
              allowedHostPaths_.addAll(other.allowedHostPaths_);
            }
            onChanged();
          }
        } else {
          if (!other.allowedHostPaths_.isEmpty()) {
            if (allowedHostPathsBuilder_.isEmpty()) {
              allowedHostPathsBuilder_.dispose();
              allowedHostPathsBuilder_ = null;
              allowedHostPaths_ = other.allowedHostPaths_;
              bitField0_ = (bitField0_ & ~0x00020000);
              allowedHostPathsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getAllowedHostPathsFieldBuilder()
                      : null;
            } else {
              allowedHostPathsBuilder_.addAllMessages(other.allowedHostPaths_);
            }
          }
        }
        if (allowedFlexVolumesBuilder_ == null) {
          if (!other.allowedFlexVolumes_.isEmpty()) {
            if (allowedFlexVolumes_.isEmpty()) {
              allowedFlexVolumes_ = other.allowedFlexVolumes_;
              bitField0_ = (bitField0_ & ~0x00040000);
            } else {
              ensureAllowedFlexVolumesIsMutable();
              allowedFlexVolumes_.addAll(other.allowedFlexVolumes_);
            }
            onChanged();
          }
        } else {
          if (!other.allowedFlexVolumes_.isEmpty()) {
            if (allowedFlexVolumesBuilder_.isEmpty()) {
              allowedFlexVolumesBuilder_.dispose();
              allowedFlexVolumesBuilder_ = null;
              allowedFlexVolumes_ = other.allowedFlexVolumes_;
              bitField0_ = (bitField0_ & ~0x00040000);
              allowedFlexVolumesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getAllowedFlexVolumesFieldBuilder()
                      : null;
            } else {
              allowedFlexVolumesBuilder_.addAllMessages(other.allowedFlexVolumes_);
            }
          }
        }
        if (allowedCSIDriversBuilder_ == null) {
          if (!other.allowedCSIDrivers_.isEmpty()) {
            if (allowedCSIDrivers_.isEmpty()) {
              allowedCSIDrivers_ = other.allowedCSIDrivers_;
              bitField0_ = (bitField0_ & ~0x00080000);
            } else {
              ensureAllowedCSIDriversIsMutable();
              allowedCSIDrivers_.addAll(other.allowedCSIDrivers_);
            }
            onChanged();
          }
        } else {
          if (!other.allowedCSIDrivers_.isEmpty()) {
            if (allowedCSIDriversBuilder_.isEmpty()) {
              allowedCSIDriversBuilder_.dispose();
              allowedCSIDriversBuilder_ = null;
              allowedCSIDrivers_ = other.allowedCSIDrivers_;
              bitField0_ = (bitField0_ & ~0x00080000);
              allowedCSIDriversBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getAllowedCSIDriversFieldBuilder()
                      : null;
            } else {
              allowedCSIDriversBuilder_.addAllMessages(other.allowedCSIDrivers_);
            }
          }
        }
        if (!other.allowedUnsafeSysctls_.isEmpty()) {
          if (allowedUnsafeSysctls_.isEmpty()) {
            allowedUnsafeSysctls_ = other.allowedUnsafeSysctls_;
            bitField0_ = (bitField0_ & ~0x00100000);
          } else {
            ensureAllowedUnsafeSysctlsIsMutable();
            allowedUnsafeSysctls_.addAll(other.allowedUnsafeSysctls_);
          }
          onChanged();
        }
        if (!other.forbiddenSysctls_.isEmpty()) {
          if (forbiddenSysctls_.isEmpty()) {
            forbiddenSysctls_ = other.forbiddenSysctls_;
            bitField0_ = (bitField0_ & ~0x00200000);
          } else {
            ensureForbiddenSysctlsIsMutable();
            forbiddenSysctls_.addAll(other.forbiddenSysctls_);
          }
          onChanged();
        }
        if (!other.allowedProcMountTypes_.isEmpty()) {
          if (allowedProcMountTypes_.isEmpty()) {
            allowedProcMountTypes_ = other.allowedProcMountTypes_;
            bitField0_ = (bitField0_ & ~0x00400000);
          } else {
            ensureAllowedProcMountTypesIsMutable();
            allowedProcMountTypes_.addAll(other.allowedProcMountTypes_);
          }
          onChanged();
        }
        if (other.hasRuntimeClass()) {
          mergeRuntimeClass(other.getRuntimeClass());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private boolean privileged_;
      /**
       *
       *
       * <pre>
       * privileged determines if a pod can request to be run as privileged.
       * +optional
       * </pre>
       *
       * <code>optional bool privileged = 1;</code>
       */
      public boolean hasPrivileged() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * privileged determines if a pod can request to be run as privileged.
       * +optional
       * </pre>
       *
       * <code>optional bool privileged = 1;</code>
       */
      public boolean getPrivileged() {
        return privileged_;
      }
      /**
       *
       *
       * <pre>
       * privileged determines if a pod can request to be run as privileged.
       * +optional
       * </pre>
       *
       * <code>optional bool privileged = 1;</code>
       */
      public Builder setPrivileged(boolean value) {
        bitField0_ |= 0x00000001;
        privileged_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * privileged determines if a pod can request to be run as privileged.
       * +optional
       * </pre>
       *
       * <code>optional bool privileged = 1;</code>
       */
      public Builder clearPrivileged() {
        bitField0_ = (bitField0_ & ~0x00000001);
        privileged_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList defaultAddCapabilities_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureDefaultAddCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          defaultAddCapabilities_ =
              new com.google.protobuf.LazyStringArrayList(defaultAddCapabilities_);
          bitField0_ |= 0x00000002;
        }
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList getDefaultAddCapabilitiesList() {
        return defaultAddCapabilities_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public int getDefaultAddCapabilitiesCount() {
        return defaultAddCapabilities_.size();
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public java.lang.String getDefaultAddCapabilities(int index) {
        return defaultAddCapabilities_.get(index);
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public com.google.protobuf.ByteString getDefaultAddCapabilitiesBytes(int index) {
        return defaultAddCapabilities_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public Builder setDefaultAddCapabilities(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDefaultAddCapabilitiesIsMutable();
        defaultAddCapabilities_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public Builder addDefaultAddCapabilities(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDefaultAddCapabilitiesIsMutable();
        defaultAddCapabilities_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public Builder addAllDefaultAddCapabilities(java.lang.Iterable<java.lang.String> values) {
        ensureDefaultAddCapabilitiesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, defaultAddCapabilities_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public Builder clearDefaultAddCapabilities() {
        defaultAddCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultAddCapabilities is the default set of capabilities that will be added to the container
       * unless the pod spec specifically drops the capability.  You may not list a capability in both
       * defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
       * allowed, and need not be included in the allowedCapabilities list.
       * +optional
       * </pre>
       *
       * <code>repeated string defaultAddCapabilities = 2;</code>
       */
      public Builder addDefaultAddCapabilitiesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDefaultAddCapabilitiesIsMutable();
        defaultAddCapabilities_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList requiredDropCapabilities_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureRequiredDropCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          requiredDropCapabilities_ =
              new com.google.protobuf.LazyStringArrayList(requiredDropCapabilities_);
          bitField0_ |= 0x00000004;
        }
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public com.google.protobuf.ProtocolStringList getRequiredDropCapabilitiesList() {
        return requiredDropCapabilities_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public int getRequiredDropCapabilitiesCount() {
        return requiredDropCapabilities_.size();
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public java.lang.String getRequiredDropCapabilities(int index) {
        return requiredDropCapabilities_.get(index);
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public com.google.protobuf.ByteString getRequiredDropCapabilitiesBytes(int index) {
        return requiredDropCapabilities_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public Builder setRequiredDropCapabilities(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredDropCapabilitiesIsMutable();
        requiredDropCapabilities_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public Builder addRequiredDropCapabilities(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredDropCapabilitiesIsMutable();
        requiredDropCapabilities_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public Builder addAllRequiredDropCapabilities(java.lang.Iterable<java.lang.String> values) {
        ensureRequiredDropCapabilitiesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, requiredDropCapabilities_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public Builder clearRequiredDropCapabilities() {
        requiredDropCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * requiredDropCapabilities are the capabilities that will be dropped from the container.  These
       * are required to be dropped and cannot be added.
       * +optional
       * </pre>
       *
       * <code>repeated string requiredDropCapabilities = 3;</code>
       */
      public Builder addRequiredDropCapabilitiesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredDropCapabilitiesIsMutable();
        requiredDropCapabilities_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList allowedCapabilities_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureAllowedCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          allowedCapabilities_ = new com.google.protobuf.LazyStringArrayList(allowedCapabilities_);
          bitField0_ |= 0x00000008;
        }
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList getAllowedCapabilitiesList() {
        return allowedCapabilities_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public int getAllowedCapabilitiesCount() {
        return allowedCapabilities_.size();
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public java.lang.String getAllowedCapabilities(int index) {
        return allowedCapabilities_.get(index);
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public com.google.protobuf.ByteString getAllowedCapabilitiesBytes(int index) {
        return allowedCapabilities_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public Builder setAllowedCapabilities(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedCapabilitiesIsMutable();
        allowedCapabilities_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public Builder addAllowedCapabilities(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedCapabilitiesIsMutable();
        allowedCapabilities_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public Builder addAllAllowedCapabilities(java.lang.Iterable<java.lang.String> values) {
        ensureAllowedCapabilitiesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedCapabilities_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public Builder clearAllowedCapabilities() {
        allowedCapabilities_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedCapabilities is a list of capabilities that can be requested to add to the container.
       * Capabilities in this field may be added at the pod author's discretion.
       * You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedCapabilities = 4;</code>
       */
      public Builder addAllowedCapabilitiesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedCapabilitiesIsMutable();
        allowedCapabilities_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList volumes_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureVolumesIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          volumes_ = new com.google.protobuf.LazyStringArrayList(volumes_);
          bitField0_ |= 0x00000010;
        }
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public com.google.protobuf.ProtocolStringList getVolumesList() {
        return volumes_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public int getVolumesCount() {
        return volumes_.size();
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public java.lang.String getVolumes(int index) {
        return volumes_.get(index);
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public com.google.protobuf.ByteString getVolumesBytes(int index) {
        return volumes_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public Builder setVolumes(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVolumesIsMutable();
        volumes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public Builder addVolumes(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVolumesIsMutable();
        volumes_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public Builder addAllVolumes(java.lang.Iterable<java.lang.String> values) {
        ensureVolumesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, volumes_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public Builder clearVolumes() {
        volumes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * volumes is an allowlist of volume plugins. Empty indicates that
       * no volumes may be used. To allow all volumes you may use '*'.
       * +optional
       * </pre>
       *
       * <code>repeated string volumes = 5;</code>
       */
      public Builder addVolumesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVolumesIsMutable();
        volumes_.add(value);
        onChanged();
        return this;
      }

      private boolean hostNetwork_;
      /**
       *
       *
       * <pre>
       * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostNetwork = 6;</code>
       */
      public boolean hasHostNetwork() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       *
       *
       * <pre>
       * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostNetwork = 6;</code>
       */
      public boolean getHostNetwork() {
        return hostNetwork_;
      }
      /**
       *
       *
       * <pre>
       * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostNetwork = 6;</code>
       */
      public Builder setHostNetwork(boolean value) {
        bitField0_ |= 0x00000020;
        hostNetwork_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostNetwork = 6;</code>
       */
      public Builder clearHostNetwork() {
        bitField0_ = (bitField0_ & ~0x00000020);
        hostNetwork_ = false;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange>
          hostPorts_ = java.util.Collections.emptyList();

      private void ensureHostPortsIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          hostPorts_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange>(
                  hostPorts_);
          bitField0_ |= 0x00000040;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRange,
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder>
          hostPortsBuilder_;

      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange>
          getHostPortsList() {
        if (hostPortsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(hostPorts_);
        } else {
          return hostPortsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public int getHostPortsCount() {
        if (hostPortsBuilder_ == null) {
          return hostPorts_.size();
        } else {
          return hostPortsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange getHostPorts(int index) {
        if (hostPortsBuilder_ == null) {
          return hostPorts_.get(index);
        } else {
          return hostPortsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder setHostPorts(
          int index, io.kubernetes.client.proto.V1beta1Extensions.HostPortRange value) {
        if (hostPortsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHostPortsIsMutable();
          hostPorts_.set(index, value);
          onChanged();
        } else {
          hostPortsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder setHostPorts(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder builderForValue) {
        if (hostPortsBuilder_ == null) {
          ensureHostPortsIsMutable();
          hostPorts_.set(index, builderForValue.build());
          onChanged();
        } else {
          hostPortsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder addHostPorts(
          io.kubernetes.client.proto.V1beta1Extensions.HostPortRange value) {
        if (hostPortsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHostPortsIsMutable();
          hostPorts_.add(value);
          onChanged();
        } else {
          hostPortsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder addHostPorts(
          int index, io.kubernetes.client.proto.V1beta1Extensions.HostPortRange value) {
        if (hostPortsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHostPortsIsMutable();
          hostPorts_.add(index, value);
          onChanged();
        } else {
          hostPortsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder addHostPorts(
          io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder builderForValue) {
        if (hostPortsBuilder_ == null) {
          ensureHostPortsIsMutable();
          hostPorts_.add(builderForValue.build());
          onChanged();
        } else {
          hostPortsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder addHostPorts(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder builderForValue) {
        if (hostPortsBuilder_ == null) {
          ensureHostPortsIsMutable();
          hostPorts_.add(index, builderForValue.build());
          onChanged();
        } else {
          hostPortsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder addAllHostPorts(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.HostPortRange>
              values) {
        if (hostPortsBuilder_ == null) {
          ensureHostPortsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, hostPorts_);
          onChanged();
        } else {
          hostPortsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder clearHostPorts() {
        if (hostPortsBuilder_ == null) {
          hostPorts_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          hostPortsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public Builder removeHostPorts(int index) {
        if (hostPortsBuilder_ == null) {
          ensureHostPortsIsMutable();
          hostPorts_.remove(index);
          onChanged();
        } else {
          hostPortsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder getHostPortsBuilder(
          int index) {
        return getHostPortsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder
          getHostPortsOrBuilder(int index) {
        if (hostPortsBuilder_ == null) {
          return hostPorts_.get(index);
        } else {
          return hostPortsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder>
          getHostPortsOrBuilderList() {
        if (hostPortsBuilder_ != null) {
          return hostPortsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(hostPorts_);
        }
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder
          addHostPortsBuilder() {
        return getHostPortsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder addHostPortsBuilder(
          int index) {
        return getHostPortsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * hostPorts determines which host port ranges are allowed to be exposed.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.HostPortRange hostPorts = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder>
          getHostPortsBuilderList() {
        return getHostPortsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRange,
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder>
          getHostPortsFieldBuilder() {
        if (hostPortsBuilder_ == null) {
          hostPortsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.HostPortRange,
                  io.kubernetes.client.proto.V1beta1Extensions.HostPortRange.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.HostPortRangeOrBuilder>(
                  hostPorts_,
                  ((bitField0_ & 0x00000040) == 0x00000040),
                  getParentForChildren(),
                  isClean());
          hostPorts_ = null;
        }
        return hostPortsBuilder_;
      }

      private boolean hostPID_;
      /**
       *
       *
       * <pre>
       * hostPID determines if the policy allows the use of HostPID in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostPID = 8;</code>
       */
      public boolean hasHostPID() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       *
       *
       * <pre>
       * hostPID determines if the policy allows the use of HostPID in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostPID = 8;</code>
       */
      public boolean getHostPID() {
        return hostPID_;
      }
      /**
       *
       *
       * <pre>
       * hostPID determines if the policy allows the use of HostPID in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostPID = 8;</code>
       */
      public Builder setHostPID(boolean value) {
        bitField0_ |= 0x00000080;
        hostPID_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostPID determines if the policy allows the use of HostPID in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostPID = 8;</code>
       */
      public Builder clearHostPID() {
        bitField0_ = (bitField0_ & ~0x00000080);
        hostPID_ = false;
        onChanged();
        return this;
      }

      private boolean hostIPC_;
      /**
       *
       *
       * <pre>
       * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostIPC = 9;</code>
       */
      public boolean hasHostIPC() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       *
       *
       * <pre>
       * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostIPC = 9;</code>
       */
      public boolean getHostIPC() {
        return hostIPC_;
      }
      /**
       *
       *
       * <pre>
       * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostIPC = 9;</code>
       */
      public Builder setHostIPC(boolean value) {
        bitField0_ |= 0x00000100;
        hostIPC_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
       * +optional
       * </pre>
       *
       * <code>optional bool hostIPC = 9;</code>
       */
      public Builder clearHostIPC() {
        bitField0_ = (bitField0_ & ~0x00000100);
        hostIPC_ = false;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions seLinux_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder>
          seLinuxBuilder_;
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public boolean hasSeLinux() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions getSeLinux() {
        if (seLinuxBuilder_ == null) {
          return seLinux_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
                  .getDefaultInstance()
              : seLinux_;
        } else {
          return seLinuxBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public Builder setSeLinux(
          io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions value) {
        if (seLinuxBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          seLinux_ = value;
          onChanged();
        } else {
          seLinuxBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public Builder setSeLinux(
          io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder
              builderForValue) {
        if (seLinuxBuilder_ == null) {
          seLinux_ = builderForValue.build();
          onChanged();
        } else {
          seLinuxBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public Builder mergeSeLinux(
          io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions value) {
        if (seLinuxBuilder_ == null) {
          if (((bitField0_ & 0x00000200) == 0x00000200)
              && seLinux_ != null
              && seLinux_
                  != io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
                      .getDefaultInstance()) {
            seLinux_ =
                io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.newBuilder(
                        seLinux_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            seLinux_ = value;
          }
          onChanged();
        } else {
          seLinuxBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public Builder clearSeLinux() {
        if (seLinuxBuilder_ == null) {
          seLinux_ = null;
          onChanged();
        } else {
          seLinuxBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder
          getSeLinuxBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getSeLinuxFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder
          getSeLinuxOrBuilder() {
        if (seLinuxBuilder_ != null) {
          return seLinuxBuilder_.getMessageOrBuilder();
        } else {
          return seLinux_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
                  .getDefaultInstance()
              : seLinux_;
        }
      }
      /**
       *
       *
       * <pre>
       * seLinux is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions seLinux = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder>
          getSeLinuxFieldBuilder() {
        if (seLinuxBuilder_ == null) {
          seLinuxBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions,
                  io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder>(
                  getSeLinux(), getParentForChildren(), isClean());
          seLinux_ = null;
        }
        return seLinuxBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions runAsUser_ =
          null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder>
          runAsUserBuilder_;
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public boolean hasRunAsUser() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions getRunAsUser() {
        if (runAsUserBuilder_ == null) {
          return runAsUser_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
                  .getDefaultInstance()
              : runAsUser_;
        } else {
          return runAsUserBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public Builder setRunAsUser(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions value) {
        if (runAsUserBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          runAsUser_ = value;
          onChanged();
        } else {
          runAsUserBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public Builder setRunAsUser(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder
              builderForValue) {
        if (runAsUserBuilder_ == null) {
          runAsUser_ = builderForValue.build();
          onChanged();
        } else {
          runAsUserBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public Builder mergeRunAsUser(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions value) {
        if (runAsUserBuilder_ == null) {
          if (((bitField0_ & 0x00000400) == 0x00000400)
              && runAsUser_ != null
              && runAsUser_
                  != io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
                      .getDefaultInstance()) {
            runAsUser_ =
                io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.newBuilder(
                        runAsUser_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            runAsUser_ = value;
          }
          onChanged();
        } else {
          runAsUserBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public Builder clearRunAsUser() {
        if (runAsUserBuilder_ == null) {
          runAsUser_ = null;
          onChanged();
        } else {
          runAsUserBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder
          getRunAsUserBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getRunAsUserFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder
          getRunAsUserOrBuilder() {
        if (runAsUserBuilder_ != null) {
          return runAsUserBuilder_.getMessageOrBuilder();
        } else {
          return runAsUser_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
                  .getDefaultInstance()
              : runAsUser_;
        }
      }
      /**
       *
       *
       * <pre>
       * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions runAsUser = 11;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder>
          getRunAsUserFieldBuilder() {
        if (runAsUserBuilder_ == null) {
          runAsUserBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions,
                  io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder>(
                  getRunAsUser(), getParentForChildren(), isClean());
          runAsUser_ = null;
        }
        return runAsUserBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions runAsGroup_ =
          null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder>
          runAsGroupBuilder_;
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public boolean hasRunAsGroup() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
          getRunAsGroup() {
        if (runAsGroupBuilder_ == null) {
          return runAsGroup_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
                  .getDefaultInstance()
              : runAsGroup_;
        } else {
          return runAsGroupBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public Builder setRunAsGroup(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions value) {
        if (runAsGroupBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          runAsGroup_ = value;
          onChanged();
        } else {
          runAsGroupBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public Builder setRunAsGroup(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder
              builderForValue) {
        if (runAsGroupBuilder_ == null) {
          runAsGroup_ = builderForValue.build();
          onChanged();
        } else {
          runAsGroupBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public Builder mergeRunAsGroup(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions value) {
        if (runAsGroupBuilder_ == null) {
          if (((bitField0_ & 0x00000800) == 0x00000800)
              && runAsGroup_ != null
              && runAsGroup_
                  != io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
                      .getDefaultInstance()) {
            runAsGroup_ =
                io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.newBuilder(
                        runAsGroup_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            runAsGroup_ = value;
          }
          onChanged();
        } else {
          runAsGroupBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public Builder clearRunAsGroup() {
        if (runAsGroupBuilder_ == null) {
          runAsGroup_ = null;
          onChanged();
        } else {
          runAsGroupBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        return this;
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder
          getRunAsGroupBuilder() {
        bitField0_ |= 0x00000800;
        onChanged();
        return getRunAsGroupFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder
          getRunAsGroupOrBuilder() {
        if (runAsGroupBuilder_ != null) {
          return runAsGroupBuilder_.getMessageOrBuilder();
        } else {
          return runAsGroup_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
                  .getDefaultInstance()
              : runAsGroup_;
        }
      }
      /**
       *
       *
       * <pre>
       * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
       * RunAsGroup feature gate to be enabled.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions runAsGroup = 22;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder>
          getRunAsGroupFieldBuilder() {
        if (runAsGroupBuilder_ == null) {
          runAsGroupBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions,
                  io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder>(
                  getRunAsGroup(), getParentForChildren(), isClean());
          runAsGroup_ = null;
        }
        return runAsGroupBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
          supplementalGroups_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                  .Builder,
              io.kubernetes.client.proto.V1beta1Extensions
                  .SupplementalGroupsStrategyOptionsOrBuilder>
          supplementalGroupsBuilder_;
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public boolean hasSupplementalGroups() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
          getSupplementalGroups() {
        if (supplementalGroupsBuilder_ == null) {
          return supplementalGroups_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                  .getDefaultInstance()
              : supplementalGroups_;
        } else {
          return supplementalGroupsBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public Builder setSupplementalGroups(
          io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions value) {
        if (supplementalGroupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          supplementalGroups_ = value;
          onChanged();
        } else {
          supplementalGroupsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public Builder setSupplementalGroups(
          io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions.Builder
              builderForValue) {
        if (supplementalGroupsBuilder_ == null) {
          supplementalGroups_ = builderForValue.build();
          onChanged();
        } else {
          supplementalGroupsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public Builder mergeSupplementalGroups(
          io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions value) {
        if (supplementalGroupsBuilder_ == null) {
          if (((bitField0_ & 0x00001000) == 0x00001000)
              && supplementalGroups_ != null
              && supplementalGroups_
                  != io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                      .getDefaultInstance()) {
            supplementalGroups_ =
                io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                    .newBuilder(supplementalGroups_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            supplementalGroups_ = value;
          }
          onChanged();
        } else {
          supplementalGroupsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public Builder clearSupplementalGroups() {
        if (supplementalGroupsBuilder_ == null) {
          supplementalGroups_ = null;
          onChanged();
        } else {
          supplementalGroupsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00001000);
        return this;
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions.Builder
          getSupplementalGroupsBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getSupplementalGroupsFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptionsOrBuilder
          getSupplementalGroupsOrBuilder() {
        if (supplementalGroupsBuilder_ != null) {
          return supplementalGroupsBuilder_.getMessageOrBuilder();
        } else {
          return supplementalGroups_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                  .getDefaultInstance()
              : supplementalGroups_;
        }
      }
      /**
       *
       *
       * <pre>
       * supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions supplementalGroups = 12;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                  .Builder,
              io.kubernetes.client.proto.V1beta1Extensions
                  .SupplementalGroupsStrategyOptionsOrBuilder>
          getSupplementalGroupsFieldBuilder() {
        if (supplementalGroupsBuilder_ == null) {
          supplementalGroupsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions,
                  io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                      .Builder,
                  io.kubernetes.client.proto.V1beta1Extensions
                      .SupplementalGroupsStrategyOptionsOrBuilder>(
                  getSupplementalGroups(), getParentForChildren(), isClean());
          supplementalGroups_ = null;
        }
        return supplementalGroupsBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions fsGroup_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder>
          fsGroupBuilder_;
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public boolean hasFsGroup() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions getFsGroup() {
        if (fsGroupBuilder_ == null) {
          return fsGroup_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
                  .getDefaultInstance()
              : fsGroup_;
        } else {
          return fsGroupBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public Builder setFsGroup(
          io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions value) {
        if (fsGroupBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fsGroup_ = value;
          onChanged();
        } else {
          fsGroupBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public Builder setFsGroup(
          io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder
              builderForValue) {
        if (fsGroupBuilder_ == null) {
          fsGroup_ = builderForValue.build();
          onChanged();
        } else {
          fsGroupBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public Builder mergeFsGroup(
          io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions value) {
        if (fsGroupBuilder_ == null) {
          if (((bitField0_ & 0x00002000) == 0x00002000)
              && fsGroup_ != null
              && fsGroup_
                  != io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
                      .getDefaultInstance()) {
            fsGroup_ =
                io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.newBuilder(
                        fsGroup_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            fsGroup_ = value;
          }
          onChanged();
        } else {
          fsGroupBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public Builder clearFsGroup() {
        if (fsGroupBuilder_ == null) {
          fsGroup_ = null;
          onChanged();
        } else {
          fsGroupBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        return this;
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder
          getFsGroupBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getFsGroupFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder
          getFsGroupOrBuilder() {
        if (fsGroupBuilder_ != null) {
          return fsGroupBuilder_.getMessageOrBuilder();
        } else {
          return fsGroup_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions
                  .getDefaultInstance()
              : fsGroup_;
        }
      }
      /**
       *
       *
       * <pre>
       * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.FSGroupStrategyOptions fsGroup = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder>
          getFsGroupFieldBuilder() {
        if (fsGroupBuilder_ == null) {
          fsGroupBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions,
                  io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptions.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.FSGroupStrategyOptionsOrBuilder>(
                  getFsGroup(), getParentForChildren(), isClean());
          fsGroup_ = null;
        }
        return fsGroupBuilder_;
      }

      private boolean readOnlyRootFilesystem_;
      /**
       *
       *
       * <pre>
       * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
       * system.  If the container specifically requests to run with a non-read only root file system
       * the PSP should deny the pod.
       * If set to false the container may run with a read only root file system if it wishes but it
       * will not be forced to.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnlyRootFilesystem = 14;</code>
       */
      public boolean hasReadOnlyRootFilesystem() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       *
       *
       * <pre>
       * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
       * system.  If the container specifically requests to run with a non-read only root file system
       * the PSP should deny the pod.
       * If set to false the container may run with a read only root file system if it wishes but it
       * will not be forced to.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnlyRootFilesystem = 14;</code>
       */
      public boolean getReadOnlyRootFilesystem() {
        return readOnlyRootFilesystem_;
      }
      /**
       *
       *
       * <pre>
       * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
       * system.  If the container specifically requests to run with a non-read only root file system
       * the PSP should deny the pod.
       * If set to false the container may run with a read only root file system if it wishes but it
       * will not be forced to.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnlyRootFilesystem = 14;</code>
       */
      public Builder setReadOnlyRootFilesystem(boolean value) {
        bitField0_ |= 0x00004000;
        readOnlyRootFilesystem_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * readOnlyRootFilesystem when set to true will force containers to run with a read only root file
       * system.  If the container specifically requests to run with a non-read only root file system
       * the PSP should deny the pod.
       * If set to false the container may run with a read only root file system if it wishes but it
       * will not be forced to.
       * +optional
       * </pre>
       *
       * <code>optional bool readOnlyRootFilesystem = 14;</code>
       */
      public Builder clearReadOnlyRootFilesystem() {
        bitField0_ = (bitField0_ & ~0x00004000);
        readOnlyRootFilesystem_ = false;
        onChanged();
        return this;
      }

      private boolean defaultAllowPrivilegeEscalation_;
      /**
       *
       *
       * <pre>
       * defaultAllowPrivilegeEscalation controls the default setting for whether a
       * process can gain more privileges than its parent process.
       * +optional
       * </pre>
       *
       * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
       */
      public boolean hasDefaultAllowPrivilegeEscalation() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       *
       *
       * <pre>
       * defaultAllowPrivilegeEscalation controls the default setting for whether a
       * process can gain more privileges than its parent process.
       * +optional
       * </pre>
       *
       * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
       */
      public boolean getDefaultAllowPrivilegeEscalation() {
        return defaultAllowPrivilegeEscalation_;
      }
      /**
       *
       *
       * <pre>
       * defaultAllowPrivilegeEscalation controls the default setting for whether a
       * process can gain more privileges than its parent process.
       * +optional
       * </pre>
       *
       * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
       */
      public Builder setDefaultAllowPrivilegeEscalation(boolean value) {
        bitField0_ |= 0x00008000;
        defaultAllowPrivilegeEscalation_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultAllowPrivilegeEscalation controls the default setting for whether a
       * process can gain more privileges than its parent process.
       * +optional
       * </pre>
       *
       * <code>optional bool defaultAllowPrivilegeEscalation = 15;</code>
       */
      public Builder clearDefaultAllowPrivilegeEscalation() {
        bitField0_ = (bitField0_ & ~0x00008000);
        defaultAllowPrivilegeEscalation_ = false;
        onChanged();
        return this;
      }

      private boolean allowPrivilegeEscalation_;
      /**
       *
       *
       * <pre>
       * allowPrivilegeEscalation determines if a pod can request to allow
       * privilege escalation. If unspecified, defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool allowPrivilegeEscalation = 16;</code>
       */
      public boolean hasAllowPrivilegeEscalation() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       *
       *
       * <pre>
       * allowPrivilegeEscalation determines if a pod can request to allow
       * privilege escalation. If unspecified, defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool allowPrivilegeEscalation = 16;</code>
       */
      public boolean getAllowPrivilegeEscalation() {
        return allowPrivilegeEscalation_;
      }
      /**
       *
       *
       * <pre>
       * allowPrivilegeEscalation determines if a pod can request to allow
       * privilege escalation. If unspecified, defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool allowPrivilegeEscalation = 16;</code>
       */
      public Builder setAllowPrivilegeEscalation(boolean value) {
        bitField0_ |= 0x00010000;
        allowPrivilegeEscalation_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowPrivilegeEscalation determines if a pod can request to allow
       * privilege escalation. If unspecified, defaults to true.
       * +optional
       * </pre>
       *
       * <code>optional bool allowPrivilegeEscalation = 16;</code>
       */
      public Builder clearAllowPrivilegeEscalation() {
        bitField0_ = (bitField0_ & ~0x00010000);
        allowPrivilegeEscalation_ = false;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>
          allowedHostPaths_ = java.util.Collections.emptyList();

      private void ensureAllowedHostPathsIsMutable() {
        if (!((bitField0_ & 0x00020000) == 0x00020000)) {
          allowedHostPaths_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>(
                  allowedHostPaths_);
          bitField0_ |= 0x00020000;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder>
          allowedHostPathsBuilder_;

      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>
          getAllowedHostPathsList() {
        if (allowedHostPathsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(allowedHostPaths_);
        } else {
          return allowedHostPathsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public int getAllowedHostPathsCount() {
        if (allowedHostPathsBuilder_ == null) {
          return allowedHostPaths_.size();
        } else {
          return allowedHostPathsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath getAllowedHostPaths(
          int index) {
        if (allowedHostPathsBuilder_ == null) {
          return allowedHostPaths_.get(index);
        } else {
          return allowedHostPathsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder setAllowedHostPaths(
          int index, io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath value) {
        if (allowedHostPathsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.set(index, value);
          onChanged();
        } else {
          allowedHostPathsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder setAllowedHostPaths(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder builderForValue) {
        if (allowedHostPathsBuilder_ == null) {
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.set(index, builderForValue.build());
          onChanged();
        } else {
          allowedHostPathsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder addAllowedHostPaths(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath value) {
        if (allowedHostPathsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.add(value);
          onChanged();
        } else {
          allowedHostPathsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder addAllowedHostPaths(
          int index, io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath value) {
        if (allowedHostPathsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.add(index, value);
          onChanged();
        } else {
          allowedHostPathsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder addAllowedHostPaths(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder builderForValue) {
        if (allowedHostPathsBuilder_ == null) {
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.add(builderForValue.build());
          onChanged();
        } else {
          allowedHostPathsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder addAllowedHostPaths(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder builderForValue) {
        if (allowedHostPathsBuilder_ == null) {
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.add(index, builderForValue.build());
          onChanged();
        } else {
          allowedHostPathsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder addAllAllowedHostPaths(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath>
              values) {
        if (allowedHostPathsBuilder_ == null) {
          ensureAllowedHostPathsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedHostPaths_);
          onChanged();
        } else {
          allowedHostPathsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder clearAllowedHostPaths() {
        if (allowedHostPathsBuilder_ == null) {
          allowedHostPaths_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00020000);
          onChanged();
        } else {
          allowedHostPathsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public Builder removeAllowedHostPaths(int index) {
        if (allowedHostPathsBuilder_ == null) {
          ensureAllowedHostPathsIsMutable();
          allowedHostPaths_.remove(index);
          onChanged();
        } else {
          allowedHostPathsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder
          getAllowedHostPathsBuilder(int index) {
        return getAllowedHostPathsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder
          getAllowedHostPathsOrBuilder(int index) {
        if (allowedHostPathsBuilder_ == null) {
          return allowedHostPaths_.get(index);
        } else {
          return allowedHostPathsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder>
          getAllowedHostPathsOrBuilderList() {
        if (allowedHostPathsBuilder_ != null) {
          return allowedHostPathsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(allowedHostPaths_);
        }
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder
          addAllowedHostPathsBuilder() {
        return getAllowedHostPathsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder
          addAllowedHostPathsBuilder(int index) {
        return getAllowedHostPathsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * allowedHostPaths is an allowlist of host paths. Empty indicates
       * that all host paths may be used.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedHostPath allowedHostPaths = 17;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder>
          getAllowedHostPathsBuilderList() {
        return getAllowedHostPathsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder>
          getAllowedHostPathsFieldBuilder() {
        if (allowedHostPathsBuilder_ == null) {
          allowedHostPathsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath,
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPath.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedHostPathOrBuilder>(
                  allowedHostPaths_,
                  ((bitField0_ & 0x00020000) == 0x00020000),
                  getParentForChildren(),
                  isClean());
          allowedHostPaths_ = null;
        }
        return allowedHostPathsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>
          allowedFlexVolumes_ = java.util.Collections.emptyList();

      private void ensureAllowedFlexVolumesIsMutable() {
        if (!((bitField0_ & 0x00040000) == 0x00040000)) {
          allowedFlexVolumes_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>(
                  allowedFlexVolumes_);
          bitField0_ |= 0x00040000;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder>
          allowedFlexVolumesBuilder_;

      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>
          getAllowedFlexVolumesList() {
        if (allowedFlexVolumesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(allowedFlexVolumes_);
        } else {
          return allowedFlexVolumesBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public int getAllowedFlexVolumesCount() {
        if (allowedFlexVolumesBuilder_ == null) {
          return allowedFlexVolumes_.size();
        } else {
          return allowedFlexVolumesBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume getAllowedFlexVolumes(
          int index) {
        if (allowedFlexVolumesBuilder_ == null) {
          return allowedFlexVolumes_.get(index);
        } else {
          return allowedFlexVolumesBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder setAllowedFlexVolumes(
          int index, io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume value) {
        if (allowedFlexVolumesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.set(index, value);
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder setAllowedFlexVolumes(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder builderForValue) {
        if (allowedFlexVolumesBuilder_ == null) {
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.set(index, builderForValue.build());
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder addAllowedFlexVolumes(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume value) {
        if (allowedFlexVolumesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.add(value);
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder addAllowedFlexVolumes(
          int index, io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume value) {
        if (allowedFlexVolumesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.add(index, value);
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder addAllowedFlexVolumes(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder builderForValue) {
        if (allowedFlexVolumesBuilder_ == null) {
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.add(builderForValue.build());
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder addAllowedFlexVolumes(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder builderForValue) {
        if (allowedFlexVolumesBuilder_ == null) {
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.add(index, builderForValue.build());
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder addAllAllowedFlexVolumes(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume>
              values) {
        if (allowedFlexVolumesBuilder_ == null) {
          ensureAllowedFlexVolumesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedFlexVolumes_);
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder clearAllowedFlexVolumes() {
        if (allowedFlexVolumesBuilder_ == null) {
          allowedFlexVolumes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00040000);
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public Builder removeAllowedFlexVolumes(int index) {
        if (allowedFlexVolumesBuilder_ == null) {
          ensureAllowedFlexVolumesIsMutable();
          allowedFlexVolumes_.remove(index);
          onChanged();
        } else {
          allowedFlexVolumesBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder
          getAllowedFlexVolumesBuilder(int index) {
        return getAllowedFlexVolumesFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder
          getAllowedFlexVolumesOrBuilder(int index) {
        if (allowedFlexVolumesBuilder_ == null) {
          return allowedFlexVolumes_.get(index);
        } else {
          return allowedFlexVolumesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder>
          getAllowedFlexVolumesOrBuilderList() {
        if (allowedFlexVolumesBuilder_ != null) {
          return allowedFlexVolumesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(allowedFlexVolumes_);
        }
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder
          addAllowedFlexVolumesBuilder() {
        return getAllowedFlexVolumesFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder
          addAllowedFlexVolumesBuilder(int index) {
        return getAllowedFlexVolumesFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all
       * Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
       * is allowed in the "volumes" field.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedFlexVolume allowedFlexVolumes = 18;
       * </code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder>
          getAllowedFlexVolumesBuilderList() {
        return getAllowedFlexVolumesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder>
          getAllowedFlexVolumesFieldBuilder() {
        if (allowedFlexVolumesBuilder_ == null) {
          allowedFlexVolumesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume,
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolume.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedFlexVolumeOrBuilder>(
                  allowedFlexVolumes_,
                  ((bitField0_ & 0x00040000) == 0x00040000),
                  getParentForChildren(),
                  isClean());
          allowedFlexVolumes_ = null;
        }
        return allowedFlexVolumesBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>
          allowedCSIDrivers_ = java.util.Collections.emptyList();

      private void ensureAllowedCSIDriversIsMutable() {
        if (!((bitField0_ & 0x00080000) == 0x00080000)) {
          allowedCSIDrivers_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>(
                  allowedCSIDrivers_);
          bitField0_ |= 0x00080000;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder>
          allowedCSIDriversBuilder_;

      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>
          getAllowedCSIDriversList() {
        if (allowedCSIDriversBuilder_ == null) {
          return java.util.Collections.unmodifiableList(allowedCSIDrivers_);
        } else {
          return allowedCSIDriversBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public int getAllowedCSIDriversCount() {
        if (allowedCSIDriversBuilder_ == null) {
          return allowedCSIDrivers_.size();
        } else {
          return allowedCSIDriversBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver getAllowedCSIDrivers(
          int index) {
        if (allowedCSIDriversBuilder_ == null) {
          return allowedCSIDrivers_.get(index);
        } else {
          return allowedCSIDriversBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder setAllowedCSIDrivers(
          int index, io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver value) {
        if (allowedCSIDriversBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.set(index, value);
          onChanged();
        } else {
          allowedCSIDriversBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder setAllowedCSIDrivers(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder builderForValue) {
        if (allowedCSIDriversBuilder_ == null) {
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.set(index, builderForValue.build());
          onChanged();
        } else {
          allowedCSIDriversBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder addAllowedCSIDrivers(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver value) {
        if (allowedCSIDriversBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.add(value);
          onChanged();
        } else {
          allowedCSIDriversBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder addAllowedCSIDrivers(
          int index, io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver value) {
        if (allowedCSIDriversBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.add(index, value);
          onChanged();
        } else {
          allowedCSIDriversBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder addAllowedCSIDrivers(
          io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder builderForValue) {
        if (allowedCSIDriversBuilder_ == null) {
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.add(builderForValue.build());
          onChanged();
        } else {
          allowedCSIDriversBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder addAllowedCSIDrivers(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder builderForValue) {
        if (allowedCSIDriversBuilder_ == null) {
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.add(index, builderForValue.build());
          onChanged();
        } else {
          allowedCSIDriversBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder addAllAllowedCSIDrivers(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver>
              values) {
        if (allowedCSIDriversBuilder_ == null) {
          ensureAllowedCSIDriversIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedCSIDrivers_);
          onChanged();
        } else {
          allowedCSIDriversBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder clearAllowedCSIDrivers() {
        if (allowedCSIDriversBuilder_ == null) {
          allowedCSIDrivers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00080000);
          onChanged();
        } else {
          allowedCSIDriversBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public Builder removeAllowedCSIDrivers(int index) {
        if (allowedCSIDriversBuilder_ == null) {
          ensureAllowedCSIDriversIsMutable();
          allowedCSIDrivers_.remove(index);
          onChanged();
        } else {
          allowedCSIDriversBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder
          getAllowedCSIDriversBuilder(int index) {
        return getAllowedCSIDriversFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder
          getAllowedCSIDriversOrBuilder(int index) {
        if (allowedCSIDriversBuilder_ == null) {
          return allowedCSIDrivers_.get(index);
        } else {
          return allowedCSIDriversBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder>
          getAllowedCSIDriversOrBuilderList() {
        if (allowedCSIDriversBuilder_ != null) {
          return allowedCSIDriversBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(allowedCSIDrivers_);
        }
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder
          addAllowedCSIDriversBuilder() {
        return getAllowedCSIDriversFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder
          addAllowedCSIDriversBuilder(int index) {
        return getAllowedCSIDriversFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
       * An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.AllowedCSIDriver allowedCSIDrivers = 23;
       * </code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder>
          getAllowedCSIDriversBuilderList() {
        return getAllowedCSIDriversFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder>
          getAllowedCSIDriversFieldBuilder() {
        if (allowedCSIDriversBuilder_ == null) {
          allowedCSIDriversBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver,
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriver.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.AllowedCSIDriverOrBuilder>(
                  allowedCSIDrivers_,
                  ((bitField0_ & 0x00080000) == 0x00080000),
                  getParentForChildren(),
                  isClean());
          allowedCSIDrivers_ = null;
        }
        return allowedCSIDriversBuilder_;
      }

      private com.google.protobuf.LazyStringList allowedUnsafeSysctls_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureAllowedUnsafeSysctlsIsMutable() {
        if (!((bitField0_ & 0x00100000) == 0x00100000)) {
          allowedUnsafeSysctls_ =
              new com.google.protobuf.LazyStringArrayList(allowedUnsafeSysctls_);
          bitField0_ |= 0x00100000;
        }
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public com.google.protobuf.ProtocolStringList getAllowedUnsafeSysctlsList() {
        return allowedUnsafeSysctls_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public int getAllowedUnsafeSysctlsCount() {
        return allowedUnsafeSysctls_.size();
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public java.lang.String getAllowedUnsafeSysctls(int index) {
        return allowedUnsafeSysctls_.get(index);
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public com.google.protobuf.ByteString getAllowedUnsafeSysctlsBytes(int index) {
        return allowedUnsafeSysctls_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public Builder setAllowedUnsafeSysctls(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedUnsafeSysctlsIsMutable();
        allowedUnsafeSysctls_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public Builder addAllowedUnsafeSysctls(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedUnsafeSysctlsIsMutable();
        allowedUnsafeSysctls_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public Builder addAllAllowedUnsafeSysctls(java.lang.Iterable<java.lang.String> values) {
        ensureAllowedUnsafeSysctlsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedUnsafeSysctls_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public Builder clearAllowedUnsafeSysctls() {
        allowedUnsafeSysctls_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00100000);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
       * Kubelet has to allowlist all unsafe sysctls explicitly to avoid rejection.
       * Examples:
       * e.g. "foo/&#42;" allows "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedUnsafeSysctls = 19;</code>
       */
      public Builder addAllowedUnsafeSysctlsBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedUnsafeSysctlsIsMutable();
        allowedUnsafeSysctls_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList forbiddenSysctls_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureForbiddenSysctlsIsMutable() {
        if (!((bitField0_ & 0x00200000) == 0x00200000)) {
          forbiddenSysctls_ = new com.google.protobuf.LazyStringArrayList(forbiddenSysctls_);
          bitField0_ |= 0x00200000;
        }
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public com.google.protobuf.ProtocolStringList getForbiddenSysctlsList() {
        return forbiddenSysctls_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public int getForbiddenSysctlsCount() {
        return forbiddenSysctls_.size();
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public java.lang.String getForbiddenSysctls(int index) {
        return forbiddenSysctls_.get(index);
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public com.google.protobuf.ByteString getForbiddenSysctlsBytes(int index) {
        return forbiddenSysctls_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public Builder setForbiddenSysctls(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureForbiddenSysctlsIsMutable();
        forbiddenSysctls_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public Builder addForbiddenSysctls(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureForbiddenSysctlsIsMutable();
        forbiddenSysctls_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public Builder addAllForbiddenSysctls(java.lang.Iterable<java.lang.String> values) {
        ensureForbiddenSysctlsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, forbiddenSysctls_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public Builder clearForbiddenSysctls() {
        forbiddenSysctls_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00200000);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
       * Each entry is either a plain sysctl name or ends in "*" in which case it is considered
       * as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
       * Examples:
       * e.g. "foo/&#42;" forbids "foo/bar", "foo/baz", etc.
       * e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
       * +optional
       * </pre>
       *
       * <code>repeated string forbiddenSysctls = 20;</code>
       */
      public Builder addForbiddenSysctlsBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureForbiddenSysctlsIsMutable();
        forbiddenSysctls_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList allowedProcMountTypes_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureAllowedProcMountTypesIsMutable() {
        if (!((bitField0_ & 0x00400000) == 0x00400000)) {
          allowedProcMountTypes_ =
              new com.google.protobuf.LazyStringArrayList(allowedProcMountTypes_);
          bitField0_ |= 0x00400000;
        }
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public com.google.protobuf.ProtocolStringList getAllowedProcMountTypesList() {
        return allowedProcMountTypes_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public int getAllowedProcMountTypesCount() {
        return allowedProcMountTypes_.size();
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public java.lang.String getAllowedProcMountTypes(int index) {
        return allowedProcMountTypes_.get(index);
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public com.google.protobuf.ByteString getAllowedProcMountTypesBytes(int index) {
        return allowedProcMountTypes_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public Builder setAllowedProcMountTypes(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedProcMountTypesIsMutable();
        allowedProcMountTypes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public Builder addAllowedProcMountTypes(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedProcMountTypesIsMutable();
        allowedProcMountTypes_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public Builder addAllAllowedProcMountTypes(java.lang.Iterable<java.lang.String> values) {
        ensureAllowedProcMountTypesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedProcMountTypes_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public Builder clearAllowedProcMountTypes() {
        allowedProcMountTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00400000);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * AllowedProcMountTypes is an allowlist of allowed ProcMountTypes.
       * Empty or nil indicates that only the DefaultProcMountType may be used.
       * This requires the ProcMountType feature flag to be enabled.
       * +optional
       * </pre>
       *
       * <code>repeated string allowedProcMountTypes = 21;</code>
       */
      public Builder addAllowedProcMountTypesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedProcMountTypesIsMutable();
        allowedProcMountTypes_.add(value);
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
          runtimeClass_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptionsOrBuilder>
          runtimeClassBuilder_;
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public boolean hasRuntimeClass() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
          getRuntimeClass() {
        if (runtimeClassBuilder_ == null) {
          return runtimeClass_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
                  .getDefaultInstance()
              : runtimeClass_;
        } else {
          return runtimeClassBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public Builder setRuntimeClass(
          io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions value) {
        if (runtimeClassBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          runtimeClass_ = value;
          onChanged();
        } else {
          runtimeClassBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00800000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public Builder setRuntimeClass(
          io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder
              builderForValue) {
        if (runtimeClassBuilder_ == null) {
          runtimeClass_ = builderForValue.build();
          onChanged();
        } else {
          runtimeClassBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00800000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public Builder mergeRuntimeClass(
          io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions value) {
        if (runtimeClassBuilder_ == null) {
          if (((bitField0_ & 0x00800000) == 0x00800000)
              && runtimeClass_ != null
              && runtimeClass_
                  != io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
                      .getDefaultInstance()) {
            runtimeClass_ =
                io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.newBuilder(
                        runtimeClass_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            runtimeClass_ = value;
          }
          onChanged();
        } else {
          runtimeClassBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00800000;
        return this;
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public Builder clearRuntimeClass() {
        if (runtimeClassBuilder_ == null) {
          runtimeClass_ = null;
          onChanged();
        } else {
          runtimeClassBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00800000);
        return this;
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder
          getRuntimeClassBuilder() {
        bitField0_ |= 0x00800000;
        onChanged();
        return getRuntimeClassFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptionsOrBuilder
          getRuntimeClassOrBuilder() {
        if (runtimeClassBuilder_ != null) {
          return runtimeClassBuilder_.getMessageOrBuilder();
        } else {
          return runtimeClass_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
                  .getDefaultInstance()
              : runtimeClass_;
        }
      }
      /**
       *
       *
       * <pre>
       * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
       * If this field is omitted, the pod's runtimeClassName field is unrestricted.
       * Enforcement of this field depends on the RuntimeClass feature gate being enabled.
       * +optional
       * </pre>
       *
       * <code>
       * optional .k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions runtimeClass = 24;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions,
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptionsOrBuilder>
          getRuntimeClassFieldBuilder() {
        if (runtimeClassBuilder_ == null) {
          runtimeClassBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions,
                  io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions
                      .RuntimeClassStrategyOptionsOrBuilder>(
                  getRuntimeClass(), getParentForChildren(), isClean());
          runtimeClass_ = null;
        }
        return runtimeClassBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.PodSecurityPolicySpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<PodSecurityPolicySpec> PARSER =
        new com.google.protobuf.AbstractParser<PodSecurityPolicySpec>() {
          @java.lang.Override
          public PodSecurityPolicySpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new PodSecurityPolicySpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<PodSecurityPolicySpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PodSecurityPolicySpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.PodSecurityPolicySpec
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ReplicaSetOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ReplicaSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec getSpec();
    /**
     *
     *
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder getSpecOrBuilder();

    /**
     *
     *
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus getStatus();
    /**
     *
     *
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder getStatusOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for
   * more information.
   * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSet}
   */
  public static final class ReplicaSet extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ReplicaSet)
      ReplicaSetOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReplicaSet.newBuilder() to construct.
    private ReplicaSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReplicaSet() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReplicaSet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder subBuilder =
                    null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = status_.toBuilder();
                }
                status_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(status_);
                  status_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.class,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * If the Labels of a ReplicaSet are empty, they are defaulted to
     * be the same as the Pod(s) that the ReplicaSet manages.
     * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec spec_;
    /**
     *
     *
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * Spec defines the specification of the desired behavior of the ReplicaSet.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.getDefaultInstance()
          : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus status_;
    /**
     *
     *
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus getStatus() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.getDefaultInstance()
          : status_;
    }
    /**
     *
     *
     * <pre>
     * Status is the most recently observed status of the ReplicaSet.
     * This data may be out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder
        getStatusOrBuilder() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.getDefaultInstance()
          : status_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet other =
          (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for
     * more information.
     * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSet}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ReplicaSet)
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.class,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet build() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet result =
            new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * If the Labels of a ReplicaSet are empty, they are defaulted to
       * be the same as the Pod(s) that the ReplicaSet manages.
       * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec
                      .getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder
          getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * Spec defines the specification of the desired behavior of the ReplicaSet.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder>
          statusBuilder_;
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.getDefaultInstance()
              : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public Builder mergeStatus(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && status_ != null
              && status_
                  != io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus
                      .getDefaultInstance()) {
            status_ =
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.newBuilder(status_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder
          getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder
          getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.getDefaultInstance()
              : status_;
        }
      }
      /**
       *
       *
       * <pre>
       * Status is the most recently observed status of the ReplicaSet.
       * This data may be out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ReplicaSetStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder>
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder>(
                  getStatus(), getParentForChildren(), isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ReplicaSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ReplicaSet)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ReplicaSet> PARSER =
        new com.google.protobuf.AbstractParser<ReplicaSet>() {
          @java.lang.Override
          public ReplicaSet parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReplicaSet(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReplicaSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ReplicaSetConditionOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ReplicaSetCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     *
     *
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     *
     *
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString getTypeBytes();

    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    java.lang.String getStatus();
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    com.google.protobuf.ByteString getStatusBytes();

    /**
     *
     *
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    boolean hasLastTransitionTime();
    /**
     *
     *
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Time getLastTransitionTime();
    /**
     *
     *
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder();

    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    boolean hasReason();
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    java.lang.String getReason();
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    com.google.protobuf.ByteString getReasonBytes();

    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    boolean hasMessage();
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    java.lang.String getMessage();
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    com.google.protobuf.ByteString getMessageBytes();
  }
  /**
   *
   *
   * <pre>
   * ReplicaSetCondition describes the state of a replica set at a certain point.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetCondition}
   */
  public static final class ReplicaSetCondition extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ReplicaSetCondition)
      ReplicaSetConditionOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReplicaSetCondition.newBuilder() to construct.
    private ReplicaSetCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReplicaSetCondition() {
      type_ = "";
      status_ = "";
      reason_ = "";
      message_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReplicaSetCondition(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                type_ = bs;
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000002;
                status_ = bs;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.Meta.Time.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = lastTransitionTime_.toBuilder();
                }
                lastTransitionTime_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.Time.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(lastTransitionTime_);
                  lastTransitionTime_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 34:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000008;
                reason_ = bs;
                break;
              }
            case 42:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000010;
                message_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.class,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     *
     *
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Type of replica set condition.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private volatile java.lang.Object status_;
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public java.lang.String getStatus() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          status_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * Status of the condition, one of True, False, Unknown.
     * </pre>
     *
     * <code>optional string status = 2;</code>
     */
    public com.google.protobuf.ByteString getStatusBytes() {
      java.lang.Object ref = status_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LASTTRANSITIONTIME_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.Time lastTransitionTime_;
    /**
     *
     *
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    public boolean hasLastTransitionTime() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
      return lastTransitionTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastTransitionTime_;
    }
    /**
     *
     *
     * <pre>
     * The last time the condition transitioned from one status to another.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
      return lastTransitionTime_ == null
          ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
          : lastTransitionTime_;
    }

    public static final int REASON_FIELD_NUMBER = 4;
    private volatile java.lang.Object reason_;
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public boolean hasReason() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * The reason for the condition's last transition.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 4;</code>
     */
    public com.google.protobuf.ByteString getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 5;
    private volatile java.lang.Object message_;
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * A human readable message indicating details about the transition.
     * +optional
     * </pre>
     *
     * <code>optional string message = 5;</code>
     */
    public com.google.protobuf.ByteString getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, status_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, reason_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, message_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, status_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(3, getLastTransitionTime());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, reason_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, message_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition other =
          (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType().equals(other.getType());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && (hasLastTransitionTime() == other.hasLastTransitionTime());
      if (hasLastTransitionTime()) {
        result = result && getLastTransitionTime().equals(other.getLastTransitionTime());
      }
      result = result && (hasReason() == other.hasReason());
      if (hasReason()) {
        result = result && getReason().equals(other.getReason());
      }
      result = result && (hasMessage() == other.hasMessage());
      if (hasMessage()) {
        result = result && getMessage().equals(other.getMessage());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      if (hasLastTransitionTime()) {
        hash = (37 * hash) + LASTTRANSITIONTIME_FIELD_NUMBER;
        hash = (53 * hash) + getLastTransitionTime().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * ReplicaSetCondition describes the state of a replica set at a certain point.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetCondition}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ReplicaSetCondition)
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.class,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getLastTransitionTimeFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        status_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        reason_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition build() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition result =
            new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.status_ = status_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (lastTransitionTimeBuilder_ == null) {
          result.lastTransitionTime_ = lastTransitionTime_;
        } else {
          result.lastTransitionTime_ = lastTransitionTimeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.reason_ = reason_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.message_ = message_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
                .getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasStatus()) {
          bitField0_ |= 0x00000002;
          status_ = other.status_;
          onChanged();
        }
        if (other.hasLastTransitionTime()) {
          mergeLastTransitionTime(other.getLastTransitionTime());
        }
        if (other.hasReason()) {
          bitField0_ |= 0x00000008;
          reason_ = other.reason_;
          onChanged();
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000010;
          message_ = other.message_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       *
       *
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Type of replica set condition.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object status_ = "";
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public java.lang.String getStatus() {
        java.lang.Object ref = status_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            status_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public com.google.protobuf.ByteString getStatusBytes() {
        java.lang.Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatus(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = getDefaultInstance().getStatus();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Status of the condition, one of True, False, Unknown.
       * </pre>
       *
       * <code>optional string status = 2;</code>
       */
      public Builder setStatusBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.Time lastTransitionTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          lastTransitionTimeBuilder_;
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public boolean hasLastTransitionTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time getLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          return lastTransitionTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastTransitionTime_;
        } else {
          return lastTransitionTimeBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          lastTransitionTime_ = value;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder setLastTransitionTime(
          io.kubernetes.client.proto.Meta.Time.Builder builderForValue) {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = builderForValue.build();
          onChanged();
        } else {
          lastTransitionTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder mergeLastTransitionTime(io.kubernetes.client.proto.Meta.Time value) {
        if (lastTransitionTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && lastTransitionTime_ != null
              && lastTransitionTime_ != io.kubernetes.client.proto.Meta.Time.getDefaultInstance()) {
            lastTransitionTime_ =
                io.kubernetes.client.proto.Meta.Time.newBuilder(lastTransitionTime_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            lastTransitionTime_ = value;
          }
          onChanged();
        } else {
          lastTransitionTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public Builder clearLastTransitionTime() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTime_ = null;
          onChanged();
        } else {
          lastTransitionTimeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Time.Builder getLastTransitionTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getLastTransitionTimeFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.TimeOrBuilder getLastTransitionTimeOrBuilder() {
        if (lastTransitionTimeBuilder_ != null) {
          return lastTransitionTimeBuilder_.getMessageOrBuilder();
        } else {
          return lastTransitionTime_ == null
              ? io.kubernetes.client.proto.Meta.Time.getDefaultInstance()
              : lastTransitionTime_;
        }
      }
      /**
       *
       *
       * <pre>
       * The last time the condition transitioned from one status to another.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Time,
              io.kubernetes.client.proto.Meta.Time.Builder,
              io.kubernetes.client.proto.Meta.TimeOrBuilder>
          getLastTransitionTimeFieldBuilder() {
        if (lastTransitionTimeBuilder_ == null) {
          lastTransitionTimeBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.Time,
                  io.kubernetes.client.proto.Meta.Time.Builder,
                  io.kubernetes.client.proto.Meta.TimeOrBuilder>(
                  getLastTransitionTime(), getParentForChildren(), isClean());
          lastTransitionTime_ = null;
        }
        return lastTransitionTimeBuilder_;
      }

      private java.lang.Object reason_ = "";
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public com.google.protobuf.ByteString getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder setReason(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        reason_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000008);
        reason_ = getDefaultInstance().getReason();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The reason for the condition's last transition.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 4;</code>
       */
      public Builder setReasonBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        reason_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public com.google.protobuf.ByteString getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder setMessage(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000010);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * A human readable message indicating details about the transition.
       * +optional
       * </pre>
       *
       * <code>optional string message = 5;</code>
       */
      public Builder setMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        message_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ReplicaSetCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ReplicaSetCondition)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ReplicaSetCondition> PARSER =
        new com.google.protobuf.AbstractParser<ReplicaSetCondition>() {
          @java.lang.Override
          public ReplicaSetCondition parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReplicaSetCondition(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReplicaSetCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ReplicaSetListOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ReplicaSetList)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet> getItemsList();
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet getItems(int index);
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    int getItemsCount();
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder>
        getItemsOrBuilderList();
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder getItemsOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * ReplicaSetList is a collection of ReplicaSets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetList}
   */
  public static final class ReplicaSetList extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ReplicaSetList)
      ReplicaSetListOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReplicaSetList.newBuilder() to construct.
    private ReplicaSetList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReplicaSetList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReplicaSetList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  items_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet>();
                  mutable_bitField0_ |= 0x00000002;
                }
                items_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.class,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet> items_;
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet> getItemsList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder>
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet getItems(int index) {
      return items_.get(index);
    }
    /**
     *
     *
     * <pre>
     * List of ReplicaSets.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList other =
          (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && getItemsList().equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * ReplicaSetList is a collection of ReplicaSets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetList}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ReplicaSetList)
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.class,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList build() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList result =
            new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getItemsFieldBuilder()
                      : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta,
              io.kubernetes.client.proto.Meta.ListMeta.Builder,
              io.kubernetes.client.proto.Meta.ListMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ListMeta,
                  io.kubernetes.client.proto.Meta.ListMeta.Builder,
                  io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet> items_ =
          java.util.Collections.emptyList();

      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet>(
                  items_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder>
          itemsBuilder_;

      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet>
          getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder setItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder addItems(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet>
              values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder>
          getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder addItemsBuilder() {
        return getItemsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * List of ReplicaSets.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder>
          getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder>
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSet.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ReplicaSetList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ReplicaSetList)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ReplicaSetList> PARSER =
        new com.google.protobuf.AbstractParser<ReplicaSetList>() {
          @java.lang.Override
          public ReplicaSetList parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReplicaSetList(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReplicaSetList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ReplicaSetSpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ReplicaSetSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    boolean hasReplicas();
    /**
     *
     *
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    int getReplicas();

    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    boolean hasMinReadySeconds();
    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    int getMinReadySeconds();

    /**
     *
     *
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * If the selector is empty, it is defaulted to the labels present on the pod template.
     * Label keys and values that must match in order to be controlled by this replica set.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    boolean hasSelector();
    /**
     *
     *
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * If the selector is empty, it is defaulted to the labels present on the pod template.
     * Label keys and values that must match in order to be controlled by this replica set.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     *
     *
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * If the selector is empty, it is defaulted to the labels present on the pod template.
     * Label keys and values that must match in order to be controlled by this replica set.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     *
     *
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    boolean hasTemplate();
    /**
     *
     *
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     *
     *
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * ReplicaSetSpec is the specification of a ReplicaSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetSpec}
   */
  public static final class ReplicaSetSpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ReplicaSetSpec)
      ReplicaSetSpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReplicaSetSpec.newBuilder() to construct.
    private ReplicaSetSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReplicaSetSpec() {
      replicas_ = 0;
      minReadySeconds_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReplicaSetSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                replicas_ = input.readInt32();
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = selector_.toBuilder();
                }
                selector_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(selector_);
                  selector_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1.PodTemplateSpec.Builder subBuilder = null;
                if (((bitField0_ & 0x00000008) == 0x00000008)) {
                  subBuilder = template_.toBuilder();
                }
                template_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.PodTemplateSpec.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(template_);
                  template_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000008;
                break;
              }
            case 32:
              {
                bitField0_ |= 0x00000002;
                minReadySeconds_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_;
    /**
     *
     *
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Replicas is the number of desired replicas.
     * This is a pointer to distinguish between explicit zero and unspecified.
     * Defaults to 1.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public int getReplicas() {
      return replicas_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 4;
    private int minReadySeconds_;
    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * Minimum number of seconds for which a newly created pod should be ready
     * without any of its container crashing, for it to be considered available.
     * Defaults to 0 (pod will be considered available as soon as it is ready)
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     *
     *
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * If the selector is empty, it is defaulted to the labels present on the pod template.
     * Label keys and values that must match in order to be controlled by this replica set.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * If the selector is empty, it is defaulted to the labels present on the pod template.
     * Label keys and values that must match in order to be controlled by this replica set.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : selector_;
    }
    /**
     *
     *
     * <pre>
     * Selector is a label query over pods that should match the replica count.
     * If the selector is empty, it is defaulted to the labels present on the pod template.
     * Label keys and values that must match in order to be controlled by this replica set.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null
          ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
          : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     *
     *
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null
          ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
          : template_;
    }
    /**
     *
     *
     * <pre>
     * Template is the object that describes the pod that will be created if
     * insufficient replicas are detected.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null
          ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
          : template_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(2, getSelector());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(3, getTemplate());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(4, minReadySeconds_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSelector());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getTemplate());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, minReadySeconds_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec) obj;

      boolean result = true;
      result = result && (hasReplicas() == other.hasReplicas());
      if (hasReplicas()) {
        result = result && (getReplicas() == other.getReplicas());
      }
      result = result && (hasMinReadySeconds() == other.hasMinReadySeconds());
      if (hasMinReadySeconds()) {
        result = result && (getMinReadySeconds() == other.getMinReadySeconds());
      }
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector().equals(other.getSelector());
      }
      result = result && (hasTemplate() == other.hasTemplate());
      if (hasTemplate()) {
        result = result && getTemplate().equals(other.getTemplate());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * ReplicaSetSpec is the specification of a ReplicaSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetSpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ReplicaSetSpec)
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        replicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        minReadySeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (templateBuilder_ == null) {
          template_ = null;
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.replicas_ = replicas_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.minReadySeconds_ = minReadySeconds_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (templateBuilder_ == null) {
          result.template_ = template_;
        } else {
          result.template_ = templateBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec.getDefaultInstance())
          return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int replicas_;
      /**
       *
       *
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public int getReplicas() {
        return replicas_;
      }
      /**
       *
       *
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder setReplicas(int value) {
        bitField0_ |= 0x00000001;
        replicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Replicas is the number of desired replicas.
       * This is a pointer to distinguish between explicit zero and unspecified.
       * Defaults to 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int minReadySeconds_;
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public Builder setMinReadySeconds(int value) {
        bitField0_ |= 0x00000002;
        minReadySeconds_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Minimum number of seconds for which a newly created pod should be ready
       * without any of its container crashing, for it to be considered available.
       * Defaults to 0 (pod will be considered available as soon as it is ready)
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000002);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          selectorBuilder_;
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && selector_ != null
              && selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
                io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null
              ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()
              : selector_;
        }
      }
      /**
       *
       *
       * <pre>
       * Selector is a label query over pods that should match the replica count.
       * If the selector is empty, it is defaulted to the labels present on the pod template.
       * Label keys and values that must match in order to be controlled by this replica set.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector,
              io.kubernetes.client.proto.Meta.LabelSelector.Builder,
              io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.LabelSelector,
                  io.kubernetes.client.proto.Meta.LabelSelector.Builder,
                  io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(), getParentForChildren(), isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec,
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
              io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>
          templateBuilder_;
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null
              ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
              : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
          onChanged();
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
          onChanged();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)
              && template_ != null
              && template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            template_ =
                io.kubernetes.client.proto.V1.PodTemplateSpec.newBuilder(template_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            template_ = value;
          }
          onChanged();
        } else {
          templateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public Builder clearTemplate() {
        if (templateBuilder_ == null) {
          template_ = null;
          onChanged();
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null
              ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()
              : template_;
        }
      }
      /**
       *
       *
       * <pre>
       * Template is the object that describes the pod that will be created if
       * insufficient replicas are detected.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec,
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
              io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1.PodTemplateSpec,
                  io.kubernetes.client.proto.V1.PodTemplateSpec.Builder,
                  io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(), getParentForChildren(), isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ReplicaSetSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ReplicaSetSpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ReplicaSetSpec> PARSER =
        new com.google.protobuf.AbstractParser<ReplicaSetSpec>() {
          @java.lang.Override
          public ReplicaSetSpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReplicaSetSpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReplicaSetSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ReplicaSetStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ReplicaSetStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Replicas is the most recently oberved number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    boolean hasReplicas();
    /**
     *
     *
     * <pre>
     * Replicas is the most recently oberved number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    int getReplicas();

    /**
     *
     *
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     */
    boolean hasFullyLabeledReplicas();
    /**
     *
     *
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     */
    int getFullyLabeledReplicas();

    /**
     *
     *
     * <pre>
     * The number of ready replicas for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     */
    boolean hasReadyReplicas();
    /**
     *
     *
     * <pre>
     * The number of ready replicas for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     */
    int getReadyReplicas();

    /**
     *
     *
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     */
    boolean hasAvailableReplicas();
    /**
     *
     *
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     */
    int getAvailableReplicas();

    /**
     *
     *
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     */
    boolean hasObservedGeneration();
    /**
     *
     *
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     */
    long getObservedGeneration();

    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>
        getConditionsList();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition getConditions(int index);
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    int getConditionsCount();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder>
        getConditionsOrBuilderList();
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder
        getConditionsOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * ReplicaSetStatus represents the current status of a ReplicaSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetStatus}
   */
  public static final class ReplicaSetStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ReplicaSetStatus)
      ReplicaSetStatusOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReplicaSetStatus.newBuilder() to construct.
    private ReplicaSetStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReplicaSetStatus() {
      replicas_ = 0;
      fullyLabeledReplicas_ = 0;
      readyReplicas_ = 0;
      availableReplicas_ = 0;
      observedGeneration_ = 0L;
      conditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReplicaSetStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                replicas_ = input.readInt32();
                break;
              }
            case 16:
              {
                bitField0_ |= 0x00000002;
                fullyLabeledReplicas_ = input.readInt32();
                break;
              }
            case 24:
              {
                bitField0_ |= 0x00000010;
                observedGeneration_ = input.readInt64();
                break;
              }
            case 32:
              {
                bitField0_ |= 0x00000004;
                readyReplicas_ = input.readInt32();
                break;
              }
            case 40:
              {
                bitField0_ |= 0x00000008;
                availableReplicas_ = input.readInt32();
                break;
              }
            case 50:
              {
                if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                  conditions_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>();
                  mutable_bitField0_ |= 0x00000020;
                }
                conditions_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
          conditions_ = java.util.Collections.unmodifiableList(conditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.class,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_;
    /**
     *
     *
     * <pre>
     * Replicas is the most recently oberved number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Replicas is the most recently oberved number of replicas.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public int getReplicas() {
      return replicas_;
    }

    public static final int FULLYLABELEDREPLICAS_FIELD_NUMBER = 2;
    private int fullyLabeledReplicas_;
    /**
     *
     *
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     */
    public boolean hasFullyLabeledReplicas() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The number of pods that have labels matching the labels of the pod template of the replicaset.
     * +optional
     * </pre>
     *
     * <code>optional int32 fullyLabeledReplicas = 2;</code>
     */
    public int getFullyLabeledReplicas() {
      return fullyLabeledReplicas_;
    }

    public static final int READYREPLICAS_FIELD_NUMBER = 4;
    private int readyReplicas_;
    /**
     *
     *
     * <pre>
     * The number of ready replicas for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     */
    public boolean hasReadyReplicas() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * The number of ready replicas for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 readyReplicas = 4;</code>
     */
    public int getReadyReplicas() {
      return readyReplicas_;
    }

    public static final int AVAILABLEREPLICAS_FIELD_NUMBER = 5;
    private int availableReplicas_;
    /**
     *
     *
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     */
    public boolean hasAvailableReplicas() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     *
     *
     * <pre>
     * The number of available replicas (ready for at least minReadySeconds) for this replica set.
     * +optional
     * </pre>
     *
     * <code>optional int32 availableReplicas = 5;</code>
     */
    public int getAvailableReplicas() {
      return availableReplicas_;
    }

    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 3;
    private long observedGeneration_;
    /**
     *
     *
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     */
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     *
     *
     * <pre>
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 3;</code>
     */
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 6;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>
        conditions_;
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>
        getConditionsList() {
      return conditions_;
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    public java.util.List<
            ? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder>
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition getConditions(
        int index) {
      return conditions_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Represents the latest available observations of a replica set's current state.
     * +optional
     * +patchMergeKey=type
     * +patchStrategy=merge
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder
        getConditionsOrBuilder(int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, fullyLabeledReplicas_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(3, observedGeneration_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(4, readyReplicas_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(5, availableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(6, conditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, replicas_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, fullyLabeledReplicas_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(3, observedGeneration_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(4, readyReplicas_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(5, availableReplicas_);
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, conditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus other =
          (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus) obj;

      boolean result = true;
      result = result && (hasReplicas() == other.hasReplicas());
      if (hasReplicas()) {
        result = result && (getReplicas() == other.getReplicas());
      }
      result = result && (hasFullyLabeledReplicas() == other.hasFullyLabeledReplicas());
      if (hasFullyLabeledReplicas()) {
        result = result && (getFullyLabeledReplicas() == other.getFullyLabeledReplicas());
      }
      result = result && (hasReadyReplicas() == other.hasReadyReplicas());
      if (hasReadyReplicas()) {
        result = result && (getReadyReplicas() == other.getReadyReplicas());
      }
      result = result && (hasAvailableReplicas() == other.hasAvailableReplicas());
      if (hasAvailableReplicas()) {
        result = result && (getAvailableReplicas() == other.getAvailableReplicas());
      }
      result = result && (hasObservedGeneration() == other.hasObservedGeneration());
      if (hasObservedGeneration()) {
        result = result && (getObservedGeneration() == other.getObservedGeneration());
      }
      result = result && getConditionsList().equals(other.getConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (hasFullyLabeledReplicas()) {
        hash = (37 * hash) + FULLYLABELEDREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getFullyLabeledReplicas();
      }
      if (hasReadyReplicas()) {
        hash = (37 * hash) + READYREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReadyReplicas();
      }
      if (hasAvailableReplicas()) {
        hash = (37 * hash) + AVAILABLEREPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getAvailableReplicas();
      }
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getObservedGeneration());
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * ReplicaSetStatus represents the current status of a ReplicaSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ReplicaSetStatus}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ReplicaSetStatus)
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.class,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getConditionsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        replicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        fullyLabeledReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        readyReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        availableReplicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        observedGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus build() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus result =
            new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.replicas_ = replicas_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.fullyLabeledReplicas_ = fullyLabeledReplicas_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.readyReplicas_ = readyReplicas_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.availableReplicas_ = availableReplicas_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.observedGeneration_ = observedGeneration_;
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus.getDefaultInstance())
          return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        if (other.hasFullyLabeledReplicas()) {
          setFullyLabeledReplicas(other.getFullyLabeledReplicas());
        }
        if (other.hasReadyReplicas()) {
          setReadyReplicas(other.getReadyReplicas());
        }
        if (other.hasAvailableReplicas()) {
          setAvailableReplicas(other.getAvailableReplicas());
        }
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
              conditionsBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getConditionsFieldBuilder()
                      : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int replicas_;
      /**
       *
       *
       * <pre>
       * Replicas is the most recently oberved number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Replicas is the most recently oberved number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public int getReplicas() {
        return replicas_;
      }
      /**
       *
       *
       * <pre>
       * Replicas is the most recently oberved number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder setReplicas(int value) {
        bitField0_ |= 0x00000001;
        replicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Replicas is the most recently oberved number of replicas.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private int fullyLabeledReplicas_;
      /**
       *
       *
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       */
      public boolean hasFullyLabeledReplicas() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       */
      public int getFullyLabeledReplicas() {
        return fullyLabeledReplicas_;
      }
      /**
       *
       *
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       */
      public Builder setFullyLabeledReplicas(int value) {
        bitField0_ |= 0x00000002;
        fullyLabeledReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of pods that have labels matching the labels of the pod template of the replicaset.
       * +optional
       * </pre>
       *
       * <code>optional int32 fullyLabeledReplicas = 2;</code>
       */
      public Builder clearFullyLabeledReplicas() {
        bitField0_ = (bitField0_ & ~0x00000002);
        fullyLabeledReplicas_ = 0;
        onChanged();
        return this;
      }

      private int readyReplicas_;
      /**
       *
       *
       * <pre>
       * The number of ready replicas for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       */
      public boolean hasReadyReplicas() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * The number of ready replicas for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       */
      public int getReadyReplicas() {
        return readyReplicas_;
      }
      /**
       *
       *
       * <pre>
       * The number of ready replicas for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       */
      public Builder setReadyReplicas(int value) {
        bitField0_ |= 0x00000004;
        readyReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of ready replicas for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 readyReplicas = 4;</code>
       */
      public Builder clearReadyReplicas() {
        bitField0_ = (bitField0_ & ~0x00000004);
        readyReplicas_ = 0;
        onChanged();
        return this;
      }

      private int availableReplicas_;
      /**
       *
       *
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       */
      public boolean hasAvailableReplicas() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       *
       *
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       */
      public int getAvailableReplicas() {
        return availableReplicas_;
      }
      /**
       *
       *
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       */
      public Builder setAvailableReplicas(int value) {
        bitField0_ |= 0x00000008;
        availableReplicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The number of available replicas (ready for at least minReadySeconds) for this replica set.
       * +optional
       * </pre>
       *
       * <code>optional int32 availableReplicas = 5;</code>
       */
      public Builder clearAvailableReplicas() {
        bitField0_ = (bitField0_ & ~0x00000008);
        availableReplicas_ = 0;
        onChanged();
        return this;
      }

      private long observedGeneration_;
      /**
       *
       *
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       */
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       *
       *
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       */
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       *
       *
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       */
      public Builder setObservedGeneration(long value) {
        bitField0_ |= 0x00000010;
        observedGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 3;</code>
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000010);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>
          conditions_ = java.util.Collections.emptyList();

      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          conditions_ =
              new java.util.ArrayList<
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>(conditions_);
          bitField0_ |= 0x00000020;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder>
          conditionsBuilder_;

      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>
          getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition getConditions(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder setConditions(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder
              builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder
              builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addConditions(
          int index,
          io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder
              builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<
                  ? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition>
              values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder
          getConditionsBuilder(int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder
          getConditionsOrBuilder(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public java.util.List<
              ? extends io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder>
          getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder
          addConditionsBuilder() {
        return getConditionsFieldBuilder()
            .addBuilder(
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder
          addConditionsBuilder(int index) {
        return getConditionsFieldBuilder()
            .addBuilder(
                index,
                io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition
                    .getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * Represents the latest available observations of a replica set's current state.
       * +optional
       * +patchMergeKey=type
       * +patchStrategy=merge
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.ReplicaSetCondition conditions = 6;</code>
       */
      public java.util.List<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder>
          getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder>
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetCondition.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000020) == 0x00000020),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ReplicaSetStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ReplicaSetStatus)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ReplicaSetStatus> PARSER =
        new com.google.protobuf.AbstractParser<ReplicaSetStatus>() {
          @java.lang.Override
          public ReplicaSetStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReplicaSetStatus(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReplicaSetStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ReplicaSetStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ReplicaSetStatus
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RollbackConfigOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.RollbackConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The revision to rollback to. If set to 0, rollback to the last revision.
     * +optional
     * </pre>
     *
     * <code>optional int64 revision = 1;</code>
     */
    boolean hasRevision();
    /**
     *
     *
     * <pre>
     * The revision to rollback to. If set to 0, rollback to the last revision.
     * +optional
     * </pre>
     *
     * <code>optional int64 revision = 1;</code>
     */
    long getRevision();
  }
  /**
   *
   *
   * <pre>
   * DEPRECATED.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.RollbackConfig}
   */
  public static final class RollbackConfig extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.RollbackConfig)
      RollbackConfigOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use RollbackConfig.newBuilder() to construct.
    private RollbackConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RollbackConfig() {
      revision_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private RollbackConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                revision_ = input.readInt64();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.class,
              io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder.class);
    }

    private int bitField0_;
    public static final int REVISION_FIELD_NUMBER = 1;
    private long revision_;
    /**
     *
     *
     * <pre>
     * The revision to rollback to. If set to 0, rollback to the last revision.
     * +optional
     * </pre>
     *
     * <code>optional int64 revision = 1;</code>
     */
    public boolean hasRevision() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * The revision to rollback to. If set to 0, rollback to the last revision.
     * +optional
     * </pre>
     *
     * <code>optional int64 revision = 1;</code>
     */
    public long getRevision() {
      return revision_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, revision_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, revision_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig other =
          (io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig) obj;

      boolean result = true;
      result = result && (hasRevision() == other.hasRevision());
      if (hasRevision()) {
        result = result && (getRevision() == other.getRevision());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRevision()) {
        hash = (37 * hash) + REVISION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getRevision());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * DEPRECATED.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.RollbackConfig}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.RollbackConfig)
        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.class,
                io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        revision_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig build() {
        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig result =
            new io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.revision_ = revision_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig.getDefaultInstance())
          return this;
        if (other.hasRevision()) {
          setRevision(other.getRevision());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private long revision_;
      /**
       *
       *
       * <pre>
       * The revision to rollback to. If set to 0, rollback to the last revision.
       * +optional
       * </pre>
       *
       * <code>optional int64 revision = 1;</code>
       */
      public boolean hasRevision() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * The revision to rollback to. If set to 0, rollback to the last revision.
       * +optional
       * </pre>
       *
       * <code>optional int64 revision = 1;</code>
       */
      public long getRevision() {
        return revision_;
      }
      /**
       *
       *
       * <pre>
       * The revision to rollback to. If set to 0, rollback to the last revision.
       * +optional
       * </pre>
       *
       * <code>optional int64 revision = 1;</code>
       */
      public Builder setRevision(long value) {
        bitField0_ |= 0x00000001;
        revision_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * The revision to rollback to. If set to 0, rollback to the last revision.
       * +optional
       * </pre>
       *
       * <code>optional int64 revision = 1;</code>
       */
      public Builder clearRevision() {
        bitField0_ = (bitField0_ & ~0x00000001);
        revision_ = 0L;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.RollbackConfig)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.RollbackConfig)
    private static final io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<RollbackConfig> PARSER =
        new com.google.protobuf.AbstractParser<RollbackConfig>() {
          @java.lang.Override
          public RollbackConfig parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new RollbackConfig(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<RollbackConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollbackConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.RollbackConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RollingUpdateDaemonSetOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    boolean hasMaxUnavailable();
    /**
     *
     *
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable();
    /**
     *
     *
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder();

    /**
     *
     *
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    boolean hasMaxSurge();
    /**
     *
     *
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge();
    /**
     *
     *
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * Spec to control the desired behavior of daemon set rolling update.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet}
   */
  public static final class RollingUpdateDaemonSet extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet)
      RollingUpdateDaemonSetOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use RollingUpdateDaemonSet.newBuilder() to construct.
    private RollingUpdateDaemonSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RollingUpdateDaemonSet() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private RollingUpdateDaemonSet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = maxUnavailable_.toBuilder();
                }
                maxUnavailable_ =
                    input.readMessage(
                        io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(maxUnavailable_);
                  maxUnavailable_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = maxSurge_.toBuilder();
                }
                maxSurge_ =
                    input.readMessage(
                        io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(maxSurge_);
                  maxSurge_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.class,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder.class);
    }

    private int bitField0_;
    public static final int MAXUNAVAILABLE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
    /**
     *
     *
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public boolean hasMaxUnavailable() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
      return maxUnavailable_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxUnavailable_;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0 if MaxSurge is 0
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given time. The update
     * starts by stopping at most 30% of those DaemonSet pods and then brings
     * up new DaemonSet pods in their place. Once the new pods are available,
     * it then proceeds onto other DaemonSet pods, thus ensuring that at least
     * 70% of original number of DaemonSet pods are available at all times during
     * the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
      return maxUnavailable_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxUnavailable_;
    }

    public static final int MAXSURGE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_;
    /**
     *
     *
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    public boolean hasMaxSurge() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
      return maxSurge_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxSurge_;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of nodes with an existing available DaemonSet pod that
     * can have an updated DaemonSet pod during during an update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up to a minimum of 1.
     * Default value is 0.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their a new pod created before the old pod is marked as deleted.
     * The update starts by launching new pods on 30% of nodes. Once an updated
     * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
     * on that node is marked deleted. If the old pod becomes unavailable for any
     * reason (Ready transitions to false, is evicted, or is drained) an updated
     * pod is immediatedly created on that node without considering surge limits.
     * Allowing surge implies the possibility that the resources consumed by the
     * daemonset on any given node can double if the readiness check fails, and
     * so resource intensive daemonsets should take into account that they may
     * cause evictions during disruption.
     * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
      return maxSurge_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxSurge_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getMaxSurge());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getMaxSurge());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet other =
          (io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet) obj;

      boolean result = true;
      result = result && (hasMaxUnavailable() == other.hasMaxUnavailable());
      if (hasMaxUnavailable()) {
        result = result && getMaxUnavailable().equals(other.getMaxUnavailable());
      }
      result = result && (hasMaxSurge() == other.hasMaxSurge());
      if (hasMaxSurge()) {
        result = result && getMaxSurge().equals(other.getMaxSurge());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMaxUnavailable()) {
        hash = (37 * hash) + MAXUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxUnavailable().hashCode();
      }
      if (hasMaxSurge()) {
        hash = (37 * hash) + MAXSURGE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxSurge().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * Spec to control the desired behavior of daemon set rolling update.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet)
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.class,
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMaxUnavailableFieldBuilder();
          getMaxSurgeFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = null;
        } else {
          maxUnavailableBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = null;
        } else {
          maxSurgeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet build() {
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet result =
            new io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (maxUnavailableBuilder_ == null) {
          result.maxUnavailable_ = maxUnavailable_;
        } else {
          result.maxUnavailable_ = maxUnavailableBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (maxSurgeBuilder_ == null) {
          result.maxSurge_ = maxSurge_;
        } else {
          result.maxSurge_ = maxSurgeBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
                .getDefaultInstance()) return this;
        if (other.hasMaxUnavailable()) {
          mergeMaxUnavailable(other.getMaxUnavailable());
        }
        if (other.hasMaxSurge()) {
          mergeMaxSurge(other.getMaxSurge());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          maxUnavailableBuilder_;
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public boolean hasMaxUnavailable() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          return maxUnavailable_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxUnavailable_;
        } else {
          return maxUnavailableBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxUnavailable_ = value;
          onChanged();
        } else {
          maxUnavailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = builderForValue.build();
          onChanged();
        } else {
          maxUnavailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder mergeMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && maxUnavailable_ != null
              && maxUnavailable_
                  != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            maxUnavailable_ =
                io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(maxUnavailable_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            maxUnavailable_ = value;
          }
          onChanged();
        } else {
          maxUnavailableBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder clearMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = null;
          onChanged();
        } else {
          maxUnavailableBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxUnavailableBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMaxUnavailableFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
        if (maxUnavailableBuilder_ != null) {
          return maxUnavailableBuilder_.getMessageOrBuilder();
        } else {
          return maxUnavailable_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxUnavailable_;
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0 if MaxSurge is 0
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given time. The update
       * starts by stopping at most 30% of those DaemonSet pods and then brings
       * up new DaemonSet pods in their place. Once the new pods are available,
       * it then proceeds onto other DaemonSet pods, thus ensuring that at least
       * 70% of original number of DaemonSet pods are available at all times during
       * the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          getMaxUnavailableFieldBuilder() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailableBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.IntStr.IntOrString,
                  io.kubernetes.client.proto.IntStr.IntOrString.Builder,
                  io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxUnavailable(), getParentForChildren(), isClean());
          maxUnavailable_ = null;
        }
        return maxUnavailableBuilder_;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          maxSurgeBuilder_;
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public boolean hasMaxSurge() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
        if (maxSurgeBuilder_ == null) {
          return maxSurge_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxSurge_;
        } else {
          return maxSurgeBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxSurge_ = value;
          onChanged();
        } else {
          maxSurgeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = builderForValue.build();
          onChanged();
        } else {
          maxSurgeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder mergeMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && maxSurge_ != null
              && maxSurge_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            maxSurge_ =
                io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(maxSurge_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            maxSurge_ = value;
          }
          onChanged();
        } else {
          maxSurgeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder clearMaxSurge() {
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = null;
          onChanged();
        } else {
          maxSurgeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxSurgeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMaxSurgeFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
        if (maxSurgeBuilder_ != null) {
          return maxSurgeBuilder_.getMessageOrBuilder();
        } else {
          return maxSurge_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxSurge_;
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of nodes with an existing available DaemonSet pod that
       * can have an updated DaemonSet pod during during an update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up to a minimum of 1.
       * Default value is 0.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their a new pod created before the old pod is marked as deleted.
       * The update starts by launching new pods on 30% of nodes. Once an updated
       * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
       * on that node is marked deleted. If the old pod becomes unavailable for any
       * reason (Ready transitions to false, is evicted, or is drained) an updated
       * pod is immediatedly created on that node without considering surge limits.
       * Allowing surge implies the possibility that the resources consumed by the
       * daemonset on any given node can double if the readiness check fails, and
       * so resource intensive daemonsets should take into account that they may
       * cause evictions during disruption.
       * This is an alpha field and requires enabling DaemonSetUpdateSurge feature gate.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          getMaxSurgeFieldBuilder() {
        if (maxSurgeBuilder_ == null) {
          maxSurgeBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.IntStr.IntOrString,
                  io.kubernetes.client.proto.IntStr.IntOrString.Builder,
                  io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxSurge(), getParentForChildren(), isClean());
          maxSurge_ = null;
        }
        return maxSurgeBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.RollingUpdateDaemonSet)
    private static final io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<RollingUpdateDaemonSet> PARSER =
        new com.google.protobuf.AbstractParser<RollingUpdateDaemonSet>() {
          @java.lang.Override
          public RollingUpdateDaemonSet parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new RollingUpdateDaemonSet(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<RollingUpdateDaemonSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollingUpdateDaemonSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDaemonSet
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RollingUpdateDeploymentOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.RollingUpdateDeployment)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * By default, a fixed value of 1 is used.
     * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old RC
     * can be scaled down further, followed by scaling up the new RC, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    boolean hasMaxUnavailable();
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * By default, a fixed value of 1 is used.
     * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old RC
     * can be scaled down further, followed by scaling up the new RC, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable();
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * By default, a fixed value of 1 is used.
     * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old RC
     * can be scaled down further, followed by scaling up the new RC, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder();

    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * By default, a value of 1 is used.
     * Example: when this is set to 30%, the new RC can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new RC can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    boolean hasMaxSurge();
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * By default, a value of 1 is used.
     * Example: when this is set to 30%, the new RC can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new RC can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge();
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * By default, a value of 1 is used.
     * Example: when this is set to 30%, the new RC can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new RC can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * Spec to control the desired behavior of rolling update.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.RollingUpdateDeployment}
   */
  public static final class RollingUpdateDeployment extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.RollingUpdateDeployment)
      RollingUpdateDeploymentOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use RollingUpdateDeployment.newBuilder() to construct.
    private RollingUpdateDeployment(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RollingUpdateDeployment() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private RollingUpdateDeployment(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = maxUnavailable_.toBuilder();
                }
                maxUnavailable_ =
                    input.readMessage(
                        io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(maxUnavailable_);
                  maxUnavailable_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = maxSurge_.toBuilder();
                }
                maxSurge_ =
                    input.readMessage(
                        io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(maxSurge_);
                  maxSurge_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.class,
              io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder.class);
    }

    private int bitField0_;
    public static final int MAXUNAVAILABLE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * By default, a fixed value of 1 is used.
     * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old RC
     * can be scaled down further, followed by scaling up the new RC, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public boolean hasMaxUnavailable() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * By default, a fixed value of 1 is used.
     * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old RC
     * can be scaled down further, followed by scaling up the new RC, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
      return maxUnavailable_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxUnavailable_;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be unavailable during the update.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0.
     * By default, a fixed value of 1 is used.
     * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old RC
     * can be scaled down further, followed by scaling up the new RC, ensuring
     * that the total number of pods available at all times during the update is at
     * least 70% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
      return maxUnavailable_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxUnavailable_;
    }

    public static final int MAXSURGE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_;
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * By default, a value of 1 is used.
     * Example: when this is set to 30%, the new RC can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new RC can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    public boolean hasMaxSurge() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * By default, a value of 1 is used.
     * Example: when this is set to 30%, the new RC can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new RC can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
      return maxSurge_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxSurge_;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of pods that can be scheduled above the desired number of
     * pods.
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * By default, a value of 1 is used.
     * Example: when this is set to 30%, the new RC can be scaled up immediately when
     * the rolling update starts, such that the total number of old and new pods do not exceed
     * 130% of desired pods. Once old pods have been killed,
     * new RC can be scaled up further, ensuring that total number of pods running
     * at any time during the update is at most 130% of desired pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
      return maxSurge_ == null
          ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
          : maxSurge_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getMaxSurge());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMaxUnavailable());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getMaxSurge());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment other =
          (io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment) obj;

      boolean result = true;
      result = result && (hasMaxUnavailable() == other.hasMaxUnavailable());
      if (hasMaxUnavailable()) {
        result = result && getMaxUnavailable().equals(other.getMaxUnavailable());
      }
      result = result && (hasMaxSurge() == other.hasMaxSurge());
      if (hasMaxSurge()) {
        result = result && getMaxSurge().equals(other.getMaxSurge());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMaxUnavailable()) {
        hash = (37 * hash) + MAXUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxUnavailable().hashCode();
      }
      if (hasMaxSurge()) {
        hash = (37 * hash) + MAXSURGE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxSurge().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * Spec to control the desired behavior of rolling update.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.RollingUpdateDeployment}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.RollingUpdateDeployment)
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeploymentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.class,
                io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMaxUnavailableFieldBuilder();
          getMaxSurgeFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = null;
        } else {
          maxUnavailableBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = null;
        } else {
          maxSurgeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment build() {
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment result =
            new io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (maxUnavailableBuilder_ == null) {
          result.maxUnavailable_ = maxUnavailable_;
        } else {
          result.maxUnavailable_ = maxUnavailableBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (maxSurgeBuilder_ == null) {
          result.maxSurge_ = maxSurge_;
        } else {
          result.maxSurge_ = maxSurgeBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
                .getDefaultInstance()) return this;
        if (other.hasMaxUnavailable()) {
          mergeMaxUnavailable(other.getMaxUnavailable());
        }
        if (other.hasMaxSurge()) {
          mergeMaxSurge(other.getMaxSurge());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          maxUnavailableBuilder_;
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public boolean hasMaxUnavailable() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          return maxUnavailable_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxUnavailable_;
        } else {
          return maxUnavailableBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxUnavailable_ = value;
          onChanged();
        } else {
          maxUnavailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = builderForValue.build();
          onChanged();
        } else {
          maxUnavailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder mergeMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && maxUnavailable_ != null
              && maxUnavailable_
                  != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            maxUnavailable_ =
                io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(maxUnavailable_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            maxUnavailable_ = value;
          }
          onChanged();
        } else {
          maxUnavailableBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder clearMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = null;
          onChanged();
        } else {
          maxUnavailableBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxUnavailableBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMaxUnavailableFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
        if (maxUnavailableBuilder_ != null) {
          return maxUnavailableBuilder_.getMessageOrBuilder();
        } else {
          return maxUnavailable_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxUnavailable_;
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be unavailable during the update.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0.
       * By default, a fixed value of 1 is used.
       * Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old RC
       * can be scaled down further, followed by scaling up the new RC, ensuring
       * that the total number of pods available at all times during the update is at
       * least 70% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          getMaxUnavailableFieldBuilder() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailableBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.IntStr.IntOrString,
                  io.kubernetes.client.proto.IntStr.IntOrString.Builder,
                  io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxUnavailable(), getParentForChildren(), isClean());
          maxUnavailable_ = null;
        }
        return maxUnavailableBuilder_;
      }

      private io.kubernetes.client.proto.IntStr.IntOrString maxSurge_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          maxSurgeBuilder_;
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public boolean hasMaxSurge() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxSurge() {
        if (maxSurgeBuilder_ == null) {
          return maxSurge_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxSurge_;
        } else {
          return maxSurgeBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxSurge_ = value;
          onChanged();
        } else {
          maxSurgeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder setMaxSurge(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = builderForValue.build();
          onChanged();
        } else {
          maxSurgeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder mergeMaxSurge(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxSurgeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && maxSurge_ != null
              && maxSurge_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            maxSurge_ =
                io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(maxSurge_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            maxSurge_ = value;
          }
          onChanged();
        } else {
          maxSurgeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public Builder clearMaxSurge() {
        if (maxSurgeBuilder_ == null) {
          maxSurge_ = null;
          onChanged();
        } else {
          maxSurgeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxSurgeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMaxSurgeFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxSurgeOrBuilder() {
        if (maxSurgeBuilder_ != null) {
          return maxSurgeBuilder_.getMessageOrBuilder();
        } else {
          return maxSurge_ == null
              ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()
              : maxSurge_;
        }
      }
      /**
       *
       *
       * <pre>
       * The maximum number of pods that can be scheduled above the desired number of
       * pods.
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * By default, a value of 1 is used.
       * Example: when this is set to 30%, the new RC can be scaled up immediately when
       * the rolling update starts, such that the total number of old and new pods do not exceed
       * 130% of desired pods. Once old pods have been killed,
       * new RC can be scaled up further, ensuring that total number of pods running
       * at any time during the update is at most 130% of desired pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString,
              io.kubernetes.client.proto.IntStr.IntOrString.Builder,
              io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>
          getMaxSurgeFieldBuilder() {
        if (maxSurgeBuilder_ == null) {
          maxSurgeBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.IntStr.IntOrString,
                  io.kubernetes.client.proto.IntStr.IntOrString.Builder,
                  io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxSurge(), getParentForChildren(), isClean());
          maxSurge_ = null;
        }
        return maxSurgeBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.RollingUpdateDeployment)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.RollingUpdateDeployment)
    private static final io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<RollingUpdateDeployment> PARSER =
        new com.google.protobuf.AbstractParser<RollingUpdateDeployment>() {
          @java.lang.Override
          public RollingUpdateDeployment parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new RollingUpdateDeployment(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<RollingUpdateDeployment> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollingUpdateDeployment> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.RollingUpdateDeployment
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RunAsGroupStrategyOptionsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    boolean hasRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    java.lang.String getRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    com.google.protobuf.ByteString getRuleBytes();

    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index);
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    int getRangesCount();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * RunAsGroupStrategyOptions defines the strategy type and any options used to create the strategy.
   * Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions}
   */
  public static final class RunAsGroupStrategyOptions extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions)
      RunAsGroupStrategyOptionsOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use RunAsGroupStrategyOptions.newBuilder() to construct.
    private RunAsGroupStrategyOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RunAsGroupStrategyOptions() {
      rule_ = "";
      ranges_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private RunAsGroupStrategyOptions(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                rule_ = bs;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  ranges_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.IDRange>();
                  mutable_bitField0_ |= 0x00000002;
                }
                ranges_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IDRange.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ = java.util.Collections.unmodifiableList(ranges_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.class,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder.class);
    }

    private int bitField0_;
    public static final int RULE_FIELD_NUMBER = 1;
    private volatile java.lang.Object rule_;
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public boolean hasRule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public java.lang.String getRule() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          rule_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public com.google.protobuf.ByteString getRuleBytes() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        rule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RANGES_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_;
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public int getRangesCount() {
      return ranges_.size();
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
      return ranges_.get(index);
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
        int index) {
      return ranges_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        output.writeMessage(2, ranges_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, ranges_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj
          instanceof io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions other =
          (io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions) obj;

      boolean result = true;
      result = result && (hasRule() == other.hasRule());
      if (hasRule()) {
        result = result && getRule().equals(other.getRule());
      }
      result = result && getRangesList().equals(other.getRangesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRule()) {
        hash = (37 * hash) + RULE_FIELD_NUMBER;
        hash = (53 * hash) + getRule().hashCode();
      }
      if (getRangesCount() > 0) {
        hash = (37 * hash) + RANGES_FIELD_NUMBER;
        hash = (53 * hash) + getRangesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * RunAsGroupStrategyOptions defines the strategy type and any options used to create the strategy.
     * Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions)
        io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.class,
                io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.Builder
                    .class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRangesFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        rule_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions build() {
        io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions result =
            new io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.rule_ = rule_;
        if (rangesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            ranges_ = java.util.Collections.unmodifiableList(ranges_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.ranges_ = ranges_;
        } else {
          result.ranges_ = rangesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other
            instanceof io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
                .getDefaultInstance()) return this;
        if (other.hasRule()) {
          bitField0_ |= 0x00000001;
          rule_ = other.rule_;
          onChanged();
        }
        if (rangesBuilder_ == null) {
          if (!other.ranges_.isEmpty()) {
            if (ranges_.isEmpty()) {
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureRangesIsMutable();
              ranges_.addAll(other.ranges_);
            }
            onChanged();
          }
        } else {
          if (!other.ranges_.isEmpty()) {
            if (rangesBuilder_.isEmpty()) {
              rangesBuilder_.dispose();
              rangesBuilder_ = null;
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
              rangesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getRangesFieldBuilder()
                      : null;
            } else {
              rangesBuilder_.addAllMessages(other.ranges_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object rule_ = "";
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public boolean hasRule() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public java.lang.String getRule() {
        java.lang.Object ref = rule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            rule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public com.google.protobuf.ByteString getRuleBytes() {
        java.lang.Object ref = rule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          rule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRule(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder clearRule() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rule_ = getDefaultInstance().getRule();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRuleBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_ =
          java.util.Collections.emptyList();

      private void ensureRangesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.IDRange>(
                  ranges_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          rangesBuilder_;

      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
        if (rangesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ranges_);
        } else {
          return rangesBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public int getRangesCount() {
        if (rangesBuilder_ == null) {
          return ranges_.size();
        } else {
          return rangesBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.set(index, value);
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.set(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(index, value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addAllRanges(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRange>
              values) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ranges_);
          onChanged();
        } else {
          rangesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder clearRanges() {
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder removeRanges(int index) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.remove(index);
          onChanged();
        } else {
          rangesBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder getRangesBuilder(
          int index) {
        return getRangesFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
          int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesOrBuilderList() {
        if (rangesBuilder_ != null) {
          return rangesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ranges_);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder() {
        return getRangesFieldBuilder()
            .addBuilder(io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder(
          int index) {
        return getRangesFieldBuilder()
            .addBuilder(
                index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder>
          getRangesBuilderList() {
        return getRangesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesFieldBuilder() {
        if (rangesBuilder_ == null) {
          rangesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>(
                  ranges_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          ranges_ = null;
        }
        return rangesBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.RunAsGroupStrategyOptions)
    private static final io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE =
          new io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<RunAsGroupStrategyOptions> PARSER =
        new com.google.protobuf.AbstractParser<RunAsGroupStrategyOptions>() {
          @java.lang.Override
          public RunAsGroupStrategyOptions parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new RunAsGroupStrategyOptions(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<RunAsGroupStrategyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RunAsGroupStrategyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.RunAsGroupStrategyOptions
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RunAsUserStrategyOptionsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    boolean hasRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    java.lang.String getRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    com.google.protobuf.ByteString getRuleBytes();

    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index);
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    int getRangesCount();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
   * Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions}
   */
  public static final class RunAsUserStrategyOptions extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions)
      RunAsUserStrategyOptionsOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use RunAsUserStrategyOptions.newBuilder() to construct.
    private RunAsUserStrategyOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RunAsUserStrategyOptions() {
      rule_ = "";
      ranges_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private RunAsUserStrategyOptions(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                rule_ = bs;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  ranges_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.IDRange>();
                  mutable_bitField0_ |= 0x00000002;
                }
                ranges_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IDRange.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ = java.util.Collections.unmodifiableList(ranges_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.class,
              io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder.class);
    }

    private int bitField0_;
    public static final int RULE_FIELD_NUMBER = 1;
    private volatile java.lang.Object rule_;
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public boolean hasRule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public java.lang.String getRule() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          rule_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public com.google.protobuf.ByteString getRuleBytes() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        rule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RANGES_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_;
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public int getRangesCount() {
      return ranges_.size();
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
      return ranges_.get(index);
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
     * then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
        int index) {
      return ranges_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        output.writeMessage(2, ranges_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, ranges_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions other =
          (io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions) obj;

      boolean result = true;
      result = result && (hasRule() == other.hasRule());
      if (hasRule()) {
        result = result && getRule().equals(other.getRule());
      }
      result = result && getRangesList().equals(other.getRangesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRule()) {
        hash = (37 * hash) + RULE_FIELD_NUMBER;
        hash = (53 * hash) + getRule().hashCode();
      }
      if (getRangesCount() > 0) {
        hash = (37 * hash) + RANGES_FIELD_NUMBER;
        hash = (53 * hash) + getRangesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
     * Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions)
        io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.class,
                io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.Builder
                    .class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRangesFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        rule_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions build() {
        io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions result =
            new io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.rule_ = rule_;
        if (rangesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            ranges_ = java.util.Collections.unmodifiableList(ranges_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.ranges_ = ranges_;
        } else {
          result.ranges_ = rangesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other
            instanceof io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
                .getDefaultInstance()) return this;
        if (other.hasRule()) {
          bitField0_ |= 0x00000001;
          rule_ = other.rule_;
          onChanged();
        }
        if (rangesBuilder_ == null) {
          if (!other.ranges_.isEmpty()) {
            if (ranges_.isEmpty()) {
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureRangesIsMutable();
              ranges_.addAll(other.ranges_);
            }
            onChanged();
          }
        } else {
          if (!other.ranges_.isEmpty()) {
            if (rangesBuilder_.isEmpty()) {
              rangesBuilder_.dispose();
              rangesBuilder_ = null;
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
              rangesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getRangesFieldBuilder()
                      : null;
            } else {
              rangesBuilder_.addAllMessages(other.ranges_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object rule_ = "";
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public boolean hasRule() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public java.lang.String getRule() {
        java.lang.Object ref = rule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            rule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public com.google.protobuf.ByteString getRuleBytes() {
        java.lang.Object ref = rule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          rule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRule(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder clearRule() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rule_ = getDefaultInstance().getRule();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRuleBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_ =
          java.util.Collections.emptyList();

      private void ensureRangesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.IDRange>(
                  ranges_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          rangesBuilder_;

      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
        if (rangesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ranges_);
        } else {
          return rangesBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public int getRangesCount() {
        if (rangesBuilder_ == null) {
          return ranges_.size();
        } else {
          return rangesBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.set(index, value);
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.set(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(index, value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addAllRanges(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRange>
              values) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ranges_);
          onChanged();
        } else {
          rangesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder clearRanges() {
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder removeRanges(int index) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.remove(index);
          onChanged();
        } else {
          rangesBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder getRangesBuilder(
          int index) {
        return getRangesFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
          int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesOrBuilderList() {
        if (rangesBuilder_ != null) {
          return rangesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ranges_);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder() {
        return getRangesFieldBuilder()
            .addBuilder(io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder(
          int index) {
        return getRangesFieldBuilder()
            .addBuilder(
                index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
       * then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder>
          getRangesBuilderList() {
        return getRangesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesFieldBuilder() {
        if (rangesBuilder_ == null) {
          rangesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>(
                  ranges_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          ranges_ = null;
        }
        return rangesBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.RunAsUserStrategyOptions)
    private static final io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE =
          new io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<RunAsUserStrategyOptions> PARSER =
        new com.google.protobuf.AbstractParser<RunAsUserStrategyOptions>() {
          @java.lang.Override
          public RunAsUserStrategyOptions parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new RunAsUserStrategyOptions(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<RunAsUserStrategyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RunAsUserStrategyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.RunAsUserStrategyOptions
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RuntimeClassStrategyOptionsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    java.util.List<java.lang.String> getAllowedRuntimeClassNamesList();
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    int getAllowedRuntimeClassNamesCount();
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    java.lang.String getAllowedRuntimeClassNames(int index);
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    com.google.protobuf.ByteString getAllowedRuntimeClassNamesBytes(int index);

    /**
     *
     *
     * <pre>
     * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
     * The default MUST be allowed by the allowedRuntimeClassNames list.
     * A value of nil does not mutate the Pod.
     * +optional
     * </pre>
     *
     * <code>optional string defaultRuntimeClassName = 2;</code>
     */
    boolean hasDefaultRuntimeClassName();
    /**
     *
     *
     * <pre>
     * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
     * The default MUST be allowed by the allowedRuntimeClassNames list.
     * A value of nil does not mutate the Pod.
     * +optional
     * </pre>
     *
     * <code>optional string defaultRuntimeClassName = 2;</code>
     */
    java.lang.String getDefaultRuntimeClassName();
    /**
     *
     *
     * <pre>
     * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
     * The default MUST be allowed by the allowedRuntimeClassNames list.
     * A value of nil does not mutate the Pod.
     * +optional
     * </pre>
     *
     * <code>optional string defaultRuntimeClassName = 2;</code>
     */
    com.google.protobuf.ByteString getDefaultRuntimeClassNameBytes();
  }
  /**
   *
   *
   * <pre>
   * RuntimeClassStrategyOptions define the strategy that will dictate the allowable RuntimeClasses
   * for a pod.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions}
   */
  public static final class RuntimeClassStrategyOptions
      extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions)
      RuntimeClassStrategyOptionsOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use RuntimeClassStrategyOptions.newBuilder() to construct.
    private RuntimeClassStrategyOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RuntimeClassStrategyOptions() {
      allowedRuntimeClassNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      defaultRuntimeClassName_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private RuntimeClassStrategyOptions(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  allowedRuntimeClassNames_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000001;
                }
                allowedRuntimeClassNames_.add(bs);
                break;
              }
            case 18:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                defaultRuntimeClassName_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          allowedRuntimeClassNames_ = allowedRuntimeClassNames_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.class,
              io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder
                  .class);
    }

    private int bitField0_;
    public static final int ALLOWEDRUNTIMECLASSNAMES_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList allowedRuntimeClassNames_;
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList getAllowedRuntimeClassNamesList() {
      return allowedRuntimeClassNames_;
    }
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    public int getAllowedRuntimeClassNamesCount() {
      return allowedRuntimeClassNames_.size();
    }
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    public java.lang.String getAllowedRuntimeClassNames(int index) {
      return allowedRuntimeClassNames_.get(index);
    }
    /**
     *
     *
     * <pre>
     * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
     * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
     * list. An empty list requires the RuntimeClassName field to be unset.
     * </pre>
     *
     * <code>repeated string allowedRuntimeClassNames = 1;</code>
     */
    public com.google.protobuf.ByteString getAllowedRuntimeClassNamesBytes(int index) {
      return allowedRuntimeClassNames_.getByteString(index);
    }

    public static final int DEFAULTRUNTIMECLASSNAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object defaultRuntimeClassName_;
    /**
     *
     *
     * <pre>
     * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
     * The default MUST be allowed by the allowedRuntimeClassNames list.
     * A value of nil does not mutate the Pod.
     * +optional
     * </pre>
     *
     * <code>optional string defaultRuntimeClassName = 2;</code>
     */
    public boolean hasDefaultRuntimeClassName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
     * The default MUST be allowed by the allowedRuntimeClassNames list.
     * A value of nil does not mutate the Pod.
     * +optional
     * </pre>
     *
     * <code>optional string defaultRuntimeClassName = 2;</code>
     */
    public java.lang.String getDefaultRuntimeClassName() {
      java.lang.Object ref = defaultRuntimeClassName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          defaultRuntimeClassName_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
     * The default MUST be allowed by the allowedRuntimeClassNames list.
     * A value of nil does not mutate the Pod.
     * +optional
     * </pre>
     *
     * <code>optional string defaultRuntimeClassName = 2;</code>
     */
    public com.google.protobuf.ByteString getDefaultRuntimeClassNameBytes() {
      java.lang.Object ref = defaultRuntimeClassName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        defaultRuntimeClassName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < allowedRuntimeClassNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(
            output, 1, allowedRuntimeClassNames_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, defaultRuntimeClassName_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < allowedRuntimeClassNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(allowedRuntimeClassNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAllowedRuntimeClassNamesList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size +=
            com.google.protobuf.GeneratedMessageV3.computeStringSize(2, defaultRuntimeClassName_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj
          instanceof io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions other =
          (io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions) obj;

      boolean result = true;
      result =
          result
              && getAllowedRuntimeClassNamesList().equals(other.getAllowedRuntimeClassNamesList());
      result = result && (hasDefaultRuntimeClassName() == other.hasDefaultRuntimeClassName());
      if (hasDefaultRuntimeClassName()) {
        result = result && getDefaultRuntimeClassName().equals(other.getDefaultRuntimeClassName());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getAllowedRuntimeClassNamesCount() > 0) {
        hash = (37 * hash) + ALLOWEDRUNTIMECLASSNAMES_FIELD_NUMBER;
        hash = (53 * hash) + getAllowedRuntimeClassNamesList().hashCode();
      }
      if (hasDefaultRuntimeClassName()) {
        hash = (37 * hash) + DEFAULTRUNTIMECLASSNAME_FIELD_NUMBER;
        hash = (53 * hash) + getDefaultRuntimeClassName().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(
            java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * RuntimeClassStrategyOptions define the strategy that will dictate the allowable RuntimeClasses
     * for a pod.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions)
        io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.class,
                io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.Builder
                    .class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        allowedRuntimeClassNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        defaultRuntimeClassName_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions build() {
        io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
          buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions result =
            new io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          allowedRuntimeClassNames_ = allowedRuntimeClassNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.allowedRuntimeClassNames_ = allowedRuntimeClassNames_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        result.defaultRuntimeClassName_ = defaultRuntimeClassName_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other
            instanceof io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
                .getDefaultInstance()) return this;
        if (!other.allowedRuntimeClassNames_.isEmpty()) {
          if (allowedRuntimeClassNames_.isEmpty()) {
            allowedRuntimeClassNames_ = other.allowedRuntimeClassNames_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureAllowedRuntimeClassNamesIsMutable();
            allowedRuntimeClassNames_.addAll(other.allowedRuntimeClassNames_);
          }
          onChanged();
        }
        if (other.hasDefaultRuntimeClassName()) {
          bitField0_ |= 0x00000002;
          defaultRuntimeClassName_ = other.defaultRuntimeClassName_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions parsedMessage =
            null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.LazyStringList allowedRuntimeClassNames_ =
          com.google.protobuf.LazyStringArrayList.EMPTY;

      private void ensureAllowedRuntimeClassNamesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          allowedRuntimeClassNames_ =
              new com.google.protobuf.LazyStringArrayList(allowedRuntimeClassNames_);
          bitField0_ |= 0x00000001;
        }
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList getAllowedRuntimeClassNamesList() {
        return allowedRuntimeClassNames_.getUnmodifiableView();
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public int getAllowedRuntimeClassNamesCount() {
        return allowedRuntimeClassNames_.size();
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public java.lang.String getAllowedRuntimeClassNames(int index) {
        return allowedRuntimeClassNames_.get(index);
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public com.google.protobuf.ByteString getAllowedRuntimeClassNamesBytes(int index) {
        return allowedRuntimeClassNames_.getByteString(index);
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public Builder setAllowedRuntimeClassNames(int index, java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedRuntimeClassNamesIsMutable();
        allowedRuntimeClassNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public Builder addAllowedRuntimeClassNames(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedRuntimeClassNamesIsMutable();
        allowedRuntimeClassNames_.add(value);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public Builder addAllAllowedRuntimeClassNames(java.lang.Iterable<java.lang.String> values) {
        ensureAllowedRuntimeClassNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, allowedRuntimeClassNames_);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public Builder clearAllowedRuntimeClassNames() {
        allowedRuntimeClassNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod.
       * A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
       * list. An empty list requires the RuntimeClassName field to be unset.
       * </pre>
       *
       * <code>repeated string allowedRuntimeClassNames = 1;</code>
       */
      public Builder addAllowedRuntimeClassNamesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAllowedRuntimeClassNamesIsMutable();
        allowedRuntimeClassNames_.add(value);
        onChanged();
        return this;
      }

      private java.lang.Object defaultRuntimeClassName_ = "";
      /**
       *
       *
       * <pre>
       * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
       * The default MUST be allowed by the allowedRuntimeClassNames list.
       * A value of nil does not mutate the Pod.
       * +optional
       * </pre>
       *
       * <code>optional string defaultRuntimeClassName = 2;</code>
       */
      public boolean hasDefaultRuntimeClassName() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
       * The default MUST be allowed by the allowedRuntimeClassNames list.
       * A value of nil does not mutate the Pod.
       * +optional
       * </pre>
       *
       * <code>optional string defaultRuntimeClassName = 2;</code>
       */
      public java.lang.String getDefaultRuntimeClassName() {
        java.lang.Object ref = defaultRuntimeClassName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            defaultRuntimeClassName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
       * The default MUST be allowed by the allowedRuntimeClassNames list.
       * A value of nil does not mutate the Pod.
       * +optional
       * </pre>
       *
       * <code>optional string defaultRuntimeClassName = 2;</code>
       */
      public com.google.protobuf.ByteString getDefaultRuntimeClassNameBytes() {
        java.lang.Object ref = defaultRuntimeClassName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          defaultRuntimeClassName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
       * The default MUST be allowed by the allowedRuntimeClassNames list.
       * A value of nil does not mutate the Pod.
       * +optional
       * </pre>
       *
       * <code>optional string defaultRuntimeClassName = 2;</code>
       */
      public Builder setDefaultRuntimeClassName(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        defaultRuntimeClassName_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
       * The default MUST be allowed by the allowedRuntimeClassNames list.
       * A value of nil does not mutate the Pod.
       * +optional
       * </pre>
       *
       * <code>optional string defaultRuntimeClassName = 2;</code>
       */
      public Builder clearDefaultRuntimeClassName() {
        bitField0_ = (bitField0_ & ~0x00000002);
        defaultRuntimeClassName_ = getDefaultInstance().getDefaultRuntimeClassName();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
       * The default MUST be allowed by the allowedRuntimeClassNames list.
       * A value of nil does not mutate the Pod.
       * +optional
       * </pre>
       *
       * <code>optional string defaultRuntimeClassName = 2;</code>
       */
      public Builder setDefaultRuntimeClassNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        defaultRuntimeClassName_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.RuntimeClassStrategyOptions)
    private static final io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE =
          new io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<RuntimeClassStrategyOptions> PARSER =
        new com.google.protobuf.AbstractParser<RuntimeClassStrategyOptions>() {
          @java.lang.Override
          public RuntimeClassStrategyOptions parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new RuntimeClassStrategyOptions(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<RuntimeClassStrategyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RuntimeClassStrategyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.RuntimeClassStrategyOptions
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface SELinuxStrategyOptionsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    boolean hasRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    java.lang.String getRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    com.google.protobuf.ByteString getRuleBytes();

    /**
     *
     *
     * <pre>
     * seLinuxOptions required to run as; required for MustRunAs
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
     */
    boolean hasSeLinuxOptions();
    /**
     *
     *
     * <pre>
     * seLinuxOptions required to run as; required for MustRunAs
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
     */
    io.kubernetes.client.proto.V1.SELinuxOptions getSeLinuxOptions();
    /**
     *
     *
     * <pre>
     * seLinuxOptions required to run as; required for MustRunAs
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
     */
    io.kubernetes.client.proto.V1.SELinuxOptionsOrBuilder getSeLinuxOptionsOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
   * Deprecated: use SELinuxStrategyOptions from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions}
   */
  public static final class SELinuxStrategyOptions extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions)
      SELinuxStrategyOptionsOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use SELinuxStrategyOptions.newBuilder() to construct.
    private SELinuxStrategyOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private SELinuxStrategyOptions() {
      rule_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private SELinuxStrategyOptions(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                rule_ = bs;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1.SELinuxOptions.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = seLinuxOptions_.toBuilder();
                }
                seLinuxOptions_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1.SELinuxOptions.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(seLinuxOptions_);
                  seLinuxOptions_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.class,
              io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder.class);
    }

    private int bitField0_;
    public static final int RULE_FIELD_NUMBER = 1;
    private volatile java.lang.Object rule_;
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public boolean hasRule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public java.lang.String getRule() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          rule_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate the allowable labels that may be set.
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public com.google.protobuf.ByteString getRuleBytes() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        rule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SELINUXOPTIONS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1.SELinuxOptions seLinuxOptions_;
    /**
     *
     *
     * <pre>
     * seLinuxOptions required to run as; required for MustRunAs
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
     */
    public boolean hasSeLinuxOptions() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * seLinuxOptions required to run as; required for MustRunAs
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
     */
    public io.kubernetes.client.proto.V1.SELinuxOptions getSeLinuxOptions() {
      return seLinuxOptions_ == null
          ? io.kubernetes.client.proto.V1.SELinuxOptions.getDefaultInstance()
          : seLinuxOptions_;
    }
    /**
     *
     *
     * <pre>
     * seLinuxOptions required to run as; required for MustRunAs
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
     */
    public io.kubernetes.client.proto.V1.SELinuxOptionsOrBuilder getSeLinuxOptionsOrBuilder() {
      return seLinuxOptions_ == null
          ? io.kubernetes.client.proto.V1.SELinuxOptions.getDefaultInstance()
          : seLinuxOptions_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, rule_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSeLinuxOptions());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, rule_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSeLinuxOptions());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions other =
          (io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions) obj;

      boolean result = true;
      result = result && (hasRule() == other.hasRule());
      if (hasRule()) {
        result = result && getRule().equals(other.getRule());
      }
      result = result && (hasSeLinuxOptions() == other.hasSeLinuxOptions());
      if (hasSeLinuxOptions()) {
        result = result && getSeLinuxOptions().equals(other.getSeLinuxOptions());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRule()) {
        hash = (37 * hash) + RULE_FIELD_NUMBER;
        hash = (53 * hash) + getRule().hashCode();
      }
      if (hasSeLinuxOptions()) {
        hash = (37 * hash) + SELINUXOPTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getSeLinuxOptions().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
     * Deprecated: use SELinuxStrategyOptions from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions)
        io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.class,
                io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getSeLinuxOptionsFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        rule_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (seLinuxOptionsBuilder_ == null) {
          seLinuxOptions_ = null;
        } else {
          seLinuxOptionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions build() {
        io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions result =
            new io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.rule_ = rule_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (seLinuxOptionsBuilder_ == null) {
          result.seLinuxOptions_ = seLinuxOptions_;
        } else {
          result.seLinuxOptions_ = seLinuxOptionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
                .getDefaultInstance()) return this;
        if (other.hasRule()) {
          bitField0_ |= 0x00000001;
          rule_ = other.rule_;
          onChanged();
        }
        if (other.hasSeLinuxOptions()) {
          mergeSeLinuxOptions(other.getSeLinuxOptions());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object rule_ = "";
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public boolean hasRule() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public java.lang.String getRule() {
        java.lang.Object ref = rule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            rule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public com.google.protobuf.ByteString getRuleBytes() {
        java.lang.Object ref = rule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          rule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRule(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder clearRule() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rule_ = getDefaultInstance().getRule();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate the allowable labels that may be set.
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRuleBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1.SELinuxOptions seLinuxOptions_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.SELinuxOptions,
              io.kubernetes.client.proto.V1.SELinuxOptions.Builder,
              io.kubernetes.client.proto.V1.SELinuxOptionsOrBuilder>
          seLinuxOptionsBuilder_;
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public boolean hasSeLinuxOptions() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public io.kubernetes.client.proto.V1.SELinuxOptions getSeLinuxOptions() {
        if (seLinuxOptionsBuilder_ == null) {
          return seLinuxOptions_ == null
              ? io.kubernetes.client.proto.V1.SELinuxOptions.getDefaultInstance()
              : seLinuxOptions_;
        } else {
          return seLinuxOptionsBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public Builder setSeLinuxOptions(io.kubernetes.client.proto.V1.SELinuxOptions value) {
        if (seLinuxOptionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          seLinuxOptions_ = value;
          onChanged();
        } else {
          seLinuxOptionsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public Builder setSeLinuxOptions(
          io.kubernetes.client.proto.V1.SELinuxOptions.Builder builderForValue) {
        if (seLinuxOptionsBuilder_ == null) {
          seLinuxOptions_ = builderForValue.build();
          onChanged();
        } else {
          seLinuxOptionsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public Builder mergeSeLinuxOptions(io.kubernetes.client.proto.V1.SELinuxOptions value) {
        if (seLinuxOptionsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && seLinuxOptions_ != null
              && seLinuxOptions_
                  != io.kubernetes.client.proto.V1.SELinuxOptions.getDefaultInstance()) {
            seLinuxOptions_ =
                io.kubernetes.client.proto.V1.SELinuxOptions.newBuilder(seLinuxOptions_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            seLinuxOptions_ = value;
          }
          onChanged();
        } else {
          seLinuxOptionsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public Builder clearSeLinuxOptions() {
        if (seLinuxOptionsBuilder_ == null) {
          seLinuxOptions_ = null;
          onChanged();
        } else {
          seLinuxOptionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public io.kubernetes.client.proto.V1.SELinuxOptions.Builder getSeLinuxOptionsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSeLinuxOptionsFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      public io.kubernetes.client.proto.V1.SELinuxOptionsOrBuilder getSeLinuxOptionsOrBuilder() {
        if (seLinuxOptionsBuilder_ != null) {
          return seLinuxOptionsBuilder_.getMessageOrBuilder();
        } else {
          return seLinuxOptions_ == null
              ? io.kubernetes.client.proto.V1.SELinuxOptions.getDefaultInstance()
              : seLinuxOptions_;
        }
      }
      /**
       *
       *
       * <pre>
       * seLinuxOptions required to run as; required for MustRunAs
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.SELinuxOptions,
              io.kubernetes.client.proto.V1.SELinuxOptions.Builder,
              io.kubernetes.client.proto.V1.SELinuxOptionsOrBuilder>
          getSeLinuxOptionsFieldBuilder() {
        if (seLinuxOptionsBuilder_ == null) {
          seLinuxOptionsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1.SELinuxOptions,
                  io.kubernetes.client.proto.V1.SELinuxOptions.Builder,
                  io.kubernetes.client.proto.V1.SELinuxOptionsOrBuilder>(
                  getSeLinuxOptions(), getParentForChildren(), isClean());
          seLinuxOptions_ = null;
        }
        return seLinuxOptionsBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.SELinuxStrategyOptions)
    private static final io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<SELinuxStrategyOptions> PARSER =
        new com.google.protobuf.AbstractParser<SELinuxStrategyOptions>() {
          @java.lang.Override
          public SELinuxStrategyOptions parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new SELinuxStrategyOptions(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<SELinuxStrategyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SELinuxStrategyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.SELinuxStrategyOptions
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ScaleOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.Scale)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     *
     *
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     *
     *
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     *
     *
     * <pre>
     * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     *
     *
     * <pre>
     * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec getSpec();
    /**
     *
     *
     * <pre>
     * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder getSpecOrBuilder();

    /**
     *
     *
     * <pre>
     * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     *
     *
     * <pre>
     * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus getStatus();
    /**
     *
     *
     * <pre>
     * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder getStatusOrBuilder();
  }
  /**
   *
   *
   * <pre>
   * represents a scaling request for a resource.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.Scale}
   */
  public static final class Scale extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.Scale)
      ScaleOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use Scale.newBuilder() to construct.
    private Scale(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private Scale() {}

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private Scale(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = metadata_.toBuilder();
                }
                metadata_ =
                    input.readMessage(
                        io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(metadata_);
                  metadata_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
            case 18:
              {
                io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) == 0x00000002)) {
                  subBuilder = spec_.toBuilder();
                }
                spec_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(spec_);
                  spec_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
            case 26:
              {
                io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) == 0x00000004)) {
                  subBuilder = status_.toBuilder();
                }
                status_ =
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.PARSER,
                        extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(status_);
                  status_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_Scale_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_Scale_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.Scale.class,
              io.kubernetes.client.proto.V1beta1Extensions.Scale.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     *
     *
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }
    /**
     *
     *
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null
          ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
          : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec spec_;
    /**
     *
     *
     * <pre>
     * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec getSpec() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance()
          : spec_;
    }
    /**
     *
     *
     * <pre>
     * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance()
          : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus status_;
    /**
     *
     *
     * <pre>
     * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     *
     *
     * <pre>
     * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus getStatus() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.getDefaultInstance()
          : status_;
    }
    /**
     *
     *
     * <pre>
     * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder getStatusOrBuilder() {
      return status_ == null
          ? io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.getDefaultInstance()
          : status_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.Scale)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.Scale other =
          (io.kubernetes.client.proto.V1beta1Extensions.Scale) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata().equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec().equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus().equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Extensions.Scale prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * represents a scaling request for a resource.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.Scale}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.Scale)
        io.kubernetes.client.proto.V1beta1Extensions.ScaleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Scale_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Scale_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.Scale.class,
                io.kubernetes.client.proto.V1beta1Extensions.Scale.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.Scale.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_Scale_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Scale getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.Scale.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Scale build() {
        io.kubernetes.client.proto.V1beta1Extensions.Scale result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.Scale buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.Scale result =
            new io.kubernetes.client.proto.V1beta1Extensions.Scale(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.Scale) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.Scale) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.Scale other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.Scale.getDefaultInstance())
          return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.Scale parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.Scale) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          metadataBuilder_;
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)
              && metadata_ != null
              && metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
                io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null
              ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()
              : metadata_;
        }
      }
      /**
       *
       *
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta,
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
              io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.Meta.ObjectMeta,
                  io.kubernetes.client.proto.Meta.ObjectMeta.Builder,
                  io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder>
          specBuilder_;
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance()
              : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)
              && spec_ != null
              && spec_
                  != io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance()) {
            spec_ =
                io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.newBuilder(spec_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance()
              : spec_;
        }
      }
      /**
       *
       *
       * <pre>
       * defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder>
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec,
                  io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder>(
                  getSpec(), getParentForChildren(), isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder>
          statusBuilder_;
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.getDefaultInstance()
              : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)
              && status_ != null
              && status_
                  != io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus
                      .getDefaultInstance()) {
            status_ =
                io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.newBuilder(status_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder
          getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null
              ? io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.getDefaultInstance()
              : status_;
        }
      }
      /**
       *
       *
       * <pre>
       * current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.extensions.v1beta1.ScaleStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder>
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus,
                  io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder>(
                  getStatus(), getParentForChildren(), isClean());
          status_ = null;
        }
        return statusBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.Scale)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.Scale)
    private static final io.kubernetes.client.proto.V1beta1Extensions.Scale DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.Scale();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.Scale getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<Scale> PARSER =
        new com.google.protobuf.AbstractParser<Scale>() {
          @java.lang.Override
          public Scale parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new Scale(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<Scale> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Scale> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.Scale getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ScaleSpecOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ScaleSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * desired number of instances for the scaled object.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    boolean hasReplicas();
    /**
     *
     *
     * <pre>
     * desired number of instances for the scaled object.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    int getReplicas();
  }
  /**
   *
   *
   * <pre>
   * describes the attributes of a scale subresource
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ScaleSpec}
   */
  public static final class ScaleSpec extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ScaleSpec)
      ScaleSpecOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ScaleSpec.newBuilder() to construct.
    private ScaleSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ScaleSpec() {
      replicas_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ScaleSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                replicas_ = input.readInt32();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.class,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_;
    /**
     *
     *
     * <pre>
     * desired number of instances for the scaled object.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * desired number of instances for the scaled object.
     * +optional
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public int getReplicas() {
      return replicas_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, replicas_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, replicas_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec other =
          (io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec) obj;

      boolean result = true;
      result = result && (hasReplicas() == other.hasReplicas());
      if (hasReplicas()) {
        result = result && (getReplicas() == other.getReplicas());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * describes the attributes of a scale subresource
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ScaleSpec}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ScaleSpec)
        io.kubernetes.client.proto.V1beta1Extensions.ScaleSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.class,
                io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        replicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec build() {
        io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec result =
            new io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.replicas_ = replicas_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec.getDefaultInstance())
          return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int replicas_;
      /**
       *
       *
       * <pre>
       * desired number of instances for the scaled object.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * desired number of instances for the scaled object.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public int getReplicas() {
        return replicas_;
      }
      /**
       *
       *
       * <pre>
       * desired number of instances for the scaled object.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder setReplicas(int value) {
        bitField0_ |= 0x00000001;
        replicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * desired number of instances for the scaled object.
       * +optional
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ScaleSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ScaleSpec)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ScaleSpec> PARSER =
        new com.google.protobuf.AbstractParser<ScaleSpec>() {
          @java.lang.Override
          public ScaleSpec parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ScaleSpec(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ScaleSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ScaleSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ScaleSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ScaleStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.ScaleStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * actual number of observed instances of the scaled object.
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    boolean hasReplicas();
    /**
     *
     *
     * <pre>
     * actual number of observed instances of the scaled object.
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    int getReplicas();

    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    int getSelectorCount();
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    boolean containsSelector(java.lang.String key);
    /** Use {@link #getSelectorMap()} instead. */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String> getSelector();
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String> getSelectorMap();
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    java.lang.String getSelectorOrDefault(java.lang.String key, java.lang.String defaultValue);
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    java.lang.String getSelectorOrThrow(java.lang.String key);

    /**
     *
     *
     * <pre>
     * label selector for pods that should match the replicas count. This is a serializated
     * version of both map-based and more expressive set-based selectors. This is done to
     * avoid introspection in the clients. The string will be in the same format as the
     * query-param syntax. If the target type only supports map-based selectors, both this
     * field and map-based selector field are populated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional string targetSelector = 3;</code>
     */
    boolean hasTargetSelector();
    /**
     *
     *
     * <pre>
     * label selector for pods that should match the replicas count. This is a serializated
     * version of both map-based and more expressive set-based selectors. This is done to
     * avoid introspection in the clients. The string will be in the same format as the
     * query-param syntax. If the target type only supports map-based selectors, both this
     * field and map-based selector field are populated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional string targetSelector = 3;</code>
     */
    java.lang.String getTargetSelector();
    /**
     *
     *
     * <pre>
     * label selector for pods that should match the replicas count. This is a serializated
     * version of both map-based and more expressive set-based selectors. This is done to
     * avoid introspection in the clients. The string will be in the same format as the
     * query-param syntax. If the target type only supports map-based selectors, both this
     * field and map-based selector field are populated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional string targetSelector = 3;</code>
     */
    com.google.protobuf.ByteString getTargetSelectorBytes();
  }
  /**
   *
   *
   * <pre>
   * represents the current status of a scale subresource.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.ScaleStatus}
   */
  public static final class ScaleStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.ScaleStatus)
      ScaleStatusOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ScaleStatus.newBuilder() to construct.
    private ScaleStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ScaleStatus() {
      replicas_ = 0;
      targetSelector_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ScaleStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                bitField0_ |= 0x00000001;
                replicas_ = input.readInt32();
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  selector_ =
                      com.google.protobuf.MapField.newMapField(
                          SelectorDefaultEntryHolder.defaultEntry);
                  mutable_bitField0_ |= 0x00000002;
                }
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String> selector__ =
                    input.readMessage(
                        SelectorDefaultEntryHolder.defaultEntry.getParserForType(),
                        extensionRegistry);
                selector_.getMutableMap().put(selector__.getKey(), selector__.getValue());
                break;
              }
            case 26:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000002;
                targetSelector_ = bs;
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(int number) {
      switch (number) {
        case 2:
          return internalGetSelector();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.class,
              io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder.class);
    }

    private int bitField0_;
    public static final int REPLICAS_FIELD_NUMBER = 1;
    private int replicas_;
    /**
     *
     *
     * <pre>
     * actual number of observed instances of the scaled object.
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public boolean hasReplicas() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * actual number of observed instances of the scaled object.
     * </pre>
     *
     * <code>optional int32 replicas = 1;</code>
     */
    public int getReplicas() {
      return replicas_;
    }

    public static final int SELECTOR_FIELD_NUMBER = 2;

    private static final class SelectorDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<java.lang.String, java.lang.String> defaultEntry =
          com.google.protobuf.MapEntry.<java.lang.String, java.lang.String>newDefaultInstance(
              io.kubernetes.client.proto.V1beta1Extensions
                  .internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_SelectorEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.STRING,
              "");
    }

    private com.google.protobuf.MapField<java.lang.String, java.lang.String> selector_;

    private com.google.protobuf.MapField<java.lang.String, java.lang.String> internalGetSelector() {
      if (selector_ == null) {
        return com.google.protobuf.MapField.emptyMapField(SelectorDefaultEntryHolder.defaultEntry);
      }
      return selector_;
    }

    public int getSelectorCount() {
      return internalGetSelector().getMap().size();
    }
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    public boolean containsSelector(java.lang.String key) {
      if (key == null) {
        throw new java.lang.NullPointerException();
      }
      return internalGetSelector().getMap().containsKey(key);
    }
    /** Use {@link #getSelectorMap()} instead. */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSelector() {
      return getSelectorMap();
    }
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    public java.util.Map<java.lang.String, java.lang.String> getSelectorMap() {
      return internalGetSelector().getMap();
    }
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    public java.lang.String getSelectorOrDefault(
        java.lang.String key, java.lang.String defaultValue) {
      if (key == null) {
        throw new java.lang.NullPointerException();
      }
      java.util.Map<java.lang.String, java.lang.String> map = internalGetSelector().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     *
     *
     * <pre>
     * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
     * +optional
     * +mapType=atomic
     * </pre>
     *
     * <code>map&lt;string, string&gt; selector = 2;</code>
     */
    public java.lang.String getSelectorOrThrow(java.lang.String key) {
      if (key == null) {
        throw new java.lang.NullPointerException();
      }
      java.util.Map<java.lang.String, java.lang.String> map = internalGetSelector().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int TARGETSELECTOR_FIELD_NUMBER = 3;
    private volatile java.lang.Object targetSelector_;
    /**
     *
     *
     * <pre>
     * label selector for pods that should match the replicas count. This is a serializated
     * version of both map-based and more expressive set-based selectors. This is done to
     * avoid introspection in the clients. The string will be in the same format as the
     * query-param syntax. If the target type only supports map-based selectors, both this
     * field and map-based selector field are populated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional string targetSelector = 3;</code>
     */
    public boolean hasTargetSelector() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     *
     *
     * <pre>
     * label selector for pods that should match the replicas count. This is a serializated
     * version of both map-based and more expressive set-based selectors. This is done to
     * avoid introspection in the clients. The string will be in the same format as the
     * query-param syntax. If the target type only supports map-based selectors, both this
     * field and map-based selector field are populated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional string targetSelector = 3;</code>
     */
    public java.lang.String getTargetSelector() {
      java.lang.Object ref = targetSelector_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          targetSelector_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * label selector for pods that should match the replicas count. This is a serializated
     * version of both map-based and more expressive set-based selectors. This is done to
     * avoid introspection in the clients. The string will be in the same format as the
     * query-param syntax. If the target type only supports map-based selectors, both this
     * field and map-based selector field are populated.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional string targetSelector = 3;</code>
     */
    public com.google.protobuf.ByteString getTargetSelectorBytes() {
      java.lang.Object ref = targetSelector_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        targetSelector_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, replicas_);
      }
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetSelector(), SelectorDefaultEntryHolder.defaultEntry, 2);
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, targetSelector_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, replicas_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry :
          internalGetSelector().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String> selector__ =
            SelectorDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, selector__);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, targetSelector_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus other =
          (io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus) obj;

      boolean result = true;
      result = result && (hasReplicas() == other.hasReplicas());
      if (hasReplicas()) {
        result = result && (getReplicas() == other.getReplicas());
      }
      result = result && internalGetSelector().equals(other.internalGetSelector());
      result = result && (hasTargetSelector() == other.hasTargetSelector());
      if (hasTargetSelector()) {
        result = result && getTargetSelector().equals(other.getTargetSelector());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReplicas()) {
        hash = (37 * hash) + REPLICAS_FIELD_NUMBER;
        hash = (53 * hash) + getReplicas();
      }
      if (!internalGetSelector().getMap().isEmpty()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSelector().hashCode();
      }
      if (hasTargetSelector()) {
        hash = (37 * hash) + TARGETSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getTargetSelector().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * represents the current status of a scale subresource.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.ScaleStatus}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.ScaleStatus)
        io.kubernetes.client.proto.V1beta1Extensions.ScaleStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(int number) {
        switch (number) {
          case 2:
            return internalGetSelector();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(int number) {
        switch (number) {
          case 2:
            return internalGetMutableSelector();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.class,
                io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        replicas_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableSelector().clear();
        targetSelector_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus build() {
        io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus result =
            new io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.replicas_ = replicas_;
        result.selector_ = internalGetSelector();
        result.selector_.makeImmutable();
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000002;
        }
        result.targetSelector_ = targetSelector_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus other) {
        if (other == io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus.getDefaultInstance())
          return this;
        if (other.hasReplicas()) {
          setReplicas(other.getReplicas());
        }
        internalGetMutableSelector().mergeFrom(other.internalGetSelector());
        if (other.hasTargetSelector()) {
          bitField0_ |= 0x00000004;
          targetSelector_ = other.targetSelector_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private int replicas_;
      /**
       *
       *
       * <pre>
       * actual number of observed instances of the scaled object.
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public boolean hasReplicas() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * actual number of observed instances of the scaled object.
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public int getReplicas() {
        return replicas_;
      }
      /**
       *
       *
       * <pre>
       * actual number of observed instances of the scaled object.
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder setReplicas(int value) {
        bitField0_ |= 0x00000001;
        replicas_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * actual number of observed instances of the scaled object.
       * </pre>
       *
       * <code>optional int32 replicas = 1;</code>
       */
      public Builder clearReplicas() {
        bitField0_ = (bitField0_ & ~0x00000001);
        replicas_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<java.lang.String, java.lang.String> selector_;

      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetSelector() {
        if (selector_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SelectorDefaultEntryHolder.defaultEntry);
        }
        return selector_;
      }

      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableSelector() {
        onChanged();
        ;
        if (selector_ == null) {
          selector_ =
              com.google.protobuf.MapField.newMapField(SelectorDefaultEntryHolder.defaultEntry);
        }
        if (!selector_.isMutable()) {
          selector_ = selector_.copy();
        }
        return selector_;
      }

      public int getSelectorCount() {
        return internalGetSelector().getMap().size();
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public boolean containsSelector(java.lang.String key) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        return internalGetSelector().getMap().containsKey(key);
      }
      /** Use {@link #getSelectorMap()} instead. */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSelector() {
        return getSelectorMap();
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public java.util.Map<java.lang.String, java.lang.String> getSelectorMap() {
        return internalGetSelector().getMap();
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public java.lang.String getSelectorOrDefault(
          java.lang.String key, java.lang.String defaultValue) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        java.util.Map<java.lang.String, java.lang.String> map = internalGetSelector().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public java.lang.String getSelectorOrThrow(java.lang.String key) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        java.util.Map<java.lang.String, java.lang.String> map = internalGetSelector().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSelector() {
        internalGetMutableSelector().getMutableMap().clear();
        return this;
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public Builder removeSelector(java.lang.String key) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        internalGetMutableSelector().getMutableMap().remove(key);
        return this;
      }
      /** Use alternate mutation accessors instead. */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getMutableSelector() {
        return internalGetMutableSelector().getMutableMap();
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public Builder putSelector(java.lang.String key, java.lang.String value) {
        if (key == null) {
          throw new java.lang.NullPointerException();
        }
        if (value == null) {
          throw new java.lang.NullPointerException();
        }
        internalGetMutableSelector().getMutableMap().put(key, value);
        return this;
      }
      /**
       *
       *
       * <pre>
       * label query over pods that should match the replicas count. More info: https://kubernetes.io/docs/user-guide/labels#label-selectors
       * +optional
       * +mapType=atomic
       * </pre>
       *
       * <code>map&lt;string, string&gt; selector = 2;</code>
       */
      public Builder putAllSelector(java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSelector().getMutableMap().putAll(values);
        return this;
      }

      private java.lang.Object targetSelector_ = "";
      /**
       *
       *
       * <pre>
       * label selector for pods that should match the replicas count. This is a serializated
       * version of both map-based and more expressive set-based selectors. This is done to
       * avoid introspection in the clients. The string will be in the same format as the
       * query-param syntax. If the target type only supports map-based selectors, both this
       * field and map-based selector field are populated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional string targetSelector = 3;</code>
       */
      public boolean hasTargetSelector() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       *
       *
       * <pre>
       * label selector for pods that should match the replicas count. This is a serializated
       * version of both map-based and more expressive set-based selectors. This is done to
       * avoid introspection in the clients. The string will be in the same format as the
       * query-param syntax. If the target type only supports map-based selectors, both this
       * field and map-based selector field are populated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional string targetSelector = 3;</code>
       */
      public java.lang.String getTargetSelector() {
        java.lang.Object ref = targetSelector_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            targetSelector_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * label selector for pods that should match the replicas count. This is a serializated
       * version of both map-based and more expressive set-based selectors. This is done to
       * avoid introspection in the clients. The string will be in the same format as the
       * query-param syntax. If the target type only supports map-based selectors, both this
       * field and map-based selector field are populated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional string targetSelector = 3;</code>
       */
      public com.google.protobuf.ByteString getTargetSelectorBytes() {
        java.lang.Object ref = targetSelector_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          targetSelector_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * label selector for pods that should match the replicas count. This is a serializated
       * version of both map-based and more expressive set-based selectors. This is done to
       * avoid introspection in the clients. The string will be in the same format as the
       * query-param syntax. If the target type only supports map-based selectors, both this
       * field and map-based selector field are populated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional string targetSelector = 3;</code>
       */
      public Builder setTargetSelector(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        targetSelector_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * label selector for pods that should match the replicas count. This is a serializated
       * version of both map-based and more expressive set-based selectors. This is done to
       * avoid introspection in the clients. The string will be in the same format as the
       * query-param syntax. If the target type only supports map-based selectors, both this
       * field and map-based selector field are populated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional string targetSelector = 3;</code>
       */
      public Builder clearTargetSelector() {
        bitField0_ = (bitField0_ & ~0x00000004);
        targetSelector_ = getDefaultInstance().getTargetSelector();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * label selector for pods that should match the replicas count. This is a serializated
       * version of both map-based and more expressive set-based selectors. This is done to
       * avoid introspection in the clients. The string will be in the same format as the
       * query-param syntax. If the target type only supports map-based selectors, both this
       * field and map-based selector field are populated.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional string targetSelector = 3;</code>
       */
      public Builder setTargetSelectorBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        targetSelector_ = value;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.ScaleStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.ScaleStatus)
    private static final io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<ScaleStatus> PARSER =
        new com.google.protobuf.AbstractParser<ScaleStatus>() {
          @java.lang.Override
          public ScaleStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ScaleStatus(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ScaleStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ScaleStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.ScaleStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface SupplementalGroupsStrategyOptionsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    boolean hasRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    java.lang.String getRule();
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    com.google.protobuf.ByteString getRuleBytes();

    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index);
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    int getRangesCount();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList();
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(int index);
  }
  /**
   *
   *
   * <pre>
   * SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
   * Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions}
   */
  public static final class SupplementalGroupsStrategyOptions
      extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions)
      SupplementalGroupsStrategyOptionsOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use SupplementalGroupsStrategyOptions.newBuilder() to construct.
    private SupplementalGroupsStrategyOptions(
        com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private SupplementalGroupsStrategyOptions() {
      rule_ = "";
      ranges_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private SupplementalGroupsStrategyOptions(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                rule_ = bs;
                break;
              }
            case 18:
              {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  ranges_ =
                      new java.util.ArrayList<
                          io.kubernetes.client.proto.V1beta1Extensions.IDRange>();
                  mutable_bitField0_ |= 0x00000002;
                }
                ranges_.add(
                    input.readMessage(
                        io.kubernetes.client.proto.V1beta1Extensions.IDRange.PARSER,
                        extensionRegistry));
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ = java.util.Collections.unmodifiableList(ranges_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Extensions
          .internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions.class,
              io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions.Builder
                  .class);
    }

    private int bitField0_;
    public static final int RULE_FIELD_NUMBER = 1;
    private volatile java.lang.Object rule_;
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public boolean hasRule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public java.lang.String getRule() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          rule_ = s;
        }
        return s;
      }
    }
    /**
     *
     *
     * <pre>
     * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
     * +optional
     * </pre>
     *
     * <code>optional string rule = 1;</code>
     */
    public com.google.protobuf.ByteString getRuleBytes() {
      java.lang.Object ref = rule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        rule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RANGES_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_;
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
        getRangesOrBuilderList() {
      return ranges_;
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public int getRangesCount() {
      return ranges_.size();
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
      return ranges_.get(index);
    }
    /**
     *
     *
     * <pre>
     * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
     * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
        int index) {
      return ranges_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        output.writeMessage(2, ranges_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, rule_);
      }
      for (int i = 0; i < ranges_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, ranges_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj
          instanceof
          io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions other =
          (io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions) obj;

      boolean result = true;
      result = result && (hasRule() == other.hasRule());
      if (hasRule()) {
        result = result && getRule().equals(other.getRule());
      }
      result = result && getRangesList().equals(other.getRangesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasRule()) {
        hash = (37 * hash) + RULE_FIELD_NUMBER;
        hash = (53 * hash) + getRule().hashCode();
      }
      if (getRangesCount() > 0) {
        hash = (37 * hash) + RANGES_FIELD_NUMBER;
        hash = (53 * hash) + getRangesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(
            java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
     * Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions)
        io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                    .class,
                io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                    .Builder.class);
      }

      // Construct using
      // io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getRangesFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        rule_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Extensions
            .internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
          getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
            .getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
          build() {
        io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
          buildPartial() {
        io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions result =
            new io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions(
                this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.rule_ = rule_;
        if (rangesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            ranges_ = java.util.Collections.unmodifiableList(ranges_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.ranges_ = ranges_;
        } else {
          result.ranges_ = rangesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other
            instanceof
            io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions) {
          return mergeFrom(
              (io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions)
                  other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions other) {
        if (other
            == io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
                .getDefaultInstance()) return this;
        if (other.hasRule()) {
          bitField0_ |= 0x00000001;
          rule_ = other.rule_;
          onChanged();
        }
        if (rangesBuilder_ == null) {
          if (!other.ranges_.isEmpty()) {
            if (ranges_.isEmpty()) {
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureRangesIsMutable();
              ranges_.addAll(other.ranges_);
            }
            onChanged();
          }
        } else {
          if (!other.ranges_.isEmpty()) {
            if (rangesBuilder_.isEmpty()) {
              rangesBuilder_.dispose();
              rangesBuilder_ = null;
              ranges_ = other.ranges_;
              bitField0_ = (bitField0_ & ~0x00000002);
              rangesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getRangesFieldBuilder()
                      : null;
            } else {
              rangesBuilder_.addAllMessages(other.ranges_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
            parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage =
              (io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions)
                  e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int bitField0_;

      private java.lang.Object rule_ = "";
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public boolean hasRule() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public java.lang.String getRule() {
        java.lang.Object ref = rule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            rule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public com.google.protobuf.ByteString getRuleBytes() {
        java.lang.Object ref = rule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
          rule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRule(java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder clearRule() {
        bitField0_ = (bitField0_ & ~0x00000001);
        rule_ = getDefaultInstance().getRule();
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
       * +optional
       * </pre>
       *
       * <code>optional string rule = 1;</code>
       */
      public Builder setRuleBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        rule_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> ranges_ =
          java.util.Collections.emptyList();

      private void ensureRangesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          ranges_ =
              new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Extensions.IDRange>(
                  ranges_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          rangesBuilder_;

      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange> getRangesList() {
        if (rangesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(ranges_);
        } else {
          return rangesBuilder_.getMessageList();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public int getRangesCount() {
        if (rangesBuilder_ == null) {
          return ranges_.size();
        } else {
          return rangesBuilder_.getCount();
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange getRanges(int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessage(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.set(index, value);
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder setRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.set(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange value) {
        if (rangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRangesIsMutable();
          ranges_.add(index, value);
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addRanges(
          int index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder builderForValue) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.add(index, builderForValue.build());
          onChanged();
        } else {
          rangesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder addAllRanges(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRange>
              values) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ranges_);
          onChanged();
        } else {
          rangesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder clearRanges() {
        if (rangesBuilder_ == null) {
          ranges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          rangesBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public Builder removeRanges(int index) {
        if (rangesBuilder_ == null) {
          ensureRangesIsMutable();
          ranges_.remove(index);
          onChanged();
        } else {
          rangesBuilder_.remove(index);
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder getRangesBuilder(
          int index) {
        return getRangesFieldBuilder().getBuilder(index);
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder getRangesOrBuilder(
          int index) {
        if (rangesBuilder_ == null) {
          return ranges_.get(index);
        } else {
          return rangesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesOrBuilderList() {
        if (rangesBuilder_ != null) {
          return rangesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(ranges_);
        }
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder() {
        return getRangesFieldBuilder()
            .addBuilder(io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder addRangesBuilder(
          int index) {
        return getRangesFieldBuilder()
            .addBuilder(
                index, io.kubernetes.client.proto.V1beta1Extensions.IDRange.getDefaultInstance());
      }
      /**
       *
       *
       * <pre>
       * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
       * supplemental group then supply a single range with the same start and end. Required for MustRunAs.
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.extensions.v1beta1.IDRange ranges = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder>
          getRangesBuilderList() {
        return getRangesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Extensions.IDRange,
              io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
              io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>
          getRangesFieldBuilder() {
        if (rangesBuilder_ == null) {
          rangesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRange.Builder,
                  io.kubernetes.client.proto.V1beta1Extensions.IDRangeOrBuilder>(
                  ranges_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          ranges_ = null;
        }
        return rangesBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.extensions.v1beta1.SupplementalGroupsStrategyOptions)
    private static final io.kubernetes.client.proto.V1beta1Extensions
            .SupplementalGroupsStrategyOptions
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE =
          new io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions();
    }

    public static io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated
    public static final com.google.protobuf.Parser<SupplementalGroupsStrategyOptions> PARSER =
        new com.google.protobuf.AbstractParser<SupplementalGroupsStrategyOptions>() {
          @java.lang.Override
          public SupplementalGroupsStrategyOptions parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new SupplementalGroupsStrategyOptions(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<SupplementalGroupsStrategyOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SupplementalGroupsStrategyOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Extensions.SupplementalGroupsStrategyOptions
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_Deployment_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_Deployment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_UpdatedAnnotationsEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_UpdatedAnnotationsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IDRange_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IDRange_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IPBlock_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IPBlock_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_Ingress_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_Ingress_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressList_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressRule_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_Scale_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_Scale_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_SelectorEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_SelectorEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor() {
    return descriptor;
  }

  private static com.google.protobuf.Descriptors.FileDescriptor descriptor;

  static {
    java.lang.String[] descriptorData = {
      "\n-k8s.io/api/extensions/v1beta1/generate"
          + "d.proto\022\035k8s.io.api.extensions.v1beta1\032\""
          + "k8s.io/api/core/v1/generated.proto\0324k8s."
          + "io/apimachinery/pkg/apis/meta/v1/generat"
          + "ed.proto\032/k8s.io/apimachinery/pkg/runtim"
          + "e/generated.proto\0326k8s.io/apimachinery/p"
          + "kg/runtime/schema/generated.proto\0323k8s.i"
          + "o/apimachinery/pkg/util/intstr/generated"
          + ".proto\" \n\020AllowedCSIDriver\022\014\n\004name\030\001 \001(\t"
          + "\"#\n\021AllowedFlexVolume\022\016\n\006driver\030\001 \001(\t\"7\n"
          + "\017AllowedHostPath\022\022\n\npathPrefix\030\001 \001(\t\022\020\n\010"
          + "readOnly\030\002 \001(\010\"\313\001\n\tDaemonSet\022B\n\010metadata"
          + "\030\001 \001(\01320.k8s.io.apimachinery.pkg.apis.me"
          + "ta.v1.ObjectMeta\022:\n\004spec\030\002 \001(\0132,.k8s.io."
          + "api.extensions.v1beta1.DaemonSetSpec\022>\n\006"
          + "status\030\003 \001(\0132..k8s.io.api.extensions.v1b"
          + "eta1.DaemonSetStatus\"\233\001\n\022DaemonSetCondit"
          + "ion\022\014\n\004type\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022F\n\022las"
          + "tTransitionTime\030\003 \001(\0132*.k8s.io.apimachin"
          + "ery.pkg.apis.meta.v1.Time\022\016\n\006reason\030\004 \001("
          + "\t\022\017\n\007message\030\005 \001(\t\"\212\001\n\rDaemonSetList\022@\n\010"
          + "metadata\030\001 \001(\0132..k8s.io.apimachinery.pkg"
          + ".apis.meta.v1.ListMeta\0227\n\005items\030\002 \003(\0132(."
          + "k8s.io.api.extensions.v1beta1.DaemonSet\""
          + "\260\002\n\rDaemonSetSpec\022E\n\010selector\030\001 \001(\01323.k8"
          + "s.io.apimachinery.pkg.apis.meta.v1.Label"
          + "Selector\0225\n\010template\030\002 \001(\0132#.k8s.io.api."
          + "core.v1.PodTemplateSpec\022N\n\016updateStrateg"
          + "y\030\003 \001(\01326.k8s.io.api.extensions.v1beta1."
          + "DaemonSetUpdateStrategy\022\027\n\017minReadySecon"
          + "ds\030\004 \001(\005\022\032\n\022templateGeneration\030\005 \001(\003\022\034\n\024"
          + "revisionHistoryLimit\030\006 \001(\005\"\321\002\n\017DaemonSet"
          + "Status\022\036\n\026currentNumberScheduled\030\001 \001(\005\022\032"
          + "\n\022numberMisscheduled\030\002 \001(\005\022\036\n\026desiredNum"
          + "berScheduled\030\003 \001(\005\022\023\n\013numberReady\030\004 \001(\005\022"
          + "\032\n\022observedGeneration\030\005 \001(\003\022\036\n\026updatedNu"
          + "mberScheduled\030\006 \001(\005\022\027\n\017numberAvailable\030\007"
          + " \001(\005\022\031\n\021numberUnavailable\030\010 \001(\005\022\026\n\016colli"
          + "sionCount\030\t \001(\005\022E\n\nconditions\030\n \003(\01321.k8"
          + "s.io.api.extensions.v1beta1.DaemonSetCon"
          + "dition\"u\n\027DaemonSetUpdateStrategy\022\014\n\004typ"
          + "e\030\001 \001(\t\022L\n\rrollingUpdate\030\002 \001(\01325.k8s.io."
          + "api.extensions.v1beta1.RollingUpdateDaem"
          + "onSet\"\316\001\n\nDeployment\022B\n\010metadata\030\001 \001(\01320"
          + ".k8s.io.apimachinery.pkg.apis.meta.v1.Ob"
          + "jectMeta\022;\n\004spec\030\002 \001(\0132-.k8s.io.api.exte"
          + "nsions.v1beta1.DeploymentSpec\022?\n\006status\030"
          + "\003 \001(\0132/.k8s.io.api.extensions.v1beta1.De"
          + "ploymentStatus\"\340\001\n\023DeploymentCondition\022\014"
          + "\n\004type\030\001 \001(\t\022\016\n\006status\030\002 \001(\t\022B\n\016lastUpda"
          + "teTime\030\006 \001(\0132*.k8s.io.apimachinery.pkg.a"
          + "pis.meta.v1.Time\022F\n\022lastTransitionTime\030\007"
          + " \001(\0132*.k8s.io.apimachinery.pkg.apis.meta"
          + ".v1.Time\022\016\n\006reason\030\004 \001(\t\022\017\n\007message\030\005 \001("
          + "\t\"\214\001\n\016DeploymentList\022@\n\010metadata\030\001 \001(\0132."
          + ".k8s.io.apimachinery.pkg.apis.meta.v1.Li"
          + "stMeta\0228\n\005items\030\002 \003(\0132).k8s.io.api.exten"
          + "sions.v1beta1.Deployment\"\207\002\n\022DeploymentR"
          + "ollback\022\014\n\004name\030\001 \001(\t\022e\n\022updatedAnnotati"
          + "ons\030\002 \003(\0132I.k8s.io.api.extensions.v1beta"
          + "1.DeploymentRollback.UpdatedAnnotationsE"
          + "ntry\022A\n\nrollbackTo\030\003 \001(\0132-.k8s.io.api.ex"
          + "tensions.v1beta1.RollbackConfig\0329\n\027Updat"
          + "edAnnotationsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value"
          + "\030\002 \001(\t:\0028\001\"\220\003\n\016DeploymentSpec\022\020\n\010replica"
          + "s\030\001 \001(\005\022E\n\010selector\030\002 \001(\01323.k8s.io.apima"
          + "chinery.pkg.apis.meta.v1.LabelSelector\0225"
          + "\n\010template\030\003 \001(\0132#.k8s.io.api.core.v1.Po"
          + "dTemplateSpec\022C\n\010strategy\030\004 \001(\01321.k8s.io"
          + ".api.extensions.v1beta1.DeploymentStrate"
          + "gy\022\027\n\017minReadySeconds\030\005 \001(\005\022\034\n\024revisionH"
          + "istoryLimit\030\006 \001(\005\022\016\n\006paused\030\007 \001(\010\022A\n\nrol"
          + "lbackTo\030\010 \001(\0132-.k8s.io.api.extensions.v1"
          + "beta1.RollbackConfig\022\037\n\027progressDeadline"
          + "Seconds\030\t \001(\005\"\210\002\n\020DeploymentStatus\022\032\n\022ob"
          + "servedGeneration\030\001 \001(\003\022\020\n\010replicas\030\002 \001(\005"
          + "\022\027\n\017updatedReplicas\030\003 \001(\005\022\025\n\rreadyReplic"
          + "as\030\007 \001(\005\022\031\n\021availableReplicas\030\004 \001(\005\022\033\n\023u"
          + "navailableReplicas\030\005 \001(\005\022F\n\nconditions\030\006"
          + " \003(\01322.k8s.io.api.extensions.v1beta1.Dep"
          + "loymentCondition\022\026\n\016collisionCount\030\010 \001(\005"
          + "\"q\n\022DeploymentStrategy\022\014\n\004type\030\001 \001(\t\022M\n\r"
          + "rollingUpdate\030\002 \001(\01326.k8s.io.api.extensi"
          + "ons.v1beta1.RollingUpdateDeployment\"^\n\026F"
          + "SGroupStrategyOptions\022\014\n\004rule\030\001 \001(\t\0226\n\006r"
          + "anges\030\002 \003(\0132&.k8s.io.api.extensions.v1be"
          + "ta1.IDRange\"q\n\017HTTPIngressPath\022\014\n\004path\030\001"
          + " \001(\t\022\020\n\010pathType\030\003 \001(\t\022>\n\007backend\030\002 \001(\0132"
          + "-.k8s.io.api.extensions.v1beta1.IngressB"
          + "ackend\"U\n\024HTTPIngressRuleValue\022=\n\005paths\030"
          + "\001 \003(\0132..k8s.io.api.extensions.v1beta1.HT"
          + "TPIngressPath\")\n\rHostPortRange\022\013\n\003min\030\001 "
          + "\001(\005\022\013\n\003max\030\002 \001(\005\"#\n\007IDRange\022\013\n\003min\030\001 \001(\003"
          + "\022\013\n\003max\030\002 \001(\003\"\'\n\007IPBlock\022\014\n\004cidr\030\001 \001(\t\022\016"
          + "\n\006except\030\002 \003(\t\"\305\001\n\007Ingress\022B\n\010metadata\030\001"
          + " \001(\01320.k8s.io.apimachinery.pkg.apis.meta"
          + ".v1.ObjectMeta\0228\n\004spec\030\002 \001(\0132*.k8s.io.ap"
          + "i.extensions.v1beta1.IngressSpec\022<\n\006stat"
          + "us\030\003 \001(\0132,.k8s.io.api.extensions.v1beta1"
          + ".IngressStatus\"\255\001\n\016IngressBackend\022\023\n\013ser"
          + "viceName\030\001 \001(\t\022E\n\013servicePort\030\002 \001(\01320.k8"
          + "s.io.apimachinery.pkg.util.intstr.IntOrS"
          + "tring\022?\n\010resource\030\003 \001(\0132-.k8s.io.api.cor"
          + "e.v1.TypedLocalObjectReference\"\206\001\n\013Ingre"
          + "ssList\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimac"
          + "hinery.pkg.apis.meta.v1.ListMeta\0225\n\005item"
          + "s\030\002 \003(\0132&.k8s.io.api.extensions.v1beta1."
          + "Ingress\"f\n\013IngressRule\022\014\n\004host\030\001 \001(\t\022I\n\020"
          + "ingressRuleValue\030\002 \001(\0132/.k8s.io.api.exte"
          + "nsions.v1beta1.IngressRuleValue\"U\n\020Ingre"
          + "ssRuleValue\022A\n\004http\030\001 \001(\01323.k8s.io.api.e"
          + "xtensions.v1beta1.HTTPIngressRuleValue\"\332"
          + "\001\n\013IngressSpec\022\030\n\020ingressClassName\030\004 \001(\t"
          + "\022>\n\007backend\030\001 \001(\0132-.k8s.io.api.extension"
          + "s.v1beta1.IngressBackend\0226\n\003tls\030\002 \003(\0132)."
          + "k8s.io.api.extensions.v1beta1.IngressTLS"
          + "\0229\n\005rules\030\003 \003(\0132*.k8s.io.api.extensions."
          + "v1beta1.IngressRule\"M\n\rIngressStatus\022<\n\014"
          + "loadBalancer\030\001 \001(\0132&.k8s.io.api.core.v1."
          + "LoadBalancerStatus\"/\n\nIngressTLS\022\r\n\005host"
          + "s\030\001 \003(\t\022\022\n\nsecretName\030\002 \001(\t\"\223\001\n\rNetworkP"
          + "olicy\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimach"
          + "inery.pkg.apis.meta.v1.ObjectMeta\022>\n\004spe"
          + "c\030\002 \001(\01320.k8s.io.api.extensions.v1beta1."
          + "NetworkPolicySpec\"\230\001\n\027NetworkPolicyEgres"
          + "sRule\022?\n\005ports\030\001 \003(\01320.k8s.io.api.extens"
          + "ions.v1beta1.NetworkPolicyPort\022<\n\002to\030\002 \003"
          + "(\01320.k8s.io.api.extensions.v1beta1.Netwo"
          + "rkPolicyPeer\"\233\001\n\030NetworkPolicyIngressRul"
          + "e\022?\n\005ports\030\001 \003(\01320.k8s.io.api.extensions"
          + ".v1beta1.NetworkPolicyPort\022>\n\004from\030\002 \003(\013"
          + "20.k8s.io.api.extensions.v1beta1.Network"
          + "PolicyPeer\"\222\001\n\021NetworkPolicyList\022@\n\010meta"
          + "data\030\001 \001(\0132..k8s.io.apimachinery.pkg.api"
          + "s.meta.v1.ListMeta\022;\n\005items\030\002 \003(\0132,.k8s."
          + "io.api.extensions.v1beta1.NetworkPolicy\""
          + "\346\001\n\021NetworkPolicyPeer\022H\n\013podSelector\030\001 \001"
          + "(\01323.k8s.io.apimachinery.pkg.apis.meta.v"
          + "1.LabelSelector\022N\n\021namespaceSelector\030\002 \001"
          + "(\01323.k8s.io.apimachinery.pkg.apis.meta.v"
          + "1.LabelSelector\0227\n\007ipBlock\030\003 \001(\0132&.k8s.i"
          + "o.api.extensions.v1beta1.IPBlock\"v\n\021Netw"
          + "orkPolicyPort\022\020\n\010protocol\030\001 \001(\t\022>\n\004port\030"
          + "\002 \001(\01320.k8s.io.apimachinery.pkg.util.int"
          + "str.IntOrString\022\017\n\007endPort\030\003 \001(\005\"\204\002\n\021Net"
          + "workPolicySpec\022H\n\013podSelector\030\001 \001(\01323.k8"
          + "s.io.apimachinery.pkg.apis.meta.v1.Label"
          + "Selector\022H\n\007ingress\030\002 \003(\01327.k8s.io.api.e"
          + "xtensions.v1beta1.NetworkPolicyIngressRu"
          + "le\022F\n\006egress\030\003 \003(\01326.k8s.io.api.extensio"
          + "ns.v1beta1.NetworkPolicyEgressRule\022\023\n\013po"
          + "licyTypes\030\004 \003(\t\"\233\001\n\021PodSecurityPolicy\022B\n"
          + "\010metadata\030\001 \001(\01320.k8s.io.apimachinery.pk"
          + "g.apis.meta.v1.ObjectMeta\022B\n\004spec\030\002 \001(\0132"
          + "4.k8s.io.api.extensions.v1beta1.PodSecur"
          + "ityPolicySpec\"\232\001\n\025PodSecurityPolicyList\022"
          + "@\n\010metadata\030\001 \001(\0132..k8s.io.apimachinery."
          + "pkg.apis.meta.v1.ListMeta\022?\n\005items\030\002 \003(\013"
          + "20.k8s.io.api.extensions.v1beta1.PodSecu"
          + "rityPolicy\"\223\t\n\025PodSecurityPolicySpec\022\022\n\n"
          + "privileged\030\001 \001(\010\022\036\n\026defaultAddCapabiliti"
          + "es\030\002 \003(\t\022 \n\030requiredDropCapabilities\030\003 \003"
          + "(\t\022\033\n\023allowedCapabilities\030\004 \003(\t\022\017\n\007volum"
          + "es\030\005 \003(\t\022\023\n\013hostNetwork\030\006 \001(\010\022?\n\thostPor"
          + "ts\030\007 \003(\0132,.k8s.io.api.extensions.v1beta1"
          + ".HostPortRange\022\017\n\007hostPID\030\010 \001(\010\022\017\n\007hostI"
          + "PC\030\t \001(\010\022F\n\007seLinux\030\n \001(\01325.k8s.io.api.e"
          + "xtensions.v1beta1.SELinuxStrategyOptions"
          + "\022J\n\trunAsUser\030\013 \001(\01327.k8s.io.api.extensi"
          + "ons.v1beta1.RunAsUserStrategyOptions\022L\n\n"
          + "runAsGroup\030\026 \001(\01328.k8s.io.api.extensions"
          + ".v1beta1.RunAsGroupStrategyOptions\022\\\n\022su"
          + "pplementalGroups\030\014 \001(\0132@.k8s.io.api.exte"
          + "nsions.v1beta1.SupplementalGroupsStrateg"
          + "yOptions\022F\n\007fsGroup\030\r \001(\01325.k8s.io.api.e"
          + "xtensions.v1beta1.FSGroupStrategyOptions"
          + "\022\036\n\026readOnlyRootFilesystem\030\016 \001(\010\022\'\n\037defa"
          + "ultAllowPrivilegeEscalation\030\017 \001(\010\022 \n\030all"
          + "owPrivilegeEscalation\030\020 \001(\010\022H\n\020allowedHo"
          + "stPaths\030\021 \003(\0132..k8s.io.api.extensions.v1"
          + "beta1.AllowedHostPath\022L\n\022allowedFlexVolu"
          + "mes\030\022 \003(\01320.k8s.io.api.extensions.v1beta"
          + "1.AllowedFlexVolume\022J\n\021allowedCSIDrivers"
          + "\030\027 \003(\0132/.k8s.io.api.extensions.v1beta1.A"
          + "llowedCSIDriver\022\034\n\024allowedUnsafeSysctls\030"
          + "\023 \003(\t\022\030\n\020forbiddenSysctls\030\024 \003(\t\022\035\n\025allow"
          + "edProcMountTypes\030\025 \003(\t\022P\n\014runtimeClass\030\030"
          + " \001(\0132:.k8s.io.api.extensions.v1beta1.Run"
          + "timeClassStrategyOptions\"\316\001\n\nReplicaSet\022"
          + "B\n\010metadata\030\001 \001(\01320.k8s.io.apimachinery."
          + "pkg.apis.meta.v1.ObjectMeta\022;\n\004spec\030\002 \001("
          + "\0132-.k8s.io.api.extensions.v1beta1.Replic"
          + "aSetSpec\022?\n\006status\030\003 \001(\0132/.k8s.io.api.ex"
          + "tensions.v1beta1.ReplicaSetStatus\"\234\001\n\023Re"
          + "plicaSetCondition\022\014\n\004type\030\001 \001(\t\022\016\n\006statu"
          + "s\030\002 \001(\t\022F\n\022lastTransitionTime\030\003 \001(\0132*.k8"
          + "s.io.apimachinery.pkg.apis.meta.v1.Time\022"
          + "\016\n\006reason\030\004 \001(\t\022\017\n\007message\030\005 \001(\t\"\214\001\n\016Rep"
          + "licaSetList\022@\n\010metadata\030\001 \001(\0132..k8s.io.a"
          + "pimachinery.pkg.apis.meta.v1.ListMeta\0228\n"
          + "\005items\030\002 \003(\0132).k8s.io.api.extensions.v1b"
          + "eta1.ReplicaSet\"\271\001\n\016ReplicaSetSpec\022\020\n\010re"
          + "plicas\030\001 \001(\005\022\027\n\017minReadySeconds\030\004 \001(\005\022E\n"
          + "\010selector\030\002 \001(\01323.k8s.io.apimachinery.pk"
          + "g.apis.meta.v1.LabelSelector\0225\n\010template"
          + "\030\003 \001(\0132#.k8s.io.api.core.v1.PodTemplateS"
          + "pec\"\330\001\n\020ReplicaSetStatus\022\020\n\010replicas\030\001 \001"
          + "(\005\022\034\n\024fullyLabeledReplicas\030\002 \001(\005\022\025\n\rread"
          + "yReplicas\030\004 \001(\005\022\031\n\021availableReplicas\030\005 \001"
          + "(\005\022\032\n\022observedGeneration\030\003 \001(\003\022F\n\ncondit"
          + "ions\030\006 \003(\01322.k8s.io.api.extensions.v1bet"
          + "a1.ReplicaSetCondition\"\"\n\016RollbackConfig"
          + "\022\020\n\010revision\030\001 \001(\003\"\246\001\n\026RollingUpdateDaem"
          + "onSet\022H\n\016maxUnavailable\030\001 \001(\01320.k8s.io.a"
          + "pimachinery.pkg.util.intstr.IntOrString\022"
          + "B\n\010maxSurge\030\002 \001(\01320.k8s.io.apimachinery."
          + "pkg.util.intstr.IntOrString\"\247\001\n\027RollingU"
          + "pdateDeployment\022H\n\016maxUnavailable\030\001 \001(\0132"
          + "0.k8s.io.apimachinery.pkg.util.intstr.In"
          + "tOrString\022B\n\010maxSurge\030\002 \001(\01320.k8s.io.api"
          + "machinery.pkg.util.intstr.IntOrString\"a\n"
          + "\031RunAsGroupStrategyOptions\022\014\n\004rule\030\001 \001(\t"
          + "\0226\n\006ranges\030\002 \003(\0132&.k8s.io.api.extensions"
          + ".v1beta1.IDRange\"`\n\030RunAsUserStrategyOpt"
          + "ions\022\014\n\004rule\030\001 \001(\t\0226\n\006ranges\030\002 \003(\0132&.k8s"
          + ".io.api.extensions.v1beta1.IDRange\"`\n\033Ru"
          + "ntimeClassStrategyOptions\022 \n\030allowedRunt"
          + "imeClassNames\030\001 \003(\t\022\037\n\027defaultRuntimeCla"
          + "ssName\030\002 \001(\t\"b\n\026SELinuxStrategyOptions\022\014"
          + "\n\004rule\030\001 \001(\t\022:\n\016seLinuxOptions\030\002 \001(\0132\".k"
          + "8s.io.api.core.v1.SELinuxOptions\"\277\001\n\005Sca"
          + "le\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachine"
          + "ry.pkg.apis.meta.v1.ObjectMeta\0226\n\004spec\030\002"
          + " \001(\0132(.k8s.io.api.extensions.v1beta1.Sca"
          + "leSpec\022:\n\006status\030\003 \001(\0132*.k8s.io.api.exte"
          + "nsions.v1beta1.ScaleStatus\"\035\n\tScaleSpec\022"
          + "\020\n\010replicas\030\001 \001(\005\"\264\001\n\013ScaleStatus\022\020\n\010rep"
          + "licas\030\001 \001(\005\022J\n\010selector\030\002 \003(\01328.k8s.io.a"
          + "pi.extensions.v1beta1.ScaleStatus.Select"
          + "orEntry\022\026\n\016targetSelector\030\003 \001(\t\032/\n\rSelec"
          + "torEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001"
          + "\"i\n!SupplementalGroupsStrategyOptions\022\014\n"
          + "\004rule\030\001 \001(\t\0226\n\006ranges\030\002 \003(\0132&.k8s.io.api"
          + ".extensions.v1beta1.IDRangeB8\n\032io.kubern"
          + "etes.client.protoB\021V1beta1ExtensionsZ\007v1"
          + "beta1"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(
        descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
          io.kubernetes.client.proto.IntStr.getDescriptor(),
        },
        assigner);
    internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_descriptor =
        getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_AllowedCSIDriver_descriptor,
            new java.lang.String[] {
              "Name",
            });
    internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_descriptor =
        getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_AllowedFlexVolume_descriptor,
            new java.lang.String[] {
              "Driver",
            });
    internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_descriptor =
        getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_AllowedHostPath_descriptor,
            new java.lang.String[] {
              "PathPrefix", "ReadOnly",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_descriptor =
        getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DaemonSet_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec", "Status",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_descriptor =
        getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DaemonSetCondition_descriptor,
            new java.lang.String[] {
              "Type", "Status", "LastTransitionTime", "Reason", "Message",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_descriptor =
        getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DaemonSetList_descriptor,
            new java.lang.String[] {
              "Metadata", "Items",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_descriptor =
        getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DaemonSetSpec_descriptor,
            new java.lang.String[] {
              "Selector",
              "Template",
              "UpdateStrategy",
              "MinReadySeconds",
              "TemplateGeneration",
              "RevisionHistoryLimit",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_descriptor =
        getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DaemonSetStatus_descriptor,
            new java.lang.String[] {
              "CurrentNumberScheduled",
              "NumberMisscheduled",
              "DesiredNumberScheduled",
              "NumberReady",
              "ObservedGeneration",
              "UpdatedNumberScheduled",
              "NumberAvailable",
              "NumberUnavailable",
              "CollisionCount",
              "Conditions",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_descriptor =
        getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DaemonSetUpdateStrategy_descriptor,
            new java.lang.String[] {
              "Type", "RollingUpdate",
            });
    internal_static_k8s_io_api_extensions_v1beta1_Deployment_descriptor =
        getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_extensions_v1beta1_Deployment_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_Deployment_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec", "Status",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_descriptor =
        getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentCondition_descriptor,
            new java.lang.String[] {
              "Type", "Status", "LastUpdateTime", "LastTransitionTime", "Reason", "Message",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_descriptor =
        getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentList_descriptor,
            new java.lang.String[] {
              "Metadata", "Items",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor =
        getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor,
            new java.lang.String[] {
              "Name", "UpdatedAnnotations", "RollbackTo",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_UpdatedAnnotationsEntry_descriptor =
        internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_descriptor
            .getNestedTypes()
            .get(0);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_UpdatedAnnotationsEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentRollback_UpdatedAnnotationsEntry_descriptor,
            new java.lang.String[] {
              "Key", "Value",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_descriptor =
        getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentSpec_descriptor,
            new java.lang.String[] {
              "Replicas",
              "Selector",
              "Template",
              "Strategy",
              "MinReadySeconds",
              "RevisionHistoryLimit",
              "Paused",
              "RollbackTo",
              "ProgressDeadlineSeconds",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_descriptor =
        getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentStatus_descriptor,
            new java.lang.String[] {
              "ObservedGeneration",
              "Replicas",
              "UpdatedReplicas",
              "ReadyReplicas",
              "AvailableReplicas",
              "UnavailableReplicas",
              "Conditions",
              "CollisionCount",
            });
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_descriptor =
        getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_DeploymentStrategy_descriptor,
            new java.lang.String[] {
              "Type", "RollingUpdate",
            });
    internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_descriptor =
        getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_FSGroupStrategyOptions_descriptor,
            new java.lang.String[] {
              "Rule", "Ranges",
            });
    internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_descriptor =
        getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressPath_descriptor,
            new java.lang.String[] {
              "Path", "PathType", "Backend",
            });
    internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_descriptor =
        getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_HTTPIngressRuleValue_descriptor,
            new java.lang.String[] {
              "Paths",
            });
    internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_descriptor =
        getDescriptor().getMessageTypes().get(19);
    internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_HostPortRange_descriptor,
            new java.lang.String[] {
              "Min", "Max",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IDRange_descriptor =
        getDescriptor().getMessageTypes().get(20);
    internal_static_k8s_io_api_extensions_v1beta1_IDRange_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IDRange_descriptor,
            new java.lang.String[] {
              "Min", "Max",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IPBlock_descriptor =
        getDescriptor().getMessageTypes().get(21);
    internal_static_k8s_io_api_extensions_v1beta1_IPBlock_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IPBlock_descriptor,
            new java.lang.String[] {
              "Cidr", "Except",
            });
    internal_static_k8s_io_api_extensions_v1beta1_Ingress_descriptor =
        getDescriptor().getMessageTypes().get(22);
    internal_static_k8s_io_api_extensions_v1beta1_Ingress_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_Ingress_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec", "Status",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_descriptor =
        getDescriptor().getMessageTypes().get(23);
    internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressBackend_descriptor,
            new java.lang.String[] {
              "ServiceName", "ServicePort", "Resource",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressList_descriptor =
        getDescriptor().getMessageTypes().get(24);
    internal_static_k8s_io_api_extensions_v1beta1_IngressList_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressList_descriptor,
            new java.lang.String[] {
              "Metadata", "Items",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressRule_descriptor =
        getDescriptor().getMessageTypes().get(25);
    internal_static_k8s_io_api_extensions_v1beta1_IngressRule_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressRule_descriptor,
            new java.lang.String[] {
              "Host", "IngressRuleValue",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_descriptor =
        getDescriptor().getMessageTypes().get(26);
    internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressRuleValue_descriptor,
            new java.lang.String[] {
              "Http",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_descriptor =
        getDescriptor().getMessageTypes().get(27);
    internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressSpec_descriptor,
            new java.lang.String[] {
              "IngressClassName", "Backend", "Tls", "Rules",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_descriptor =
        getDescriptor().getMessageTypes().get(28);
    internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressStatus_descriptor,
            new java.lang.String[] {
              "LoadBalancer",
            });
    internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_descriptor =
        getDescriptor().getMessageTypes().get(29);
    internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_IngressTLS_descriptor,
            new java.lang.String[] {
              "Hosts", "SecretName",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_descriptor =
        getDescriptor().getMessageTypes().get(30);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicy_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_descriptor =
        getDescriptor().getMessageTypes().get(31);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyEgressRule_descriptor,
            new java.lang.String[] {
              "Ports", "To",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_descriptor =
        getDescriptor().getMessageTypes().get(32);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyIngressRule_descriptor,
            new java.lang.String[] {
              "Ports", "From",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_descriptor =
        getDescriptor().getMessageTypes().get(33);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyList_descriptor,
            new java.lang.String[] {
              "Metadata", "Items",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_descriptor =
        getDescriptor().getMessageTypes().get(34);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPeer_descriptor,
            new java.lang.String[] {
              "PodSelector", "NamespaceSelector", "IpBlock",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_descriptor =
        getDescriptor().getMessageTypes().get(35);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicyPort_descriptor,
            new java.lang.String[] {
              "Protocol", "Port", "EndPort",
            });
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_descriptor =
        getDescriptor().getMessageTypes().get(36);
    internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_NetworkPolicySpec_descriptor,
            new java.lang.String[] {
              "PodSelector", "Ingress", "Egress", "PolicyTypes",
            });
    internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_descriptor =
        getDescriptor().getMessageTypes().get(37);
    internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicy_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec",
            });
    internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_descriptor =
        getDescriptor().getMessageTypes().get(38);
    internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicyList_descriptor,
            new java.lang.String[] {
              "Metadata", "Items",
            });
    internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_descriptor =
        getDescriptor().getMessageTypes().get(39);
    internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_PodSecurityPolicySpec_descriptor,
            new java.lang.String[] {
              "Privileged",
              "DefaultAddCapabilities",
              "RequiredDropCapabilities",
              "AllowedCapabilities",
              "Volumes",
              "HostNetwork",
              "HostPorts",
              "HostPID",
              "HostIPC",
              "SeLinux",
              "RunAsUser",
              "RunAsGroup",
              "SupplementalGroups",
              "FsGroup",
              "ReadOnlyRootFilesystem",
              "DefaultAllowPrivilegeEscalation",
              "AllowPrivilegeEscalation",
              "AllowedHostPaths",
              "AllowedFlexVolumes",
              "AllowedCSIDrivers",
              "AllowedUnsafeSysctls",
              "ForbiddenSysctls",
              "AllowedProcMountTypes",
              "RuntimeClass",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_descriptor =
        getDescriptor().getMessageTypes().get(40);
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ReplicaSet_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec", "Status",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_descriptor =
        getDescriptor().getMessageTypes().get(41);
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetCondition_descriptor,
            new java.lang.String[] {
              "Type", "Status", "LastTransitionTime", "Reason", "Message",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_descriptor =
        getDescriptor().getMessageTypes().get(42);
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetList_descriptor,
            new java.lang.String[] {
              "Metadata", "Items",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_descriptor =
        getDescriptor().getMessageTypes().get(43);
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetSpec_descriptor,
            new java.lang.String[] {
              "Replicas", "MinReadySeconds", "Selector", "Template",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_descriptor =
        getDescriptor().getMessageTypes().get(44);
    internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ReplicaSetStatus_descriptor,
            new java.lang.String[] {
              "Replicas",
              "FullyLabeledReplicas",
              "ReadyReplicas",
              "AvailableReplicas",
              "ObservedGeneration",
              "Conditions",
            });
    internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_descriptor =
        getDescriptor().getMessageTypes().get(45);
    internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_RollbackConfig_descriptor,
            new java.lang.String[] {
              "Revision",
            });
    internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_descriptor =
        getDescriptor().getMessageTypes().get(46);
    internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDaemonSet_descriptor,
            new java.lang.String[] {
              "MaxUnavailable", "MaxSurge",
            });
    internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_descriptor =
        getDescriptor().getMessageTypes().get(47);
    internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_RollingUpdateDeployment_descriptor,
            new java.lang.String[] {
              "MaxUnavailable", "MaxSurge",
            });
    internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_descriptor =
        getDescriptor().getMessageTypes().get(48);
    internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_RunAsGroupStrategyOptions_descriptor,
            new java.lang.String[] {
              "Rule", "Ranges",
            });
    internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_descriptor =
        getDescriptor().getMessageTypes().get(49);
    internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_RunAsUserStrategyOptions_descriptor,
            new java.lang.String[] {
              "Rule", "Ranges",
            });
    internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_descriptor =
        getDescriptor().getMessageTypes().get(50);
    internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_RuntimeClassStrategyOptions_descriptor,
            new java.lang.String[] {
              "AllowedRuntimeClassNames", "DefaultRuntimeClassName",
            });
    internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_descriptor =
        getDescriptor().getMessageTypes().get(51);
    internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_SELinuxStrategyOptions_descriptor,
            new java.lang.String[] {
              "Rule", "SeLinuxOptions",
            });
    internal_static_k8s_io_api_extensions_v1beta1_Scale_descriptor =
        getDescriptor().getMessageTypes().get(52);
    internal_static_k8s_io_api_extensions_v1beta1_Scale_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_Scale_descriptor,
            new java.lang.String[] {
              "Metadata", "Spec", "Status",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_descriptor =
        getDescriptor().getMessageTypes().get(53);
    internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ScaleSpec_descriptor,
            new java.lang.String[] {
              "Replicas",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor =
        getDescriptor().getMessageTypes().get(54);
    internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor,
            new java.lang.String[] {
              "Replicas", "Selector", "TargetSelector",
            });
    internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_SelectorEntry_descriptor =
        internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_descriptor
            .getNestedTypes()
            .get(0);
    internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_SelectorEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_ScaleStatus_SelectorEntry_descriptor,
            new java.lang.String[] {
              "Key", "Value",
            });
    internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_descriptor =
        getDescriptor().getMessageTypes().get(55);
    internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_k8s_io_api_extensions_v1beta1_SupplementalGroupsStrategyOptions_descriptor,
            new java.lang.String[] {
              "Rule", "Ranges",
            });
    io.kubernetes.client.proto.V1.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
    io.kubernetes.client.proto.IntStr.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
