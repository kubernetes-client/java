// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/admissionregistration/v1beta1/generated.proto

package io.kubernetes.client.proto;

public final class V1beta1Admissionregistration {
  private V1beta1Admissionregistration() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ApplyConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * expression will be evaluated by CEL to create an apply configuration.
     * ref: https://github.com/google/cel-spec
     * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
     * returns an apply configuration to set a single field:
     * 	Object{
     * 	  spec: Object.spec{
     * 	    serviceAccountName: "example"
     * 	  }
     * 	}
     * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
     * values not included in the apply configuration.
     * CEL expressions have access to the object types needed to create apply configurations:
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * expression will be evaluated by CEL to create an apply configuration.
     * ref: https://github.com/google/cel-spec
     * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
     * returns an apply configuration to set a single field:
     * 	Object{
     * 	  spec: Object.spec{
     * 	    serviceAccountName: "example"
     * 	  }
     * 	}
     * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
     * values not included in the apply configuration.
     * CEL expressions have access to the object types needed to create apply configurations:
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * expression will be evaluated by CEL to create an apply configuration.
     * ref: https://github.com/google/cel-spec
     * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
     * returns an apply configuration to set a single field:
     * 	Object{
     * 	  spec: Object.spec{
     * 	    serviceAccountName: "example"
     * 	  }
     * 	}
     * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
     * values not included in the apply configuration.
     * CEL expressions have access to the object types needed to create apply configurations:
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * ApplyConfiguration defines the desired configuration values of an object.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration}
   */
  public  static final class ApplyConfiguration extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration)
      ApplyConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ApplyConfiguration.newBuilder() to construct.
    private ApplyConfiguration(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ApplyConfiguration() {
      expression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ApplyConfiguration(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              expression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int EXPRESSION_FIELD_NUMBER = 1;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * expression will be evaluated by CEL to create an apply configuration.
     * ref: https://github.com/google/cel-spec
     * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
     * returns an apply configuration to set a single field:
     * 	Object{
     * 	  spec: Object.spec{
     * 	    serviceAccountName: "example"
     * 	  }
     * 	}
     * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
     * values not included in the apply configuration.
     * CEL expressions have access to the object types needed to create apply configurations:
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * expression will be evaluated by CEL to create an apply configuration.
     * ref: https://github.com/google/cel-spec
     * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
     * returns an apply configuration to set a single field:
     * 	Object{
     * 	  spec: Object.spec{
     * 	    serviceAccountName: "example"
     * 	  }
     * 	}
     * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
     * values not included in the apply configuration.
     * CEL expressions have access to the object types needed to create apply configurations:
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * expression will be evaluated by CEL to create an apply configuration.
     * ref: https://github.com/google/cel-spec
     * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
     * returns an apply configuration to set a single field:
     * 	Object{
     * 	  spec: Object.spec{
     * 	    serviceAccountName: "example"
     * 	  }
     * 	}
     * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
     * values not included in the apply configuration.
     * CEL expressions have access to the object types needed to create apply configurations:
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, expression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, expression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration) obj;

      boolean result = true;
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ApplyConfiguration defines the desired configuration values of an object.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.expression_ = expression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance()) return this;
        if (other.hasExpression()) {
          bitField0_ |= 0x00000001;
          expression_ = other.expression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * expression will be evaluated by CEL to create an apply configuration.
       * ref: https://github.com/google/cel-spec
       * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
       * returns an apply configuration to set a single field:
       * 	Object{
       * 	  spec: Object.spec{
       * 	    serviceAccountName: "example"
       * 	  }
       * 	}
       * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
       * values not included in the apply configuration.
       * CEL expressions have access to the object types needed to create apply configurations:
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create an apply configuration.
       * ref: https://github.com/google/cel-spec
       * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
       * returns an apply configuration to set a single field:
       * 	Object{
       * 	  spec: Object.spec{
       * 	    serviceAccountName: "example"
       * 	  }
       * 	}
       * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
       * values not included in the apply configuration.
       * CEL expressions have access to the object types needed to create apply configurations:
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create an apply configuration.
       * ref: https://github.com/google/cel-spec
       * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
       * returns an apply configuration to set a single field:
       * 	Object{
       * 	  spec: Object.spec{
       * 	    serviceAccountName: "example"
       * 	  }
       * 	}
       * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
       * values not included in the apply configuration.
       * CEL expressions have access to the object types needed to create apply configurations:
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create an apply configuration.
       * ref: https://github.com/google/cel-spec
       * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
       * returns an apply configuration to set a single field:
       * 	Object{
       * 	  spec: Object.spec{
       * 	    serviceAccountName: "example"
       * 	  }
       * 	}
       * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
       * values not included in the apply configuration.
       * CEL expressions have access to the object types needed to create apply configurations:
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create an apply configuration.
       * ref: https://github.com/google/cel-spec
       * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
       * returns an apply configuration to set a single field:
       * 	Object{
       * 	  spec: Object.spec{
       * 	    serviceAccountName: "example"
       * 	  }
       * 	}
       * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
       * values not included in the apply configuration.
       * CEL expressions have access to the object types needed to create apply configurations:
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create an apply configuration.
       * ref: https://github.com/google/cel-spec
       * Apply configurations are declared in CEL using object initialization. For example, this CEL expression
       * returns an apply configuration to set a single field:
       * 	Object{
       * 	  spec: Object.spec{
       * 	    serviceAccountName: "example"
       * 	  }
       * 	}
       * Apply configurations may not modify atomic structs, maps or arrays due to the risk of accidental deletion of
       * values not included in the apply configuration.
       * CEL expressions have access to the object types needed to create apply configurations:
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ApplyConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<ApplyConfiguration>() {
      @java.lang.Override
      public ApplyConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ApplyConfiguration(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ApplyConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ApplyConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AuditAnnotationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    boolean hasKey();
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    java.lang.String getKey();
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    boolean hasValueExpression();
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    java.lang.String getValueExpression();
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    com.google.protobuf.ByteString
        getValueExpressionBytes();
  }
  /**
   * <pre>
   * AuditAnnotation describes how to produce an audit annotation for an API request.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.AuditAnnotation}
   */
  public  static final class AuditAnnotation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
      AuditAnnotationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AuditAnnotation.newBuilder() to construct.
    private AuditAnnotation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AuditAnnotation() {
      key_ = "";
      valueExpression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AuditAnnotation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              key_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              valueExpression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    private volatile java.lang.Object key_;
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUEEXPRESSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object valueExpression_;
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    public boolean hasValueExpression() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    public java.lang.String getValueExpression() {
      java.lang.Object ref = valueExpression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          valueExpression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    public com.google.protobuf.ByteString
        getValueExpressionBytes() {
      java.lang.Object ref = valueExpression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        valueExpression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, valueExpression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, valueExpression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation other = (io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation) obj;

      boolean result = true;
      result = result && (hasKey() == other.hasKey());
      if (hasKey()) {
        result = result && getKey()
            .equals(other.getKey());
      }
      result = result && (hasValueExpression() == other.hasValueExpression());
      if (hasValueExpression()) {
        result = result && getValueExpression()
            .equals(other.getValueExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasValueExpression()) {
        hash = (37 * hash) + VALUEEXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getValueExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * AuditAnnotation describes how to produce an audit annotation for an API request.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.AuditAnnotation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        key_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        valueExpression_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation result = new io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.key_ = key_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.valueExpression_ = valueExpression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance()) return this;
        if (other.hasKey()) {
          bitField0_ |= 0x00000001;
          key_ = other.key_;
          onChanged();
        }
        if (other.hasValueExpression()) {
          bitField0_ |= 0x00000002;
          valueExpression_ = other.valueExpression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object key_ = "";
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        key_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        key_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object valueExpression_ = "";
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public boolean hasValueExpression() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public java.lang.String getValueExpression() {
        java.lang.Object ref = valueExpression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            valueExpression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public com.google.protobuf.ByteString
          getValueExpressionBytes() {
        java.lang.Object ref = valueExpression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          valueExpression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public Builder setValueExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        valueExpression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public Builder clearValueExpression() {
        bitField0_ = (bitField0_ & ~0x00000002);
        valueExpression_ = getDefaultInstance().getValueExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public Builder setValueExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        valueExpression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.AuditAnnotation)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<AuditAnnotation>
        PARSER = new com.google.protobuf.AbstractParser<AuditAnnotation>() {
      @java.lang.Override
      public AuditAnnotation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AuditAnnotation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AuditAnnotation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AuditAnnotation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExpressionWarningOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    boolean hasFieldRef();
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    java.lang.String getFieldRef();
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    com.google.protobuf.ByteString
        getFieldRefBytes();

    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    boolean hasWarning();
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    java.lang.String getWarning();
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    com.google.protobuf.ByteString
        getWarningBytes();
  }
  /**
   * <pre>
   * ExpressionWarning is a warning information that targets a specific expression.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ExpressionWarning}
   */
  public  static final class ExpressionWarning extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
      ExpressionWarningOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ExpressionWarning.newBuilder() to construct.
    private ExpressionWarning(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExpressionWarning() {
      fieldRef_ = "";
      warning_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ExpressionWarning(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              fieldRef_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              warning_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder.class);
    }

    private int bitField0_;
    public static final int FIELDREF_FIELD_NUMBER = 2;
    private volatile java.lang.Object fieldRef_;
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    public boolean hasFieldRef() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    public java.lang.String getFieldRef() {
      java.lang.Object ref = fieldRef_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldRef_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    public com.google.protobuf.ByteString
        getFieldRefBytes() {
      java.lang.Object ref = fieldRef_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldRef_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WARNING_FIELD_NUMBER = 3;
    private volatile java.lang.Object warning_;
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    public boolean hasWarning() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    public java.lang.String getWarning() {
      java.lang.Object ref = warning_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          warning_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    public com.google.protobuf.ByteString
        getWarningBytes() {
      java.lang.Object ref = warning_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        warning_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, fieldRef_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, warning_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, fieldRef_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, warning_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning) obj;

      boolean result = true;
      result = result && (hasFieldRef() == other.hasFieldRef());
      if (hasFieldRef()) {
        result = result && getFieldRef()
            .equals(other.getFieldRef());
      }
      result = result && (hasWarning() == other.hasWarning());
      if (hasWarning()) {
        result = result && getWarning()
            .equals(other.getWarning());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasFieldRef()) {
        hash = (37 * hash) + FIELDREF_FIELD_NUMBER;
        hash = (53 * hash) + getFieldRef().hashCode();
      }
      if (hasWarning()) {
        hash = (37 * hash) + WARNING_FIELD_NUMBER;
        hash = (53 * hash) + getWarning().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ExpressionWarning is a warning information that targets a specific expression.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ExpressionWarning}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        fieldRef_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        warning_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.fieldRef_ = fieldRef_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.warning_ = warning_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance()) return this;
        if (other.hasFieldRef()) {
          bitField0_ |= 0x00000001;
          fieldRef_ = other.fieldRef_;
          onChanged();
        }
        if (other.hasWarning()) {
          bitField0_ |= 0x00000002;
          warning_ = other.warning_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object fieldRef_ = "";
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public boolean hasFieldRef() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public java.lang.String getFieldRef() {
        java.lang.Object ref = fieldRef_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldRef_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public com.google.protobuf.ByteString
          getFieldRefBytes() {
        java.lang.Object ref = fieldRef_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldRef_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public Builder setFieldRef(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        fieldRef_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public Builder clearFieldRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        fieldRef_ = getDefaultInstance().getFieldRef();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public Builder setFieldRefBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        fieldRef_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object warning_ = "";
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public boolean hasWarning() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public java.lang.String getWarning() {
        java.lang.Object ref = warning_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            warning_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public com.google.protobuf.ByteString
          getWarningBytes() {
        java.lang.Object ref = warning_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          warning_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public Builder setWarning(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        warning_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public Builder clearWarning() {
        bitField0_ = (bitField0_ & ~0x00000002);
        warning_ = getDefaultInstance().getWarning();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public Builder setWarningBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        warning_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ExpressionWarning)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ExpressionWarning>
        PARSER = new com.google.protobuf.AbstractParser<ExpressionWarning>() {
      @java.lang.Override
      public ExpressionWarning parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ExpressionWarning(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExpressionWarning> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExpressionWarning> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface JSONPatchOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.JSONPatch)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
     * ref: https://github.com/google/cel-spec
     * expression must return an array of JSONPatch values.
     * For example, this CEL expression returns a JSON patch to conditionally modify a value:
     * 	  [
     * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
     * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
     * 	  ]
     * To define an object for the patch value, use Object types. For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/spec/selector",
     * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
     * 	    }
     * 	  ]
     * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
     * 	      value: "test"
     * 	    },
     * 	  ]
     * CEL expressions have access to the types needed to create JSON patches and objects:
     * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
     *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
     *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
     *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
     *   function may be used to escape path keys containing '/' and '~'.
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
     * as well as:
     * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
     * ref: https://github.com/google/cel-spec
     * expression must return an array of JSONPatch values.
     * For example, this CEL expression returns a JSON patch to conditionally modify a value:
     * 	  [
     * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
     * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
     * 	  ]
     * To define an object for the patch value, use Object types. For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/spec/selector",
     * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
     * 	    }
     * 	  ]
     * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
     * 	      value: "test"
     * 	    },
     * 	  ]
     * CEL expressions have access to the types needed to create JSON patches and objects:
     * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
     *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
     *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
     *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
     *   function may be used to escape path keys containing '/' and '~'.
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
     * as well as:
     * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
     * ref: https://github.com/google/cel-spec
     * expression must return an array of JSONPatch values.
     * For example, this CEL expression returns a JSON patch to conditionally modify a value:
     * 	  [
     * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
     * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
     * 	  ]
     * To define an object for the patch value, use Object types. For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/spec/selector",
     * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
     * 	    }
     * 	  ]
     * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
     * 	      value: "test"
     * 	    },
     * 	  ]
     * CEL expressions have access to the types needed to create JSON patches and objects:
     * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
     *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
     *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
     *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
     *   function may be used to escape path keys containing '/' and '~'.
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
     * as well as:
     * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * JSONPatch defines a JSON Patch.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.JSONPatch}
   */
  public  static final class JSONPatch extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.JSONPatch)
      JSONPatchOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use JSONPatch.newBuilder() to construct.
    private JSONPatch(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private JSONPatch() {
      expression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private JSONPatch(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              expression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.class, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder.class);
    }

    private int bitField0_;
    public static final int EXPRESSION_FIELD_NUMBER = 1;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
     * ref: https://github.com/google/cel-spec
     * expression must return an array of JSONPatch values.
     * For example, this CEL expression returns a JSON patch to conditionally modify a value:
     * 	  [
     * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
     * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
     * 	  ]
     * To define an object for the patch value, use Object types. For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/spec/selector",
     * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
     * 	    }
     * 	  ]
     * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
     * 	      value: "test"
     * 	    },
     * 	  ]
     * CEL expressions have access to the types needed to create JSON patches and objects:
     * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
     *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
     *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
     *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
     *   function may be used to escape path keys containing '/' and '~'.
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
     * as well as:
     * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
     * ref: https://github.com/google/cel-spec
     * expression must return an array of JSONPatch values.
     * For example, this CEL expression returns a JSON patch to conditionally modify a value:
     * 	  [
     * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
     * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
     * 	  ]
     * To define an object for the patch value, use Object types. For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/spec/selector",
     * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
     * 	    }
     * 	  ]
     * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
     * 	      value: "test"
     * 	    },
     * 	  ]
     * CEL expressions have access to the types needed to create JSON patches and objects:
     * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
     *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
     *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
     *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
     *   function may be used to escape path keys containing '/' and '~'.
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
     * as well as:
     * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
     * ref: https://github.com/google/cel-spec
     * expression must return an array of JSONPatch values.
     * For example, this CEL expression returns a JSON patch to conditionally modify a value:
     * 	  [
     * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
     * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
     * 	  ]
     * To define an object for the patch value, use Object types. For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/spec/selector",
     * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
     * 	    }
     * 	  ]
     * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
     * 	  [
     * 	    JSONPatch{
     * 	      op: "add",
     * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
     * 	      value: "test"
     * 	    },
     * 	  ]
     * CEL expressions have access to the types needed to create JSON patches and objects:
     * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
     *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
     *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
     *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
     *   function may be used to escape path keys containing '/' and '~'.
     * - 'Object' - CEL type of the resource object.
     * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
     * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
     * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
     * as well as:
     * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Required.
     * </pre>
     *
     * <code>optional string expression = 1;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, expression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, expression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch other = (io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch) obj;

      boolean result = true;
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * JSONPatch defines a JSON Patch.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.JSONPatch}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.JSONPatch)
        io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.class, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch result = new io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.expression_ = expression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance()) return this;
        if (other.hasExpression()) {
          bitField0_ |= 0x00000001;
          expression_ = other.expression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
       * ref: https://github.com/google/cel-spec
       * expression must return an array of JSONPatch values.
       * For example, this CEL expression returns a JSON patch to conditionally modify a value:
       * 	  [
       * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
       * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
       * 	  ]
       * To define an object for the patch value, use Object types. For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/spec/selector",
       * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
       * 	    }
       * 	  ]
       * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
       * 	      value: "test"
       * 	    },
       * 	  ]
       * CEL expressions have access to the types needed to create JSON patches and objects:
       * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
       *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
       *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
       *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
       *   function may be used to escape path keys containing '/' and '~'.
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
       * as well as:
       * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
       * ref: https://github.com/google/cel-spec
       * expression must return an array of JSONPatch values.
       * For example, this CEL expression returns a JSON patch to conditionally modify a value:
       * 	  [
       * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
       * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
       * 	  ]
       * To define an object for the patch value, use Object types. For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/spec/selector",
       * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
       * 	    }
       * 	  ]
       * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
       * 	      value: "test"
       * 	    },
       * 	  ]
       * CEL expressions have access to the types needed to create JSON patches and objects:
       * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
       *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
       *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
       *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
       *   function may be used to escape path keys containing '/' and '~'.
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
       * as well as:
       * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
       * ref: https://github.com/google/cel-spec
       * expression must return an array of JSONPatch values.
       * For example, this CEL expression returns a JSON patch to conditionally modify a value:
       * 	  [
       * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
       * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
       * 	  ]
       * To define an object for the patch value, use Object types. For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/spec/selector",
       * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
       * 	    }
       * 	  ]
       * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
       * 	      value: "test"
       * 	    },
       * 	  ]
       * CEL expressions have access to the types needed to create JSON patches and objects:
       * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
       *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
       *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
       *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
       *   function may be used to escape path keys containing '/' and '~'.
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
       * as well as:
       * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
       * ref: https://github.com/google/cel-spec
       * expression must return an array of JSONPatch values.
       * For example, this CEL expression returns a JSON patch to conditionally modify a value:
       * 	  [
       * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
       * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
       * 	  ]
       * To define an object for the patch value, use Object types. For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/spec/selector",
       * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
       * 	    }
       * 	  ]
       * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
       * 	      value: "test"
       * 	    },
       * 	  ]
       * CEL expressions have access to the types needed to create JSON patches and objects:
       * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
       *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
       *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
       *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
       *   function may be used to escape path keys containing '/' and '~'.
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
       * as well as:
       * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
       * ref: https://github.com/google/cel-spec
       * expression must return an array of JSONPatch values.
       * For example, this CEL expression returns a JSON patch to conditionally modify a value:
       * 	  [
       * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
       * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
       * 	  ]
       * To define an object for the patch value, use Object types. For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/spec/selector",
       * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
       * 	    }
       * 	  ]
       * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
       * 	      value: "test"
       * 	    },
       * 	  ]
       * CEL expressions have access to the types needed to create JSON patches and objects:
       * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
       *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
       *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
       *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
       *   function may be used to escape path keys containing '/' and '~'.
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
       * as well as:
       * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * expression will be evaluated by CEL to create a [JSON patch](https://jsonpatch.com/).
       * ref: https://github.com/google/cel-spec
       * expression must return an array of JSONPatch values.
       * For example, this CEL expression returns a JSON patch to conditionally modify a value:
       * 	  [
       * 	    JSONPatch{op: "test", path: "/spec/example", value: "Red"},
       * 	    JSONPatch{op: "replace", path: "/spec/example", value: "Green"}
       * 	  ]
       * To define an object for the patch value, use Object types. For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/spec/selector",
       * 	      value: Object.spec.selector{matchLabels: {"environment": "test"}}
       * 	    }
       * 	  ]
       * To use strings containing '/' and '~' as JSONPatch path keys, use "jsonpatch.escapeKey". For example:
       * 	  [
       * 	    JSONPatch{
       * 	      op: "add",
       * 	      path: "/metadata/labels/" + jsonpatch.escapeKey("example.com/environment"),
       * 	      value: "test"
       * 	    },
       * 	  ]
       * CEL expressions have access to the types needed to create JSON patches and objects:
       * - 'JSONPatch' - CEL type of JSON Patch operations. JSONPatch has the fields 'op', 'from', 'path' and 'value'.
       *   See [JSON patch](https://jsonpatch.com/) for more details. The 'value' field may be set to any of: string,
       *   integer, array, map or object.  If set, the 'path' and 'from' fields must be set to a
       *   [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901/) string, where the 'jsonpatch.escapeKey()' CEL
       *   function may be used to escape path keys containing '/' and '~'.
       * - 'Object' - CEL type of the resource object.
       * - 'Object.&lt;fieldName&gt;' - CEL type of object field (such as 'Object.spec')
       * - 'Object.&lt;fieldName1&gt;.&lt;fieldName2&gt;...&lt;fieldNameN&gt;` - CEL type of nested field (such as 'Object.spec.containers')
       * CEL expressions have access to the contents of the API request, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * CEL expressions have access to [Kubernetes CEL function libraries](https://kubernetes.io/docs/reference/using-api/cel/#cel-options-language-features-and-libraries)
       * as well as:
       * - 'jsonpatch.escapeKey' - Performs JSONPatch key escaping. '~' and  '/' are escaped as '~0' and `~1' respectively).
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Required.
       * </pre>
       *
       * <code>optional string expression = 1;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.JSONPatch)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.JSONPatch)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<JSONPatch>
        PARSER = new com.google.protobuf.AbstractParser<JSONPatch>() {
      @java.lang.Override
      public JSONPatch parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new JSONPatch(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<JSONPatch> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<JSONPatch> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MatchConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * MatchCondition represents a condition which must be fulfilled for a request to be sent to a webhook.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchCondition}
   */
  public  static final class MatchCondition extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
      MatchConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MatchCondition.newBuilder() to construct.
    private MatchCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MatchCondition() {
      name_ = "";
      expression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MatchCondition(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              expression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPRESSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, expression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, expression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MatchCondition represents a condition which must be fulfilled for a request to be sent to a webhook.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.expression_ = expression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasExpression()) {
          bitField0_ |= 0x00000002;
          expression_ = other.expression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000002);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MatchCondition)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MatchCondition>
        PARSER = new com.google.protobuf.AbstractParser<MatchCondition>() {
      @java.lang.Override
      public MatchCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MatchCondition(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MatchCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MatchCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MatchResourcesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MatchResources)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> 
        getResourceRulesList();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getResourceRules(int index);
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    int getResourceRulesCount();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getResourceRulesOrBuilderList();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
        int index);

    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> 
        getExcludeResourceRulesList();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index);
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    int getExcludeResourceRulesCount();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getExcludeResourceRulesOrBuilderList();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
        int index);

    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();
  }
  /**
   * <pre>
   * MatchResources decides whether to run the admission control policy on an object based
   * on whether it meets the match criteria.
   * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchResources}
   */
  public  static final class MatchResources extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MatchResources)
      MatchResourcesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MatchResources.newBuilder() to construct.
    private MatchResources(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MatchResources() {
      resourceRules_ = java.util.Collections.emptyList();
      excludeResourceRules_ = java.util.Collections.emptyList();
      matchPolicy_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MatchResources(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = namespaceSelector_.toBuilder();
              }
              namespaceSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(namespaceSelector_);
                namespaceSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = objectSelector_.toBuilder();
              }
              objectSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectSelector_);
                objectSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                resourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations>();
                mutable_bitField0_ |= 0x00000004;
              }
              resourceRules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                excludeResourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations>();
                mutable_bitField0_ |= 0x00000008;
              }
              excludeResourceRules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              matchPolicy_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          resourceRules_ = java.util.Collections.unmodifiableList(resourceRules_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          excludeResourceRules_ = java.util.Collections.unmodifiableList(excludeResourceRules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder.class);
    }

    private int bitField0_;
    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int RESOURCERULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> resourceRules_;
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getResourceRulesList() {
      return resourceRules_;
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getResourceRulesOrBuilderList() {
      return resourceRules_;
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public int getResourceRulesCount() {
      return resourceRules_.size();
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getResourceRules(int index) {
      return resourceRules_.get(index);
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
        int index) {
      return resourceRules_.get(index);
    }

    public static final int EXCLUDERESOURCERULES_FIELD_NUMBER = 4;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> excludeResourceRules_;
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getExcludeResourceRulesList() {
      return excludeResourceRules_;
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getExcludeResourceRulesOrBuilderList() {
      return excludeResourceRules_;
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public int getExcludeResourceRulesCount() {
      return excludeResourceRules_.size();
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index) {
      return excludeResourceRules_.get(index);
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
        int index) {
      return excludeResourceRules_.get(index);
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 7;
    private volatile java.lang.Object matchPolicy_;
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getObjectSelector());
      }
      for (int i = 0; i < resourceRules_.size(); i++) {
        output.writeMessage(3, resourceRules_.get(i));
      }
      for (int i = 0; i < excludeResourceRules_.size(); i++) {
        output.writeMessage(4, excludeResourceRules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, matchPolicy_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getObjectSelector());
      }
      for (int i = 0; i < resourceRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, resourceRules_.get(i));
      }
      for (int i = 0; i < excludeResourceRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, excludeResourceRules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, matchPolicy_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources) obj;

      boolean result = true;
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector()
            .equals(other.getNamespaceSelector());
      }
      result = result && (hasObjectSelector() == other.hasObjectSelector());
      if (hasObjectSelector()) {
        result = result && getObjectSelector()
            .equals(other.getObjectSelector());
      }
      result = result && getResourceRulesList()
          .equals(other.getResourceRulesList());
      result = result && getExcludeResourceRulesList()
          .equals(other.getExcludeResourceRulesList());
      result = result && (hasMatchPolicy() == other.hasMatchPolicy());
      if (hasMatchPolicy()) {
        result = result && getMatchPolicy()
            .equals(other.getMatchPolicy());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (getResourceRulesCount() > 0) {
        hash = (37 * hash) + RESOURCERULES_FIELD_NUMBER;
        hash = (53 * hash) + getResourceRulesList().hashCode();
      }
      if (getExcludeResourceRulesCount() > 0) {
        hash = (37 * hash) + EXCLUDERESOURCERULES_FIELD_NUMBER;
        hash = (53 * hash) + getExcludeResourceRulesList().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MatchResources decides whether to run the admission control policy on an object based
     * on whether it meets the match criteria.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MatchResources}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MatchResources)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getResourceRulesFieldBuilder();
          getExcludeResourceRulesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (resourceRulesBuilder_ == null) {
          resourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          resourceRulesBuilder_.clear();
        }
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          excludeResourceRulesBuilder_.clear();
        }
        matchPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (objectSelectorBuilder_ == null) {
          result.objectSelector_ = objectSelector_;
        } else {
          result.objectSelector_ = objectSelectorBuilder_.build();
        }
        if (resourceRulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            resourceRules_ = java.util.Collections.unmodifiableList(resourceRules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.resourceRules_ = resourceRules_;
        } else {
          result.resourceRules_ = resourceRulesBuilder_.build();
        }
        if (excludeResourceRulesBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            excludeResourceRules_ = java.util.Collections.unmodifiableList(excludeResourceRules_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.excludeResourceRules_ = excludeResourceRules_;
        } else {
          result.excludeResourceRules_ = excludeResourceRulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000004;
        }
        result.matchPolicy_ = matchPolicy_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) return this;
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (resourceRulesBuilder_ == null) {
          if (!other.resourceRules_.isEmpty()) {
            if (resourceRules_.isEmpty()) {
              resourceRules_ = other.resourceRules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureResourceRulesIsMutable();
              resourceRules_.addAll(other.resourceRules_);
            }
            onChanged();
          }
        } else {
          if (!other.resourceRules_.isEmpty()) {
            if (resourceRulesBuilder_.isEmpty()) {
              resourceRulesBuilder_.dispose();
              resourceRulesBuilder_ = null;
              resourceRules_ = other.resourceRules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              resourceRulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getResourceRulesFieldBuilder() : null;
            } else {
              resourceRulesBuilder_.addAllMessages(other.resourceRules_);
            }
          }
        }
        if (excludeResourceRulesBuilder_ == null) {
          if (!other.excludeResourceRules_.isEmpty()) {
            if (excludeResourceRules_.isEmpty()) {
              excludeResourceRules_ = other.excludeResourceRules_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureExcludeResourceRulesIsMutable();
              excludeResourceRules_.addAll(other.excludeResourceRules_);
            }
            onChanged();
          }
        } else {
          if (!other.excludeResourceRules_.isEmpty()) {
            if (excludeResourceRulesBuilder_.isEmpty()) {
              excludeResourceRulesBuilder_.dispose();
              excludeResourceRulesBuilder_ = null;
              excludeResourceRules_ = other.excludeResourceRules_;
              bitField0_ = (bitField0_ & ~0x00000008);
              excludeResourceRulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExcludeResourceRulesFieldBuilder() : null;
            } else {
              excludeResourceRulesBuilder_.addAllMessages(other.excludeResourceRules_);
            }
          }
        }
        if (other.hasMatchPolicy()) {
          bitField0_ |= 0x00000010;
          matchPolicy_ = other.matchPolicy_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              namespaceSelector_ != null &&
              namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_).mergeFrom(value).buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              objectSelector_ != null &&
              objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            objectSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(objectSelector_).mergeFrom(value).buildPartial();
          } else {
            objectSelector_ = value;
          }
          onChanged();
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder clearObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
          onChanged();
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> resourceRules_ =
        java.util.Collections.emptyList();
      private void ensureResourceRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          resourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations>(resourceRules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> resourceRulesBuilder_;

      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getResourceRulesList() {
        if (resourceRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(resourceRules_);
        } else {
          return resourceRulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public int getResourceRulesCount() {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.size();
        } else {
          return resourceRulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getResourceRules(int index) {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.get(index);
        } else {
          return resourceRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder setResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.set(index, value);
          onChanged();
        } else {
          resourceRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder setResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.add(value);
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.add(index, value);
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.add(builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addAllResourceRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> values) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, resourceRules_);
          onChanged();
        } else {
          resourceRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder clearResourceRules() {
        if (resourceRulesBuilder_ == null) {
          resourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          resourceRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder removeResourceRules(int index) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.remove(index);
          onChanged();
        } else {
          resourceRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder getResourceRulesBuilder(
          int index) {
        return getResourceRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
          int index) {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.get(index);  } else {
          return resourceRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
           getResourceRulesOrBuilderList() {
        if (resourceRulesBuilder_ != null) {
          return resourceRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(resourceRules_);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addResourceRulesBuilder() {
        return getResourceRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addResourceRulesBuilder(
          int index) {
        return getResourceRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder> 
           getResourceRulesBuilderList() {
        return getResourceRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
          getResourceRulesFieldBuilder() {
        if (resourceRulesBuilder_ == null) {
          resourceRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder>(
                  resourceRules_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          resourceRules_ = null;
        }
        return resourceRulesBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> excludeResourceRules_ =
        java.util.Collections.emptyList();
      private void ensureExcludeResourceRulesIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          excludeResourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations>(excludeResourceRules_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> excludeResourceRulesBuilder_;

      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> getExcludeResourceRulesList() {
        if (excludeResourceRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(excludeResourceRules_);
        } else {
          return excludeResourceRulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public int getExcludeResourceRulesCount() {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.size();
        } else {
          return excludeResourceRulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index) {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.get(index);
        } else {
          return excludeResourceRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder setExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.set(index, value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder setExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(index, value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addAllExcludeResourceRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations> values) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, excludeResourceRules_);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder clearExcludeResourceRules() {
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder removeExcludeResourceRules(int index) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.remove(index);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder getExcludeResourceRulesBuilder(
          int index) {
        return getExcludeResourceRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
          int index) {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.get(index);  } else {
          return excludeResourceRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
           getExcludeResourceRulesOrBuilderList() {
        if (excludeResourceRulesBuilder_ != null) {
          return excludeResourceRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(excludeResourceRules_);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addExcludeResourceRulesBuilder() {
        return getExcludeResourceRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder addExcludeResourceRulesBuilder(
          int index) {
        return getExcludeResourceRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder> 
           getExcludeResourceRulesBuilderList() {
        return getExcludeResourceRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
          getExcludeResourceRulesFieldBuilder() {
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder>(
                  excludeResourceRules_,
                  ((bitField0_ & 0x00000008) == 0x00000008),
                  getParentForChildren(),
                  isClean());
          excludeResourceRules_ = null;
        }
        return excludeResourceRulesBuilder_;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public Builder clearMatchPolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MatchResources)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MatchResources)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MatchResources>
        PARSER = new com.google.protobuf.AbstractParser<MatchResources>() {
      @java.lang.Override
      public MatchResources parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MatchResources(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MatchResources> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MatchResources> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingAdmissionPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * MutatingAdmissionPolicy describes the definition of an admission mutation policy that mutates the object coming into admission chain.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy}
   */
  public  static final class MutatingAdmissionPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy)
      MutatingAdmissionPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingAdmissionPolicy.newBuilder() to construct.
    private MutatingAdmissionPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingAdmissionPolicy() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingAdmissionPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingAdmissionPolicy describes the definition of an admission mutation policy that mutates the object coming into admission chain.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingAdmissionPolicy>
        PARSER = new com.google.protobuf.AbstractParser<MutatingAdmissionPolicy>() {
      @java.lang.Override
      public MutatingAdmissionPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingAdmissionPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingAdmissionPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingAdmissionPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingAdmissionPolicyBindingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * MutatingAdmissionPolicyBinding binds the MutatingAdmissionPolicy with parametrized resources.
   * MutatingAdmissionPolicyBinding and the optional parameter resource together define how cluster administrators
   * configure policies for clusters.
   * For a given admission request, each binding will cause its policy to be
   * evaluated N times, where N is 1 for policies/bindings that don't use
   * params, otherwise N is the number of parameters selected by the binding.
   * Each evaluation is constrained by a [runtime cost budget](https://kubernetes.io/docs/reference/using-api/cel/#runtime-cost-budget).
   * Adding/removing policies, bindings, or params can not affect whether a
   * given (policy, binding, param) combination is within its own CEL budget.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding}
   */
  public  static final class MutatingAdmissionPolicyBinding extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding)
      MutatingAdmissionPolicyBindingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingAdmissionPolicyBinding.newBuilder() to construct.
    private MutatingAdmissionPolicyBinding(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingAdmissionPolicyBinding() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingAdmissionPolicyBinding(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingAdmissionPolicyBinding binds the MutatingAdmissionPolicy with parametrized resources.
     * MutatingAdmissionPolicyBinding and the optional parameter resource together define how cluster administrators
     * configure policies for clusters.
     * For a given admission request, each binding will cause its policy to be
     * evaluated N times, where N is 1 for policies/bindings that don't use
     * params, otherwise N is the number of parameters selected by the binding.
     * Each evaluation is constrained by a [runtime cost budget](https://kubernetes.io/docs/reference/using-api/cel/#runtime-cost-budget).
     * Adding/removing policies, bindings, or params can not affect whether a
     * given (policy, binding, param) combination is within its own CEL budget.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the MutatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingAdmissionPolicyBinding>
        PARSER = new com.google.protobuf.AbstractParser<MutatingAdmissionPolicyBinding>() {
      @java.lang.Override
      public MutatingAdmissionPolicyBinding parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingAdmissionPolicyBinding(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingAdmissionPolicyBinding> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingAdmissionPolicyBinding> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingAdmissionPolicyBindingListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding> 
        getItemsList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding getItems(int index);
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingAdmissionPolicyBindingList is a list of MutatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList}
   */
  public  static final class MutatingAdmissionPolicyBindingList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList)
      MutatingAdmissionPolicyBindingListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingAdmissionPolicyBindingList.newBuilder() to construct.
    private MutatingAdmissionPolicyBindingList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingAdmissionPolicyBindingList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingAdmissionPolicyBindingList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding> items_;
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingAdmissionPolicyBindingList is a list of MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingAdmissionPolicyBindingList>
        PARSER = new com.google.protobuf.AbstractParser<MutatingAdmissionPolicyBindingList>() {
      @java.lang.Override
      public MutatingAdmissionPolicyBindingList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingAdmissionPolicyBindingList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingAdmissionPolicyBindingList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingAdmissionPolicyBindingList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingAdmissionPolicyBindingSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    boolean hasPolicyName();
    /**
     * <pre>
     * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    java.lang.String getPolicyName();
    /**
     * <pre>
     * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    com.google.protobuf.ByteString
        getPolicyNameBytes();

    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    boolean hasParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder();

    /**
     * <pre>
     * matchResources limits what resources match this binding and may be mutated by it.
     * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
     * matchConditions before the resource may be mutated.
     * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
     * and matchConditions must match for the resource to be mutated.
     * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
     * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    boolean hasMatchResources();
    /**
     * <pre>
     * matchResources limits what resources match this binding and may be mutated by it.
     * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
     * matchConditions before the resource may be mutated.
     * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
     * and matchConditions must match for the resource to be mutated.
     * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
     * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources();
    /**
     * <pre>
     * matchResources limits what resources match this binding and may be mutated by it.
     * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
     * matchConditions before the resource may be mutated.
     * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
     * and matchConditions must match for the resource to be mutated.
     * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
     * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder();
  }
  /**
   * <pre>
   * MutatingAdmissionPolicyBindingSpec is the specification of the MutatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec}
   */
  public  static final class MutatingAdmissionPolicyBindingSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec)
      MutatingAdmissionPolicyBindingSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingAdmissionPolicyBindingSpec.newBuilder() to construct.
    private MutatingAdmissionPolicyBindingSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingAdmissionPolicyBindingSpec() {
      policyName_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingAdmissionPolicyBindingSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              policyName_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = paramRef_.toBuilder();
              }
              paramRef_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paramRef_);
                paramRef_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = matchResources_.toBuilder();
              }
              matchResources_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matchResources_);
                matchResources_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder.class);
    }

    private int bitField0_;
    public static final int POLICYNAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object policyName_;
    /**
     * <pre>
     * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public boolean hasPolicyName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public java.lang.String getPolicyName() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          policyName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public com.google.protobuf.ByteString
        getPolicyNameBytes() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        policyName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARAMREF_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef paramRef_;
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    public boolean hasParamRef() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }

    public static final int MATCHRESOURCES_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchResources_;
    /**
     * <pre>
     * matchResources limits what resources match this binding and may be mutated by it.
     * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
     * matchConditions before the resource may be mutated.
     * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
     * and matchConditions must match for the resource to be mutated.
     * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
     * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    public boolean hasMatchResources() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * matchResources limits what resources match this binding and may be mutated by it.
     * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
     * matchConditions before the resource may be mutated.
     * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
     * and matchConditions must match for the resource to be mutated.
     * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
     * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }
    /**
     * <pre>
     * matchResources limits what resources match this binding and may be mutated by it.
     * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
     * matchConditions before the resource may be mutated.
     * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
     * and matchConditions must match for the resource to be mutated.
     * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
     * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, policyName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getMatchResources());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, policyName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getMatchResources());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec) obj;

      boolean result = true;
      result = result && (hasPolicyName() == other.hasPolicyName());
      if (hasPolicyName()) {
        result = result && getPolicyName()
            .equals(other.getPolicyName());
      }
      result = result && (hasParamRef() == other.hasParamRef());
      if (hasParamRef()) {
        result = result && getParamRef()
            .equals(other.getParamRef());
      }
      result = result && (hasMatchResources() == other.hasMatchResources());
      if (hasMatchResources()) {
        result = result && getMatchResources()
            .equals(other.getMatchResources());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPolicyName()) {
        hash = (37 * hash) + POLICYNAME_FIELD_NUMBER;
        hash = (53 * hash) + getPolicyName().hashCode();
      }
      if (hasParamRef()) {
        hash = (37 * hash) + PARAMREF_FIELD_NUMBER;
        hash = (53 * hash) + getParamRef().hashCode();
      }
      if (hasMatchResources()) {
        hash = (37 * hash) + MATCHRESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getMatchResources().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingAdmissionPolicyBindingSpec is the specification of the MutatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParamRefFieldBuilder();
          getMatchResourcesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        policyName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (paramRefBuilder_ == null) {
          paramRef_ = null;
        } else {
          paramRefBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (matchResourcesBuilder_ == null) {
          matchResources_ = null;
        } else {
          matchResourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.policyName_ = policyName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (paramRefBuilder_ == null) {
          result.paramRef_ = paramRef_;
        } else {
          result.paramRef_ = paramRefBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (matchResourcesBuilder_ == null) {
          result.matchResources_ = matchResources_;
        } else {
          result.matchResources_ = matchResourcesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec.getDefaultInstance()) return this;
        if (other.hasPolicyName()) {
          bitField0_ |= 0x00000001;
          policyName_ = other.policyName_;
          onChanged();
        }
        if (other.hasParamRef()) {
          mergeParamRef(other.getParamRef());
        }
        if (other.hasMatchResources()) {
          mergeMatchResources(other.getMatchResources());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object policyName_ = "";
      /**
       * <pre>
       * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public boolean hasPolicyName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public java.lang.String getPolicyName() {
        java.lang.Object ref = policyName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            policyName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public com.google.protobuf.ByteString
          getPolicyNameBytes() {
        java.lang.Object ref = policyName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          policyName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder setPolicyName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        policyName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder clearPolicyName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        policyName_ = getDefaultInstance().getPolicyName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * policyName references a MutatingAdmissionPolicy name which the MutatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder setPolicyNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        policyName_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef paramRef_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder> paramRefBuilder_;
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public boolean hasParamRef() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef() {
        if (paramRefBuilder_ == null) {
          return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        } else {
          return paramRefBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramRef_ = value;
          onChanged();
        } else {
          paramRefBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder builderForValue) {
        if (paramRefBuilder_ == null) {
          paramRef_ = builderForValue.build();
          onChanged();
        } else {
          paramRefBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder mergeParamRef(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              paramRef_ != null &&
              paramRef_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance()) {
            paramRef_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.newBuilder(paramRef_).mergeFrom(value).buildPartial();
          } else {
            paramRef_ = value;
          }
          onChanged();
        } else {
          paramRefBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder clearParamRef() {
        if (paramRefBuilder_ == null) {
          paramRef_ = null;
          onChanged();
        } else {
          paramRefBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder getParamRefBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getParamRefFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
        if (paramRefBuilder_ != null) {
          return paramRefBuilder_.getMessageOrBuilder();
        } else {
          return paramRef_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in spec.ParamKind of the bound MutatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the MutatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder> 
          getParamRefFieldBuilder() {
        if (paramRefBuilder_ == null) {
          paramRefBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder>(
                  getParamRef(),
                  getParentForChildren(),
                  isClean());
          paramRef_ = null;
        }
        return paramRefBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchResources_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> matchResourcesBuilder_;
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public boolean hasMatchResources() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources() {
        if (matchResourcesBuilder_ == null) {
          return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        } else {
          return matchResourcesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchResources_ = value;
          onChanged();
        } else {
          matchResourcesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = builderForValue.build();
          onChanged();
        } else {
          matchResourcesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder mergeMatchResources(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              matchResources_ != null &&
              matchResources_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) {
            matchResources_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.newBuilder(matchResources_).mergeFrom(value).buildPartial();
          } else {
            matchResources_ = value;
          }
          onChanged();
        } else {
          matchResourcesBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder clearMatchResources() {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = null;
          onChanged();
        } else {
          matchResourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder getMatchResourcesBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getMatchResourcesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
        if (matchResourcesBuilder_ != null) {
          return matchResourcesBuilder_.getMessageOrBuilder();
        } else {
          return matchResources_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        }
      }
      /**
       * <pre>
       * matchResources limits what resources match this binding and may be mutated by it.
       * Note that if matchResources matches a resource, the resource must also match a policy's matchConstraints and
       * matchConditions before the resource may be mutated.
       * When matchResources is unset, it does not constrain resource matching, and only the policy's matchConstraints
       * and matchConditions must match for the resource to be mutated.
       * Additionally, matchResources.resourceRules are optional and do not constraint matching when unset.
       * Note that this is differs from MutatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchResourcesFieldBuilder() {
        if (matchResourcesBuilder_ == null) {
          matchResourcesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchResources(),
                  getParentForChildren(),
                  isClean());
          matchResources_ = null;
        }
        return matchResourcesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingAdmissionPolicyBindingSpec>
        PARSER = new com.google.protobuf.AbstractParser<MutatingAdmissionPolicyBindingSpec>() {
      @java.lang.Override
      public MutatingAdmissionPolicyBindingSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingAdmissionPolicyBindingSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingAdmissionPolicyBindingSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingAdmissionPolicyBindingSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingAdmissionPolicyListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy getItems(int index);
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingAdmissionPolicyList is a list of MutatingAdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList}
   */
  public  static final class MutatingAdmissionPolicyList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList)
      MutatingAdmissionPolicyListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingAdmissionPolicyList.newBuilder() to construct.
    private MutatingAdmissionPolicyList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingAdmissionPolicyList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingAdmissionPolicyList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy> items_;
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingAdmissionPolicyList is a list of MutatingAdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingAdmissionPolicyList>
        PARSER = new com.google.protobuf.AbstractParser<MutatingAdmissionPolicyList>() {
      @java.lang.Override
      public MutatingAdmissionPolicyList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingAdmissionPolicyList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingAdmissionPolicyList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingAdmissionPolicyList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicyList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingAdmissionPolicySpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * paramKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    boolean hasParamKind();
    /**
     * <pre>
     * paramKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind();
    /**
     * <pre>
     * paramKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder();

    /**
     * <pre>
     * matchConstraints specifies what resources this policy is designed to validate.
     * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    boolean hasMatchConstraints();
    /**
     * <pre>
     * matchConstraints specifies what resources this policy is designed to validate.
     * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints();
    /**
     * <pre>
     * matchConstraints specifies what resources this policy is designed to validate.
     * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder();

    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> 
        getVariablesList();
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index);
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    int getVariablesCount();
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList();
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index);

    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation> 
        getMutationsList();
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation getMutations(int index);
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    int getMutationsCount();
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder> 
        getMutationsOrBuilderList();
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder getMutationsOrBuilder(
        int index);

    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if paramKind refers to a non-existent Kind.
     * A binding is invalid if paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 5;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if paramKind refers to a non-existent Kind.
     * A binding is invalid if paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 5;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if paramKind refers to a non-existent Kind.
     * A binding is invalid if paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 5;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
     * as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: These mutations will not be called more than once per binding in a single admission evaluation.
     * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
     * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
     * reinvoked when mutations change the object after this mutation is invoked.
     * Required.
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 7;</code>
     */
    boolean hasReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
     * as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: These mutations will not be called more than once per binding in a single admission evaluation.
     * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
     * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
     * reinvoked when mutations change the object after this mutation is invoked.
     * Required.
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 7;</code>
     */
    java.lang.String getReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
     * as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: These mutations will not be called more than once per binding in a single admission evaluation.
     * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
     * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
     * reinvoked when mutations change the object after this mutation is invoked.
     * Required.
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 7;</code>
     */
    com.google.protobuf.ByteString
        getReinvocationPolicyBytes();
  }
  /**
   * <pre>
   * MutatingAdmissionPolicySpec is the specification of the desired behavior of the admission policy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec}
   */
  public  static final class MutatingAdmissionPolicySpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec)
      MutatingAdmissionPolicySpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingAdmissionPolicySpec.newBuilder() to construct.
    private MutatingAdmissionPolicySpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingAdmissionPolicySpec() {
      variables_ = java.util.Collections.emptyList();
      mutations_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchConditions_ = java.util.Collections.emptyList();
      reinvocationPolicy_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingAdmissionPolicySpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = paramKind_.toBuilder();
              }
              paramKind_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paramKind_);
                paramKind_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = matchConstraints_.toBuilder();
              }
              matchConstraints_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matchConstraints_);
                matchConstraints_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable>();
                mutable_bitField0_ |= 0x00000004;
              }
              variables_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                mutations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation>();
                mutable_bitField0_ |= 0x00000008;
              }
              mutations_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.PARSER, extensionRegistry));
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000020;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              reinvocationPolicy_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          variables_ = java.util.Collections.unmodifiableList(variables_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          mutations_ = java.util.Collections.unmodifiableList(mutations_);
        }
        if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder.class);
    }

    private int bitField0_;
    public static final int PARAMKIND_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind paramKind_;
    /**
     * <pre>
     * paramKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    public boolean hasParamKind() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * paramKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }
    /**
     * <pre>
     * paramKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }

    public static final int MATCHCONSTRAINTS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchConstraints_;
    /**
     * <pre>
     * matchConstraints specifies what resources this policy is designed to validate.
     * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    public boolean hasMatchConstraints() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * matchConstraints specifies what resources this policy is designed to validate.
     * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }
    /**
     * <pre>
     * matchConstraints specifies what resources this policy is designed to validate.
     * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
     * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
     * '*' matches CREATE, UPDATE and CONNECT.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }

    public static final int VARIABLES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> variables_;
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> getVariablesList() {
      return variables_;
    }
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList() {
      return variables_;
    }
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    public int getVariablesCount() {
      return variables_.size();
    }
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index) {
      return variables_.get(index);
    }
    /**
     * <pre>
     * variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except matchConditions because matchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, variables must be sorted by the order of first appearance and acyclic.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index) {
      return variables_.get(index);
    }

    public static final int MUTATIONS_FIELD_NUMBER = 4;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation> mutations_;
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation> getMutationsList() {
      return mutations_;
    }
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder> 
        getMutationsOrBuilderList() {
      return mutations_;
    }
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    public int getMutationsCount() {
      return mutations_.size();
    }
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation getMutations(int index) {
      return mutations_.get(index);
    }
    /**
     * <pre>
     * mutations contain operations to perform on matching objects.
     * mutations may not be empty; a minimum of one mutation is required.
     * mutations are evaluated in order, and are reinvoked according to
     * the reinvocationPolicy.
     * The mutations of a policy are invoked for each binding of this policy
     * and reinvocation of mutations occurs on a per binding basis.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder getMutationsOrBuilder(
        int index) {
      return mutations_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 5;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if paramKind refers to a non-existent Kind.
     * A binding is invalid if paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 5;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if paramKind refers to a non-existent Kind.
     * A binding is invalid if paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 5;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if paramKind refers to a non-existent Kind.
     * A binding is invalid if paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 5;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 6;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * matchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the matchConstraints.
     * An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    public static final int REINVOCATIONPOLICY_FIELD_NUMBER = 7;
    private volatile java.lang.Object reinvocationPolicy_;
    /**
     * <pre>
     * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
     * as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: These mutations will not be called more than once per binding in a single admission evaluation.
     * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
     * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
     * reinvoked when mutations change the object after this mutation is invoked.
     * Required.
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 7;</code>
     */
    public boolean hasReinvocationPolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
     * as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: These mutations will not be called more than once per binding in a single admission evaluation.
     * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
     * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
     * reinvoked when mutations change the object after this mutation is invoked.
     * Required.
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 7;</code>
     */
    public java.lang.String getReinvocationPolicy() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reinvocationPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
     * as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: These mutations will not be called more than once per binding in a single admission evaluation.
     * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
     * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
     * reinvoked when mutations change the object after this mutation is invoked.
     * Required.
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 7;</code>
     */
    public com.google.protobuf.ByteString
        getReinvocationPolicyBytes() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reinvocationPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getMatchConstraints());
      }
      for (int i = 0; i < variables_.size(); i++) {
        output.writeMessage(3, variables_.get(i));
      }
      for (int i = 0; i < mutations_.size(); i++) {
        output.writeMessage(4, mutations_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, failurePolicy_);
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(6, matchConditions_.get(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, reinvocationPolicy_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMatchConstraints());
      }
      for (int i = 0; i < variables_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, variables_.get(i));
      }
      for (int i = 0; i < mutations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, mutations_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, failurePolicy_);
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, matchConditions_.get(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, reinvocationPolicy_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec) obj;

      boolean result = true;
      result = result && (hasParamKind() == other.hasParamKind());
      if (hasParamKind()) {
        result = result && getParamKind()
            .equals(other.getParamKind());
      }
      result = result && (hasMatchConstraints() == other.hasMatchConstraints());
      if (hasMatchConstraints()) {
        result = result && getMatchConstraints()
            .equals(other.getMatchConstraints());
      }
      result = result && getVariablesList()
          .equals(other.getVariablesList());
      result = result && getMutationsList()
          .equals(other.getMutationsList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && (hasReinvocationPolicy() == other.hasReinvocationPolicy());
      if (hasReinvocationPolicy()) {
        result = result && getReinvocationPolicy()
            .equals(other.getReinvocationPolicy());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParamKind()) {
        hash = (37 * hash) + PARAMKIND_FIELD_NUMBER;
        hash = (53 * hash) + getParamKind().hashCode();
      }
      if (hasMatchConstraints()) {
        hash = (37 * hash) + MATCHCONSTRAINTS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConstraints().hashCode();
      }
      if (getVariablesCount() > 0) {
        hash = (37 * hash) + VARIABLES_FIELD_NUMBER;
        hash = (53 * hash) + getVariablesList().hashCode();
      }
      if (getMutationsCount() > 0) {
        hash = (37 * hash) + MUTATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMutationsList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      if (hasReinvocationPolicy()) {
        hash = (37 * hash) + REINVOCATIONPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getReinvocationPolicy().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingAdmissionPolicySpec is the specification of the desired behavior of the admission policy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParamKindFieldBuilder();
          getMatchConstraintsFieldBuilder();
          getVariablesFieldBuilder();
          getMutationsFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (paramKindBuilder_ == null) {
          paramKind_ = null;
        } else {
          paramKindBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = null;
        } else {
          matchConstraintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          variablesBuilder_.clear();
        }
        if (mutationsBuilder_ == null) {
          mutations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          mutationsBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          matchConditionsBuilder_.clear();
        }
        reinvocationPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (paramKindBuilder_ == null) {
          result.paramKind_ = paramKind_;
        } else {
          result.paramKind_ = paramKindBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (matchConstraintsBuilder_ == null) {
          result.matchConstraints_ = matchConstraints_;
        } else {
          result.matchConstraints_ = matchConstraintsBuilder_.build();
        }
        if (variablesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            variables_ = java.util.Collections.unmodifiableList(variables_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.variables_ = variables_;
        } else {
          result.variables_ = variablesBuilder_.build();
        }
        if (mutationsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            mutations_ = java.util.Collections.unmodifiableList(mutations_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.mutations_ = mutations_;
        } else {
          result.mutations_ = mutationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000008;
        }
        result.reinvocationPolicy_ = reinvocationPolicy_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec.getDefaultInstance()) return this;
        if (other.hasParamKind()) {
          mergeParamKind(other.getParamKind());
        }
        if (other.hasMatchConstraints()) {
          mergeMatchConstraints(other.getMatchConstraints());
        }
        if (variablesBuilder_ == null) {
          if (!other.variables_.isEmpty()) {
            if (variables_.isEmpty()) {
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureVariablesIsMutable();
              variables_.addAll(other.variables_);
            }
            onChanged();
          }
        } else {
          if (!other.variables_.isEmpty()) {
            if (variablesBuilder_.isEmpty()) {
              variablesBuilder_.dispose();
              variablesBuilder_ = null;
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000004);
              variablesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVariablesFieldBuilder() : null;
            } else {
              variablesBuilder_.addAllMessages(other.variables_);
            }
          }
        }
        if (mutationsBuilder_ == null) {
          if (!other.mutations_.isEmpty()) {
            if (mutations_.isEmpty()) {
              mutations_ = other.mutations_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureMutationsIsMutable();
              mutations_.addAll(other.mutations_);
            }
            onChanged();
          }
        } else {
          if (!other.mutations_.isEmpty()) {
            if (mutationsBuilder_.isEmpty()) {
              mutationsBuilder_.dispose();
              mutationsBuilder_ = null;
              mutations_ = other.mutations_;
              bitField0_ = (bitField0_ & ~0x00000008);
              mutationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMutationsFieldBuilder() : null;
            } else {
              mutationsBuilder_.addAllMessages(other.mutations_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000010;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        if (other.hasReinvocationPolicy()) {
          bitField0_ |= 0x00000040;
          reinvocationPolicy_ = other.reinvocationPolicy_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind paramKind_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder> paramKindBuilder_;
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public boolean hasParamKind() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind() {
        if (paramKindBuilder_ == null) {
          return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        } else {
          return paramKindBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramKind_ = value;
          onChanged();
        } else {
          paramKindBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder builderForValue) {
        if (paramKindBuilder_ == null) {
          paramKind_ = builderForValue.build();
          onChanged();
        } else {
          paramKindBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder mergeParamKind(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              paramKind_ != null &&
              paramKind_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance()) {
            paramKind_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.newBuilder(paramKind_).mergeFrom(value).buildPartial();
          } else {
            paramKind_ = value;
          }
          onChanged();
        } else {
          paramKindBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder clearParamKind() {
        if (paramKindBuilder_ == null) {
          paramKind_ = null;
          onChanged();
        } else {
          paramKindBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder getParamKindBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getParamKindFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
        if (paramKindBuilder_ != null) {
          return paramKindBuilder_.getMessageOrBuilder();
        } else {
          return paramKind_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        }
      }
      /**
       * <pre>
       * paramKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If paramKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in MutatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder> 
          getParamKindFieldBuilder() {
        if (paramKindBuilder_ == null) {
          paramKindBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder>(
                  getParamKind(),
                  getParentForChildren(),
                  isClean());
          paramKind_ = null;
        }
        return paramKindBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchConstraints_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> matchConstraintsBuilder_;
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public boolean hasMatchConstraints() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        } else {
          return matchConstraintsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchConstraints_ = value;
          onChanged();
        } else {
          matchConstraintsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = builderForValue.build();
          onChanged();
        } else {
          matchConstraintsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder mergeMatchConstraints(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              matchConstraints_ != null &&
              matchConstraints_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) {
            matchConstraints_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.newBuilder(matchConstraints_).mergeFrom(value).buildPartial();
          } else {
            matchConstraints_ = value;
          }
          onChanged();
        } else {
          matchConstraintsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder clearMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = null;
          onChanged();
        } else {
          matchConstraintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder getMatchConstraintsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMatchConstraintsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
        if (matchConstraintsBuilder_ != null) {
          return matchConstraintsBuilder_.getMessageOrBuilder();
        } else {
          return matchConstraints_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        }
      }
      /**
       * <pre>
       * matchConstraints specifies what resources this policy is designed to validate.
       * The MutatingAdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * MutatingAdmissionPolicy cannot match MutatingAdmissionPolicy and MutatingAdmissionPolicyBinding.
       * The CREATE, UPDATE and CONNECT operations are allowed.  The DELETE operation may not be matched.
       * '*' matches CREATE, UPDATE and CONNECT.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchConstraintsFieldBuilder() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraintsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchConstraints(),
                  getParentForChildren(),
                  isClean());
          matchConstraints_ = null;
        }
        return matchConstraintsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> variables_ =
        java.util.Collections.emptyList();
      private void ensureVariablesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable>(variables_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> variablesBuilder_;

      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> getVariablesList() {
        if (variablesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(variables_);
        } else {
          return variablesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public int getVariablesCount() {
        if (variablesBuilder_ == null) {
          return variables_.size();
        } else {
          return variablesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);
        } else {
          return variablesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.set(index, value);
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.set(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder addVariables(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(index, value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder addVariables(
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder addAllVariables(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> values) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, variables_);
          onChanged();
        } else {
          variablesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder clearVariables() {
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          variablesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public Builder removeVariables(int index) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.remove(index);
          onChanged();
        } else {
          variablesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder getVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
          int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);  } else {
          return variablesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
           getVariablesOrBuilderList() {
        if (variablesBuilder_ != null) {
          return variablesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(variables_);
        }
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder addVariablesBuilder() {
        return getVariablesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder addVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except matchConditions because matchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, variables must be sorted by the order of first appearance and acyclic.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder> 
           getVariablesBuilderList() {
        return getVariablesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
          getVariablesFieldBuilder() {
        if (variablesBuilder_ == null) {
          variablesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder>(
                  variables_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          variables_ = null;
        }
        return variablesBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation> mutations_ =
        java.util.Collections.emptyList();
      private void ensureMutationsIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          mutations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation>(mutations_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder> mutationsBuilder_;

      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation> getMutationsList() {
        if (mutationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(mutations_);
        } else {
          return mutationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public int getMutationsCount() {
        if (mutationsBuilder_ == null) {
          return mutations_.size();
        } else {
          return mutationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation getMutations(int index) {
        if (mutationsBuilder_ == null) {
          return mutations_.get(index);
        } else {
          return mutationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder setMutations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation value) {
        if (mutationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMutationsIsMutable();
          mutations_.set(index, value);
          onChanged();
        } else {
          mutationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder setMutations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder builderForValue) {
        if (mutationsBuilder_ == null) {
          ensureMutationsIsMutable();
          mutations_.set(index, builderForValue.build());
          onChanged();
        } else {
          mutationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder addMutations(io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation value) {
        if (mutationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMutationsIsMutable();
          mutations_.add(value);
          onChanged();
        } else {
          mutationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder addMutations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation value) {
        if (mutationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMutationsIsMutable();
          mutations_.add(index, value);
          onChanged();
        } else {
          mutationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder addMutations(
          io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder builderForValue) {
        if (mutationsBuilder_ == null) {
          ensureMutationsIsMutable();
          mutations_.add(builderForValue.build());
          onChanged();
        } else {
          mutationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder addMutations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder builderForValue) {
        if (mutationsBuilder_ == null) {
          ensureMutationsIsMutable();
          mutations_.add(index, builderForValue.build());
          onChanged();
        } else {
          mutationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder addAllMutations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation> values) {
        if (mutationsBuilder_ == null) {
          ensureMutationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, mutations_);
          onChanged();
        } else {
          mutationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder clearMutations() {
        if (mutationsBuilder_ == null) {
          mutations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          mutationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public Builder removeMutations(int index) {
        if (mutationsBuilder_ == null) {
          ensureMutationsIsMutable();
          mutations_.remove(index);
          onChanged();
        } else {
          mutationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder getMutationsBuilder(
          int index) {
        return getMutationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder getMutationsOrBuilder(
          int index) {
        if (mutationsBuilder_ == null) {
          return mutations_.get(index);  } else {
          return mutationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder> 
           getMutationsOrBuilderList() {
        if (mutationsBuilder_ != null) {
          return mutationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(mutations_);
        }
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder addMutationsBuilder() {
        return getMutationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.getDefaultInstance());
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder addMutationsBuilder(
          int index) {
        return getMutationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.getDefaultInstance());
      }
      /**
       * <pre>
       * mutations contain operations to perform on matching objects.
       * mutations may not be empty; a minimum of one mutation is required.
       * mutations are evaluated in order, and are reinvoked according to
       * the reinvocationPolicy.
       * The mutations of a policy are invoked for each binding of this policy
       * and reinvocation of mutations occurs on a per binding basis.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Mutation mutations = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder> 
           getMutationsBuilderList() {
        return getMutationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder> 
          getMutationsFieldBuilder() {
        if (mutationsBuilder_ == null) {
          mutationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder>(
                  mutations_,
                  ((bitField0_ & 0x00000008) == 0x00000008),
                  getParentForChildren(),
                  isClean());
          mutations_ = null;
        }
        return mutationsBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if paramKind refers to a non-existent Kind.
       * A binding is invalid if paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 5;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if paramKind refers to a non-existent Kind.
       * A binding is invalid if paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 5;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if paramKind refers to a non-existent Kind.
       * A binding is invalid if paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 5;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if paramKind refers to a non-existent Kind.
       * A binding is invalid if paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 5;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if paramKind refers to a non-existent Kind.
       * A binding is invalid if paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 5;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if paramKind refers to a non-existent Kind.
       * A binding is invalid if paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 5;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * matchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the matchConstraints.
       * An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000020) == 0x00000020),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }

      private java.lang.Object reinvocationPolicy_ = "";
      /**
       * <pre>
       * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
       * as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: These mutations will not be called more than once per binding in a single admission evaluation.
       * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
       * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
       * reinvoked when mutations change the object after this mutation is invoked.
       * Required.
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 7;</code>
       */
      public boolean hasReinvocationPolicy() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
       * as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: These mutations will not be called more than once per binding in a single admission evaluation.
       * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
       * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
       * reinvoked when mutations change the object after this mutation is invoked.
       * Required.
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 7;</code>
       */
      public java.lang.String getReinvocationPolicy() {
        java.lang.Object ref = reinvocationPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reinvocationPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
       * as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: These mutations will not be called more than once per binding in a single admission evaluation.
       * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
       * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
       * reinvoked when mutations change the object after this mutation is invoked.
       * Required.
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 7;</code>
       */
      public com.google.protobuf.ByteString
          getReinvocationPolicyBytes() {
        java.lang.Object ref = reinvocationPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reinvocationPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
       * as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: These mutations will not be called more than once per binding in a single admission evaluation.
       * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
       * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
       * reinvoked when mutations change the object after this mutation is invoked.
       * Required.
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 7;</code>
       */
      public Builder setReinvocationPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        reinvocationPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
       * as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: These mutations will not be called more than once per binding in a single admission evaluation.
       * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
       * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
       * reinvoked when mutations change the object after this mutation is invoked.
       * Required.
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 7;</code>
       */
      public Builder clearReinvocationPolicy() {
        bitField0_ = (bitField0_ & ~0x00000040);
        reinvocationPolicy_ = getDefaultInstance().getReinvocationPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether mutations may be called multiple times per MutatingAdmissionPolicyBinding
       * as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: These mutations will not be called more than once per binding in a single admission evaluation.
       * IfNeeded: These mutations may be invoked more than once per binding for a single admission request and there is no guarantee of
       * order with respect to other admission plugins, admission webhooks, bindings of this policy and admission policies.  Mutations are only
       * reinvoked when mutations change the object after this mutation is invoked.
       * Required.
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 7;</code>
       */
      public Builder setReinvocationPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        reinvocationPolicy_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingAdmissionPolicySpec>
        PARSER = new com.google.protobuf.AbstractParser<MutatingAdmissionPolicySpec>() {
      @java.lang.Override
      public MutatingAdmissionPolicySpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingAdmissionPolicySpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingAdmissionPolicySpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingAdmissionPolicySpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingAdmissionPolicySpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    boolean hasClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder();

    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> 
        getRulesList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index);
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();

    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    boolean hasSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    java.lang.String getSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    com.google.protobuf.ByteString
        getSideEffectsBytes();

    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    int getTimeoutSeconds();

    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.util.List<java.lang.String>
        getAdmissionReviewVersionsList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    int getAdmissionReviewVersionsCount();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.lang.String getAdmissionReviewVersions(int index);
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index);

    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    boolean hasReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    java.lang.String getReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    com.google.protobuf.ByteString
        getReinvocationPolicyBytes();

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhook describes an admission webhook and the resources and operations it applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhook}
   */
  public  static final class MutatingWebhook extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
      MutatingWebhookOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingWebhook.newBuilder() to construct.
    private MutatingWebhook(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhook() {
      name_ = "";
      rules_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchPolicy_ = "";
      sideEffects_ = "";
      timeoutSeconds_ = 0;
      admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      reinvocationPolicy_ = "";
      matchConditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingWebhook(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = clientConfig_.toBuilder();
              }
              clientConfig_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(clientConfig_);
                clientConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>();
                mutable_bitField0_ |= 0x00000004;
              }
              rules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 42: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = namespaceSelector_.toBuilder();
              }
              namespaceSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(namespaceSelector_);
                namespaceSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              sideEffects_ = bs;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000080;
              timeoutSeconds_ = input.readInt32();
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000200;
              }
              admissionReviewVersions_.add(bs);
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              matchPolicy_ = bs;
              break;
            }
            case 82: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000100;
              reinvocationPolicy_ = bs;
              break;
            }
            case 90: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = objectSelector_.toBuilder();
              }
              objectSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectSelector_);
                objectSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 98: {
              if (!((mutable_bitField0_ & 0x00000800) == 0x00000800)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000800;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000800) == 0x00000800)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CLIENTCONFIG_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_;
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    public boolean hasClientConfig() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }

    public static final int RULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_;
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 9;
    private volatile java.lang.Object matchPolicy_;
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 11;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int SIDEEFFECTS_FIELD_NUMBER = 6;
    private volatile java.lang.Object sideEffects_;
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public boolean hasSideEffects() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public java.lang.String getSideEffects() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sideEffects_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public com.google.protobuf.ByteString
        getSideEffectsBytes() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sideEffects_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 7;
    private int timeoutSeconds_;
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public int getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int ADMISSIONREVIEWVERSIONS_FIELD_NUMBER = 8;
    private com.google.protobuf.LazyStringList admissionReviewVersions_;
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getAdmissionReviewVersionsList() {
      return admissionReviewVersions_;
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public int getAdmissionReviewVersionsCount() {
      return admissionReviewVersions_.size();
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public java.lang.String getAdmissionReviewVersions(int index) {
      return admissionReviewVersions_.get(index);
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index) {
      return admissionReviewVersions_.getByteString(index);
    }

    public static final int REINVOCATIONPOLICY_FIELD_NUMBER = 10;
    private volatile java.lang.Object reinvocationPolicy_;
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    public boolean hasReinvocationPolicy() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    public java.lang.String getReinvocationPolicy() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reinvocationPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    public com.google.protobuf.ByteString
        getReinvocationPolicyBytes() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reinvocationPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 12;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(7, timeoutSeconds_);
      }
      for (int i = 0; i < admissionReviewVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, admissionReviewVersions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, reinvocationPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(11, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(12, matchConditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, timeoutSeconds_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < admissionReviewVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(admissionReviewVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAdmissionReviewVersionsList().size();
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, reinvocationPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, matchConditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasClientConfig() == other.hasClientConfig());
      if (hasClientConfig()) {
        result = result && getClientConfig()
            .equals(other.getClientConfig());
      }
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && (hasMatchPolicy() == other.hasMatchPolicy());
      if (hasMatchPolicy()) {
        result = result && getMatchPolicy()
            .equals(other.getMatchPolicy());
      }
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector()
            .equals(other.getNamespaceSelector());
      }
      result = result && (hasObjectSelector() == other.hasObjectSelector());
      if (hasObjectSelector()) {
        result = result && getObjectSelector()
            .equals(other.getObjectSelector());
      }
      result = result && (hasSideEffects() == other.hasSideEffects());
      if (hasSideEffects()) {
        result = result && getSideEffects()
            .equals(other.getSideEffects());
      }
      result = result && (hasTimeoutSeconds() == other.hasTimeoutSeconds());
      if (hasTimeoutSeconds()) {
        result = result && (getTimeoutSeconds()
            == other.getTimeoutSeconds());
      }
      result = result && getAdmissionReviewVersionsList()
          .equals(other.getAdmissionReviewVersionsList());
      result = result && (hasReinvocationPolicy() == other.hasReinvocationPolicy());
      if (hasReinvocationPolicy()) {
        result = result && getReinvocationPolicy()
            .equals(other.getReinvocationPolicy());
      }
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasClientConfig()) {
        hash = (37 * hash) + CLIENTCONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getClientConfig().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (hasSideEffects()) {
        hash = (37 * hash) + SIDEEFFECTS_FIELD_NUMBER;
        hash = (53 * hash) + getSideEffects().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getTimeoutSeconds();
      }
      if (getAdmissionReviewVersionsCount() > 0) {
        hash = (37 * hash) + ADMISSIONREVIEWVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAdmissionReviewVersionsList().hashCode();
      }
      if (hasReinvocationPolicy()) {
        hash = (37 * hash) + REINVOCATIONPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getReinvocationPolicy().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhook describes an admission webhook and the resources and operations it applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhook}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getClientConfigFieldBuilder();
          getRulesFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          rulesBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        matchPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        sideEffects_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        timeoutSeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        reinvocationPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000400);
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (clientConfigBuilder_ == null) {
          result.clientConfig_ = clientConfig_;
        } else {
          result.clientConfig_ = clientConfigBuilder_.build();
        }
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000008;
        }
        result.matchPolicy_ = matchPolicy_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000020;
        }
        if (objectSelectorBuilder_ == null) {
          result.objectSelector_ = objectSelector_;
        } else {
          result.objectSelector_ = objectSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sideEffects_ = sideEffects_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000080;
        }
        result.timeoutSeconds_ = timeoutSeconds_;
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.admissionReviewVersions_ = admissionReviewVersions_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000100;
        }
        result.reinvocationPolicy_ = reinvocationPolicy_;
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000800) == 0x00000800)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000800);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasClientConfig()) {
          mergeClientConfig(other.getClientConfig());
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000008;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (other.hasMatchPolicy()) {
          bitField0_ |= 0x00000010;
          matchPolicy_ = other.matchPolicy_;
          onChanged();
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (other.hasSideEffects()) {
          bitField0_ |= 0x00000080;
          sideEffects_ = other.sideEffects_;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (!other.admissionReviewVersions_.isEmpty()) {
          if (admissionReviewVersions_.isEmpty()) {
            admissionReviewVersions_ = other.admissionReviewVersions_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureAdmissionReviewVersionsIsMutable();
            admissionReviewVersions_.addAll(other.admissionReviewVersions_);
          }
          onChanged();
        }
        if (other.hasReinvocationPolicy()) {
          bitField0_ |= 0x00000400;
          reinvocationPolicy_ = other.reinvocationPolicy_;
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000800);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000800);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> clientConfigBuilder_;
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public boolean hasClientConfig() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
        if (clientConfigBuilder_ == null) {
          return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        } else {
          return clientConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientConfig_ = value;
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder builderForValue) {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = builderForValue.build();
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder mergeClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              clientConfig_ != null &&
              clientConfig_ != io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance()) {
            clientConfig_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.newBuilder(clientConfig_).mergeFrom(value).buildPartial();
          } else {
            clientConfig_ = value;
          }
          onChanged();
        } else {
          clientConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder clearClientConfig() {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
          onChanged();
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder getClientConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getClientConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
        if (clientConfigBuilder_ != null) {
          return clientConfigBuilder_.getMessageOrBuilder();
        } else {
          return clientConfig_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> 
          getClientConfigFieldBuilder() {
        if (clientConfigBuilder_ == null) {
          clientConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder>(
                  getClientConfig(),
                  getParentForChildren(),
                  isClean());
          clientConfig_ = null;
        }
        return clientConfigBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>(rules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder clearMatchPolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020) &&
              namespaceSelector_ != null &&
              namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_).mergeFrom(value).buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040) &&
              objectSelector_ != null &&
              objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            objectSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(objectSelector_).mergeFrom(value).buildPartial();
          } else {
            objectSelector_ = value;
          }
          onChanged();
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder clearObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
          onChanged();
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.lang.Object sideEffects_ = "";
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public boolean hasSideEffects() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public java.lang.String getSideEffects() {
        java.lang.Object ref = sideEffects_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sideEffects_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public com.google.protobuf.ByteString
          getSideEffectsBytes() {
        java.lang.Object ref = sideEffects_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sideEffects_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffects(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder clearSideEffects() {
        bitField0_ = (bitField0_ & ~0x00000080);
        sideEffects_ = getDefaultInstance().getSideEffects();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffectsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }

      private int timeoutSeconds_ ;
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public int getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder setTimeoutSeconds(int value) {
        bitField0_ |= 0x00000100;
        timeoutSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        timeoutSeconds_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAdmissionReviewVersionsIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList(admissionReviewVersions_);
          bitField0_ |= 0x00000200;
         }
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getAdmissionReviewVersionsList() {
        return admissionReviewVersions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public int getAdmissionReviewVersionsCount() {
        return admissionReviewVersions_.size();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public java.lang.String getAdmissionReviewVersions(int index) {
        return admissionReviewVersions_.get(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ByteString
          getAdmissionReviewVersionsBytes(int index) {
        return admissionReviewVersions_.getByteString(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder setAdmissionReviewVersions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAllAdmissionReviewVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureAdmissionReviewVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, admissionReviewVersions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder clearAdmissionReviewVersions() {
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }

      private java.lang.Object reinvocationPolicy_ = "";
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public boolean hasReinvocationPolicy() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public java.lang.String getReinvocationPolicy() {
        java.lang.Object ref = reinvocationPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reinvocationPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public com.google.protobuf.ByteString
          getReinvocationPolicyBytes() {
        java.lang.Object ref = reinvocationPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reinvocationPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public Builder setReinvocationPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
        reinvocationPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public Builder clearReinvocationPolicy() {
        bitField0_ = (bitField0_ & ~0x00000400);
        reinvocationPolicy_ = getDefaultInstance().getReinvocationPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public Builder setReinvocationPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
        reinvocationPolicy_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000800) == 0x00000800)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000800;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000800) == 0x00000800),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhook)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingWebhook>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhook>() {
      @java.lang.Override
      public MutatingWebhook parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingWebhook(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhook> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhook> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> 
        getWebhooksList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getWebhooks(int index);
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    int getWebhooksCount();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
        getWebhooksOrBuilderList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
   * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration}
   */
  public  static final class MutatingWebhookConfiguration extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
      MutatingWebhookConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingWebhookConfiguration.newBuilder() to construct.
    private MutatingWebhookConfiguration(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhookConfiguration() {
      webhooks_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingWebhookConfiguration(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook>();
                mutable_bitField0_ |= 0x00000002;
              }
              webhooks_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int WEBHOOKS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> webhooks_;
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> getWebhooksList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
        getWebhooksOrBuilderList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    public int getWebhooksCount() {
      return webhooks_.size();
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getWebhooks(int index) {
      return webhooks_.get(index);
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
        int index) {
      return webhooks_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        output.writeMessage(2, webhooks_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, webhooks_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getWebhooksList()
          .equals(other.getWebhooksList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getWebhooksCount() > 0) {
        hash = (37 * hash) + WEBHOOKS_FIELD_NUMBER;
        hash = (53 * hash) + getWebhooksList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
     * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getWebhooksFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (webhooksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.webhooks_ = webhooks_;
        } else {
          result.webhooks_ = webhooksBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (webhooksBuilder_ == null) {
          if (!other.webhooks_.isEmpty()) {
            if (webhooks_.isEmpty()) {
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureWebhooksIsMutable();
              webhooks_.addAll(other.webhooks_);
            }
            onChanged();
          }
        } else {
          if (!other.webhooks_.isEmpty()) {
            if (webhooksBuilder_.isEmpty()) {
              webhooksBuilder_.dispose();
              webhooksBuilder_ = null;
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              webhooksBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getWebhooksFieldBuilder() : null;
            } else {
              webhooksBuilder_.addAllMessages(other.webhooks_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> webhooks_ =
        java.util.Collections.emptyList();
      private void ensureWebhooksIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook>(webhooks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> webhooksBuilder_;

      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> getWebhooksList() {
        if (webhooksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(webhooks_);
        } else {
          return webhooksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public int getWebhooksCount() {
        if (webhooksBuilder_ == null) {
          return webhooks_.size();
        } else {
          return webhooksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook getWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);
        } else {
          return webhooksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.set(index, value);
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.set(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(index, value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addAllWebhooks(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook> values) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, webhooks_);
          onChanged();
        } else {
          webhooksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder clearWebhooks() {
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder removeWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.remove(index);
          onChanged();
        } else {
          webhooksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder getWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
          int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);  } else {
          return webhooksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
           getWebhooksOrBuilderList() {
        if (webhooksBuilder_ != null) {
          return webhooksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(webhooks_);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder addWebhooksBuilder() {
        return getWebhooksFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder addWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder> 
           getWebhooksBuilderList() {
        return getWebhooksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder> 
          getWebhooksFieldBuilder() {
        if (webhooksBuilder_ == null) {
          webhooksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookOrBuilder>(
                  webhooks_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          webhooks_ = null;
        }
        return webhooksBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingWebhookConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhookConfiguration>() {
      @java.lang.Override
      public MutatingWebhookConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingWebhookConfiguration(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhookConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhookConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookConfigurationListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> 
        getItemsList();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getItems(int index);
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList}
   */
  public  static final class MutatingWebhookConfigurationList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
      MutatingWebhookConfigurationListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingWebhookConfigurationList.newBuilder() to construct.
    private MutatingWebhookConfigurationList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhookConfigurationList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingWebhookConfigurationList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> items_;
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingWebhookConfigurationList>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhookConfigurationList>() {
      @java.lang.Override
      public MutatingWebhookConfigurationList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingWebhookConfigurationList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhookConfigurationList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhookConfigurationList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.Mutation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * patchType indicates the patch strategy used.
     * Allowed values are "ApplyConfiguration" and "JSONPatch".
     * Required.
     * +unionDiscriminator
     * </pre>
     *
     * <code>optional string patchType = 2;</code>
     */
    boolean hasPatchType();
    /**
     * <pre>
     * patchType indicates the patch strategy used.
     * Allowed values are "ApplyConfiguration" and "JSONPatch".
     * Required.
     * +unionDiscriminator
     * </pre>
     *
     * <code>optional string patchType = 2;</code>
     */
    java.lang.String getPatchType();
    /**
     * <pre>
     * patchType indicates the patch strategy used.
     * Allowed values are "ApplyConfiguration" and "JSONPatch".
     * Required.
     * +unionDiscriminator
     * </pre>
     *
     * <code>optional string patchType = 2;</code>
     */
    com.google.protobuf.ByteString
        getPatchTypeBytes();

    /**
     * <pre>
     * applyConfiguration defines the desired configuration values of an object.
     * The configuration is applied to the admission object using
     * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
     * A CEL expression is used to create apply configuration.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
     */
    boolean hasApplyConfiguration();
    /**
     * <pre>
     * applyConfiguration defines the desired configuration values of an object.
     * The configuration is applied to the admission object using
     * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
     * A CEL expression is used to create apply configuration.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration getApplyConfiguration();
    /**
     * <pre>
     * applyConfiguration defines the desired configuration values of an object.
     * The configuration is applied to the admission object using
     * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
     * A CEL expression is used to create apply configuration.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder getApplyConfigurationOrBuilder();

    /**
     * <pre>
     * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
     * A CEL expression is used to create the JSON patch.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
     */
    boolean hasJsonPatch();
    /**
     * <pre>
     * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
     * A CEL expression is used to create the JSON patch.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch getJsonPatch();
    /**
     * <pre>
     * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
     * A CEL expression is used to create the JSON patch.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder getJsonPatchOrBuilder();
  }
  /**
   * <pre>
   * Mutation specifies the CEL expression which is used to apply the Mutation.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Mutation}
   */
  public  static final class Mutation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.Mutation)
      MutationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Mutation.newBuilder() to construct.
    private Mutation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Mutation() {
      patchType_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Mutation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              patchType_ = bs;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = applyConfiguration_.toBuilder();
              }
              applyConfiguration_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(applyConfiguration_);
                applyConfiguration_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 34: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = jsonPatch_.toBuilder();
              }
              jsonPatch_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(jsonPatch_);
                jsonPatch_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder.class);
    }

    private int bitField0_;
    public static final int PATCHTYPE_FIELD_NUMBER = 2;
    private volatile java.lang.Object patchType_;
    /**
     * <pre>
     * patchType indicates the patch strategy used.
     * Allowed values are "ApplyConfiguration" and "JSONPatch".
     * Required.
     * +unionDiscriminator
     * </pre>
     *
     * <code>optional string patchType = 2;</code>
     */
    public boolean hasPatchType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * patchType indicates the patch strategy used.
     * Allowed values are "ApplyConfiguration" and "JSONPatch".
     * Required.
     * +unionDiscriminator
     * </pre>
     *
     * <code>optional string patchType = 2;</code>
     */
    public java.lang.String getPatchType() {
      java.lang.Object ref = patchType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          patchType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * patchType indicates the patch strategy used.
     * Allowed values are "ApplyConfiguration" and "JSONPatch".
     * Required.
     * +unionDiscriminator
     * </pre>
     *
     * <code>optional string patchType = 2;</code>
     */
    public com.google.protobuf.ByteString
        getPatchTypeBytes() {
      java.lang.Object ref = patchType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        patchType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int APPLYCONFIGURATION_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration applyConfiguration_;
    /**
     * <pre>
     * applyConfiguration defines the desired configuration values of an object.
     * The configuration is applied to the admission object using
     * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
     * A CEL expression is used to create apply configuration.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
     */
    public boolean hasApplyConfiguration() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * applyConfiguration defines the desired configuration values of an object.
     * The configuration is applied to the admission object using
     * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
     * A CEL expression is used to create apply configuration.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration getApplyConfiguration() {
      return applyConfiguration_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance() : applyConfiguration_;
    }
    /**
     * <pre>
     * applyConfiguration defines the desired configuration values of an object.
     * The configuration is applied to the admission object using
     * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
     * A CEL expression is used to create apply configuration.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder getApplyConfigurationOrBuilder() {
      return applyConfiguration_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance() : applyConfiguration_;
    }

    public static final int JSONPATCH_FIELD_NUMBER = 4;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch jsonPatch_;
    /**
     * <pre>
     * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
     * A CEL expression is used to create the JSON patch.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
     */
    public boolean hasJsonPatch() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
     * A CEL expression is used to create the JSON patch.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch getJsonPatch() {
      return jsonPatch_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance() : jsonPatch_;
    }
    /**
     * <pre>
     * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
     * A CEL expression is used to create the JSON patch.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder getJsonPatchOrBuilder() {
      return jsonPatch_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance() : jsonPatch_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, patchType_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(3, getApplyConfiguration());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(4, getJsonPatch());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, patchType_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getApplyConfiguration());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getJsonPatch());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation other = (io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation) obj;

      boolean result = true;
      result = result && (hasPatchType() == other.hasPatchType());
      if (hasPatchType()) {
        result = result && getPatchType()
            .equals(other.getPatchType());
      }
      result = result && (hasApplyConfiguration() == other.hasApplyConfiguration());
      if (hasApplyConfiguration()) {
        result = result && getApplyConfiguration()
            .equals(other.getApplyConfiguration());
      }
      result = result && (hasJsonPatch() == other.hasJsonPatch());
      if (hasJsonPatch()) {
        result = result && getJsonPatch()
            .equals(other.getJsonPatch());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPatchType()) {
        hash = (37 * hash) + PATCHTYPE_FIELD_NUMBER;
        hash = (53 * hash) + getPatchType().hashCode();
      }
      if (hasApplyConfiguration()) {
        hash = (37 * hash) + APPLYCONFIGURATION_FIELD_NUMBER;
        hash = (53 * hash) + getApplyConfiguration().hashCode();
      }
      if (hasJsonPatch()) {
        hash = (37 * hash) + JSONPATCH_FIELD_NUMBER;
        hash = (53 * hash) + getJsonPatch().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Mutation specifies the CEL expression which is used to apply the Mutation.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Mutation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.Mutation)
        io.kubernetes.client.proto.V1beta1Admissionregistration.MutationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getApplyConfigurationFieldBuilder();
          getJsonPatchFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        patchType_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (applyConfigurationBuilder_ == null) {
          applyConfiguration_ = null;
        } else {
          applyConfigurationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (jsonPatchBuilder_ == null) {
          jsonPatch_ = null;
        } else {
          jsonPatchBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation result = new io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.patchType_ = patchType_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (applyConfigurationBuilder_ == null) {
          result.applyConfiguration_ = applyConfiguration_;
        } else {
          result.applyConfiguration_ = applyConfigurationBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (jsonPatchBuilder_ == null) {
          result.jsonPatch_ = jsonPatch_;
        } else {
          result.jsonPatch_ = jsonPatchBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation.getDefaultInstance()) return this;
        if (other.hasPatchType()) {
          bitField0_ |= 0x00000001;
          patchType_ = other.patchType_;
          onChanged();
        }
        if (other.hasApplyConfiguration()) {
          mergeApplyConfiguration(other.getApplyConfiguration());
        }
        if (other.hasJsonPatch()) {
          mergeJsonPatch(other.getJsonPatch());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object patchType_ = "";
      /**
       * <pre>
       * patchType indicates the patch strategy used.
       * Allowed values are "ApplyConfiguration" and "JSONPatch".
       * Required.
       * +unionDiscriminator
       * </pre>
       *
       * <code>optional string patchType = 2;</code>
       */
      public boolean hasPatchType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * patchType indicates the patch strategy used.
       * Allowed values are "ApplyConfiguration" and "JSONPatch".
       * Required.
       * +unionDiscriminator
       * </pre>
       *
       * <code>optional string patchType = 2;</code>
       */
      public java.lang.String getPatchType() {
        java.lang.Object ref = patchType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            patchType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * patchType indicates the patch strategy used.
       * Allowed values are "ApplyConfiguration" and "JSONPatch".
       * Required.
       * +unionDiscriminator
       * </pre>
       *
       * <code>optional string patchType = 2;</code>
       */
      public com.google.protobuf.ByteString
          getPatchTypeBytes() {
        java.lang.Object ref = patchType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          patchType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * patchType indicates the patch strategy used.
       * Allowed values are "ApplyConfiguration" and "JSONPatch".
       * Required.
       * +unionDiscriminator
       * </pre>
       *
       * <code>optional string patchType = 2;</code>
       */
      public Builder setPatchType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        patchType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * patchType indicates the patch strategy used.
       * Allowed values are "ApplyConfiguration" and "JSONPatch".
       * Required.
       * +unionDiscriminator
       * </pre>
       *
       * <code>optional string patchType = 2;</code>
       */
      public Builder clearPatchType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        patchType_ = getDefaultInstance().getPatchType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * patchType indicates the patch strategy used.
       * Allowed values are "ApplyConfiguration" and "JSONPatch".
       * Required.
       * +unionDiscriminator
       * </pre>
       *
       * <code>optional string patchType = 2;</code>
       */
      public Builder setPatchTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        patchType_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration applyConfiguration_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder> applyConfigurationBuilder_;
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public boolean hasApplyConfiguration() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration getApplyConfiguration() {
        if (applyConfigurationBuilder_ == null) {
          return applyConfiguration_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance() : applyConfiguration_;
        } else {
          return applyConfigurationBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public Builder setApplyConfiguration(io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration value) {
        if (applyConfigurationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          applyConfiguration_ = value;
          onChanged();
        } else {
          applyConfigurationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public Builder setApplyConfiguration(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder builderForValue) {
        if (applyConfigurationBuilder_ == null) {
          applyConfiguration_ = builderForValue.build();
          onChanged();
        } else {
          applyConfigurationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public Builder mergeApplyConfiguration(io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration value) {
        if (applyConfigurationBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              applyConfiguration_ != null &&
              applyConfiguration_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance()) {
            applyConfiguration_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.newBuilder(applyConfiguration_).mergeFrom(value).buildPartial();
          } else {
            applyConfiguration_ = value;
          }
          onChanged();
        } else {
          applyConfigurationBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public Builder clearApplyConfiguration() {
        if (applyConfigurationBuilder_ == null) {
          applyConfiguration_ = null;
          onChanged();
        } else {
          applyConfigurationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder getApplyConfigurationBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getApplyConfigurationFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder getApplyConfigurationOrBuilder() {
        if (applyConfigurationBuilder_ != null) {
          return applyConfigurationBuilder_.getMessageOrBuilder();
        } else {
          return applyConfiguration_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.getDefaultInstance() : applyConfiguration_;
        }
      }
      /**
       * <pre>
       * applyConfiguration defines the desired configuration values of an object.
       * The configuration is applied to the admission object using
       * [structured merge diff](https://github.com/kubernetes-sigs/structured-merge-diff).
       * A CEL expression is used to create apply configuration.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ApplyConfiguration applyConfiguration = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder> 
          getApplyConfigurationFieldBuilder() {
        if (applyConfigurationBuilder_ == null) {
          applyConfigurationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ApplyConfigurationOrBuilder>(
                  getApplyConfiguration(),
                  getParentForChildren(),
                  isClean());
          applyConfiguration_ = null;
        }
        return applyConfigurationBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch jsonPatch_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder> jsonPatchBuilder_;
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public boolean hasJsonPatch() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch getJsonPatch() {
        if (jsonPatchBuilder_ == null) {
          return jsonPatch_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance() : jsonPatch_;
        } else {
          return jsonPatchBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public Builder setJsonPatch(io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch value) {
        if (jsonPatchBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          jsonPatch_ = value;
          onChanged();
        } else {
          jsonPatchBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public Builder setJsonPatch(
          io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder builderForValue) {
        if (jsonPatchBuilder_ == null) {
          jsonPatch_ = builderForValue.build();
          onChanged();
        } else {
          jsonPatchBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public Builder mergeJsonPatch(io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch value) {
        if (jsonPatchBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              jsonPatch_ != null &&
              jsonPatch_ != io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance()) {
            jsonPatch_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.newBuilder(jsonPatch_).mergeFrom(value).buildPartial();
          } else {
            jsonPatch_ = value;
          }
          onChanged();
        } else {
          jsonPatchBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public Builder clearJsonPatch() {
        if (jsonPatchBuilder_ == null) {
          jsonPatch_ = null;
          onChanged();
        } else {
          jsonPatchBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder getJsonPatchBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getJsonPatchFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder getJsonPatchOrBuilder() {
        if (jsonPatchBuilder_ != null) {
          return jsonPatchBuilder_.getMessageOrBuilder();
        } else {
          return jsonPatch_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.getDefaultInstance() : jsonPatch_;
        }
      }
      /**
       * <pre>
       * jsonPatch defines a [JSON patch](https://jsonpatch.com/) operation to perform a mutation to the object.
       * A CEL expression is used to create the JSON patch.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.JSONPatch jsonPatch = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder> 
          getJsonPatchFieldBuilder() {
        if (jsonPatchBuilder_ == null) {
          jsonPatchBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatch.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.JSONPatchOrBuilder>(
                  getJsonPatch(),
                  getParentForChildren(),
                  isClean());
          jsonPatch_ = null;
        }
        return jsonPatchBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.Mutation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.Mutation)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Mutation>
        PARSER = new com.google.protobuf.AbstractParser<Mutation>() {
      @java.lang.Override
      public Mutation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Mutation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Mutation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Mutation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Mutation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NamedRuleWithOperationsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    java.util.List<java.lang.String>
        getResourceNamesList();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    int getResourceNamesCount();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    java.lang.String getResourceNames(int index);
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    com.google.protobuf.ByteString
        getResourceNamesBytes(int index);

    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    boolean hasRuleWithOperations();
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations();
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder();
  }
  /**
   * <pre>
   * NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations}
   */
  public  static final class NamedRuleWithOperations extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
      NamedRuleWithOperationsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NamedRuleWithOperations.newBuilder() to construct.
    private NamedRuleWithOperations(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NamedRuleWithOperations() {
      resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NamedRuleWithOperations(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                resourceNames_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              resourceNames_.add(bs);
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = ruleWithOperations_.toBuilder();
              }
              ruleWithOperations_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ruleWithOperations_);
                ruleWithOperations_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          resourceNames_ = resourceNames_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.class, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder.class);
    }

    private int bitField0_;
    public static final int RESOURCENAMES_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList resourceNames_;
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getResourceNamesList() {
      return resourceNames_;
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public int getResourceNamesCount() {
      return resourceNames_.size();
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public java.lang.String getResourceNames(int index) {
      return resourceNames_.get(index);
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public com.google.protobuf.ByteString
        getResourceNamesBytes(int index) {
      return resourceNames_.getByteString(index);
    }

    public static final int RULEWITHOPERATIONS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations ruleWithOperations_;
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    public boolean hasRuleWithOperations() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations() {
      return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder() {
      return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < resourceNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, resourceNames_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(2, getRuleWithOperations());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < resourceNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(resourceNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getResourceNamesList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRuleWithOperations());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations other = (io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations) obj;

      boolean result = true;
      result = result && getResourceNamesList()
          .equals(other.getResourceNamesList());
      result = result && (hasRuleWithOperations() == other.hasRuleWithOperations());
      if (hasRuleWithOperations()) {
        result = result && getRuleWithOperations()
            .equals(other.getRuleWithOperations());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getResourceNamesCount() > 0) {
        hash = (37 * hash) + RESOURCENAMES_FIELD_NUMBER;
        hash = (53 * hash) + getResourceNamesList().hashCode();
      }
      if (hasRuleWithOperations()) {
        hash = (37 * hash) + RULEWITHOPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getRuleWithOperations().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperationsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.class, io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRuleWithOperationsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = null;
        } else {
          ruleWithOperationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations result = new io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          resourceNames_ = resourceNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.resourceNames_ = resourceNames_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        if (ruleWithOperationsBuilder_ == null) {
          result.ruleWithOperations_ = ruleWithOperations_;
        } else {
          result.ruleWithOperations_ = ruleWithOperationsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations.getDefaultInstance()) return this;
        if (!other.resourceNames_.isEmpty()) {
          if (resourceNames_.isEmpty()) {
            resourceNames_ = other.resourceNames_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureResourceNamesIsMutable();
            resourceNames_.addAll(other.resourceNames_);
          }
          onChanged();
        }
        if (other.hasRuleWithOperations()) {
          mergeRuleWithOperations(other.getRuleWithOperations());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureResourceNamesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          resourceNames_ = new com.google.protobuf.LazyStringArrayList(resourceNames_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getResourceNamesList() {
        return resourceNames_.getUnmodifiableView();
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public int getResourceNamesCount() {
        return resourceNames_.size();
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public java.lang.String getResourceNames(int index) {
        return resourceNames_.get(index);
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public com.google.protobuf.ByteString
          getResourceNamesBytes(int index) {
        return resourceNames_.getByteString(index);
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder setResourceNames(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourceNamesIsMutable();
        resourceNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder addResourceNames(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourceNamesIsMutable();
        resourceNames_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder addAllResourceNames(
          java.lang.Iterable<java.lang.String> values) {
        ensureResourceNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, resourceNames_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder clearResourceNames() {
        resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder addResourceNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourceNamesIsMutable();
        resourceNames_.add(value);
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations ruleWithOperations_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> ruleWithOperationsBuilder_;
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public boolean hasRuleWithOperations() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations() {
        if (ruleWithOperationsBuilder_ == null) {
          return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
        } else {
          return ruleWithOperationsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder setRuleWithOperations(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (ruleWithOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ruleWithOperations_ = value;
          onChanged();
        } else {
          ruleWithOperationsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder setRuleWithOperations(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = builderForValue.build();
          onChanged();
        } else {
          ruleWithOperationsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder mergeRuleWithOperations(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (ruleWithOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              ruleWithOperations_ != null &&
              ruleWithOperations_ != io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance()) {
            ruleWithOperations_ =
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.newBuilder(ruleWithOperations_).mergeFrom(value).buildPartial();
          } else {
            ruleWithOperations_ = value;
          }
          onChanged();
        } else {
          ruleWithOperationsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder clearRuleWithOperations() {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = null;
          onChanged();
        } else {
          ruleWithOperationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRuleWithOperationsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRuleWithOperationsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder() {
        if (ruleWithOperationsBuilder_ != null) {
          return ruleWithOperationsBuilder_.getMessageOrBuilder();
        } else {
          return ruleWithOperations_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
        }
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRuleWithOperationsFieldBuilder() {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperationsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  getRuleWithOperations(),
                  getParentForChildren(),
                  isClean());
          ruleWithOperations_ = null;
        }
        return ruleWithOperationsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.NamedRuleWithOperations)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<NamedRuleWithOperations>
        PARSER = new com.google.protobuf.AbstractParser<NamedRuleWithOperations>() {
      @java.lang.Override
      public NamedRuleWithOperations parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NamedRuleWithOperations(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NamedRuleWithOperations> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NamedRuleWithOperations> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.NamedRuleWithOperations getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParamKindOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ParamKind)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    boolean hasApiVersion();
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    java.lang.String getApiVersion();
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    com.google.protobuf.ByteString
        getApiVersionBytes();

    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    boolean hasKind();
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    java.lang.String getKind();
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    com.google.protobuf.ByteString
        getKindBytes();
  }
  /**
   * <pre>
   * ParamKind is a tuple of Group Kind and Version.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamKind}
   */
  public  static final class ParamKind extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ParamKind)
      ParamKindOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ParamKind.newBuilder() to construct.
    private ParamKind(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ParamKind() {
      apiVersion_ = "";
      kind_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ParamKind(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              apiVersion_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              kind_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder.class);
    }

    private int bitField0_;
    public static final int APIVERSION_FIELD_NUMBER = 1;
    private volatile java.lang.Object apiVersion_;
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    public boolean hasApiVersion() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    public java.lang.String getApiVersion() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          apiVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    public com.google.protobuf.ByteString
        getApiVersionBytes() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        apiVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 2;
    private volatile java.lang.Object kind_;
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    public boolean hasKind() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, apiVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, kind_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, apiVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, kind_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind) obj;

      boolean result = true;
      result = result && (hasApiVersion() == other.hasApiVersion());
      if (hasApiVersion()) {
        result = result && getApiVersion()
            .equals(other.getApiVersion());
      }
      result = result && (hasKind() == other.hasKind());
      if (hasKind()) {
        result = result && getKind()
            .equals(other.getKind());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasApiVersion()) {
        hash = (37 * hash) + APIVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersion().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ParamKind is a tuple of Group Kind and Version.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamKind}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ParamKind)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        apiVersion_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        kind_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.apiVersion_ = apiVersion_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.kind_ = kind_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance()) return this;
        if (other.hasApiVersion()) {
          bitField0_ |= 0x00000001;
          apiVersion_ = other.apiVersion_;
          onChanged();
        }
        if (other.hasKind()) {
          bitField0_ |= 0x00000002;
          kind_ = other.kind_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object apiVersion_ = "";
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public boolean hasApiVersion() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public java.lang.String getApiVersion() {
        java.lang.Object ref = apiVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            apiVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public com.google.protobuf.ByteString
          getApiVersionBytes() {
        java.lang.Object ref = apiVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          apiVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public Builder setApiVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        apiVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public Builder clearApiVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        apiVersion_ = getDefaultInstance().getApiVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public Builder setApiVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        apiVersion_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        kind_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public Builder clearKind() {
        bitField0_ = (bitField0_ & ~0x00000002);
        kind_ = getDefaultInstance().getKind();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        kind_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ParamKind)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ParamKind)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ParamKind>
        PARSER = new com.google.protobuf.AbstractParser<ParamKind>() {
      @java.lang.Override
      public ParamKind parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ParamKind(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ParamKind> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParamKind> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParamRefOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ParamRef)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    boolean hasNamespace();
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    boolean hasSelector();
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    boolean hasParameterNotFoundAction();
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    java.lang.String getParameterNotFoundAction();
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    com.google.protobuf.ByteString
        getParameterNotFoundActionBytes();
  }
  /**
   * <pre>
   * ParamRef describes how to locate the params to be used as input to
   * expressions of rules applied by a policy binding.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamRef}
   */
  public  static final class ParamRef extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ParamRef)
      ParamRefOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ParamRef.newBuilder() to construct.
    private ParamRef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ParamRef() {
      name_ = "";
      namespace_ = "";
      parameterNotFoundAction_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ParamRef(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              namespace_ = bs;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = selector_.toBuilder();
              }
              selector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(selector_);
                selector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              parameterNotFoundAction_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACE_FIELD_NUMBER = 2;
    private volatile java.lang.Object namespace_;
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SELECTOR_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int PARAMETERNOTFOUNDACTION_FIELD_NUMBER = 4;
    private volatile java.lang.Object parameterNotFoundAction_;
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    public boolean hasParameterNotFoundAction() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    public java.lang.String getParameterNotFoundAction() {
      java.lang.Object ref = parameterNotFoundAction_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          parameterNotFoundAction_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    public com.google.protobuf.ByteString
        getParameterNotFoundActionBytes() {
      java.lang.Object ref = parameterNotFoundAction_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        parameterNotFoundAction_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, namespace_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getSelector());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, parameterNotFoundAction_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, namespace_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getSelector());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, parameterNotFoundAction_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasNamespace() == other.hasNamespace());
      if (hasNamespace()) {
        result = result && getNamespace()
            .equals(other.getNamespace());
      }
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector()
            .equals(other.getSelector());
      }
      result = result && (hasParameterNotFoundAction() == other.hasParameterNotFoundAction());
      if (hasParameterNotFoundAction()) {
        result = result && getParameterNotFoundAction()
            .equals(other.getParameterNotFoundAction());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasParameterNotFoundAction()) {
        hash = (37 * hash) + PARAMETERNOTFOUNDACTION_FIELD_NUMBER;
        hash = (53 * hash) + getParameterNotFoundAction().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ParamRef describes how to locate the params to be used as input to
     * expressions of rules applied by a policy binding.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ParamRef}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ParamRef)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        namespace_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        parameterNotFoundAction_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.namespace_ = namespace_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.parameterNotFoundAction_ = parameterNotFoundAction_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasNamespace()) {
          bitField0_ |= 0x00000002;
          namespace_ = other.namespace_;
          onChanged();
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasParameterNotFoundAction()) {
          bitField0_ |= 0x00000008;
          parameterNotFoundAction_ = other.parameterNotFoundAction_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        namespace_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public Builder clearNamespace() {
        bitField0_ = (bitField0_ & ~0x00000002);
        namespace_ = getDefaultInstance().getNamespace();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        namespace_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              selector_ != null &&
              selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_).mergeFrom(value).buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private java.lang.Object parameterNotFoundAction_ = "";
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public boolean hasParameterNotFoundAction() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public java.lang.String getParameterNotFoundAction() {
        java.lang.Object ref = parameterNotFoundAction_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            parameterNotFoundAction_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public com.google.protobuf.ByteString
          getParameterNotFoundActionBytes() {
        java.lang.Object ref = parameterNotFoundAction_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          parameterNotFoundAction_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public Builder setParameterNotFoundAction(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        parameterNotFoundAction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public Builder clearParameterNotFoundAction() {
        bitField0_ = (bitField0_ & ~0x00000008);
        parameterNotFoundAction_ = getDefaultInstance().getParameterNotFoundAction();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public Builder setParameterNotFoundActionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        parameterNotFoundAction_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ParamRef)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ParamRef)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ParamRef>
        PARSER = new com.google.protobuf.AbstractParser<ParamRef>() {
      @java.lang.Override
      public ParamRef parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ParamRef(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ParamRef> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParamRef> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServiceReferenceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    boolean hasNamespace();
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    boolean hasPath();
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    java.lang.String getPath();
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    com.google.protobuf.ByteString
        getPathBytes();

    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    boolean hasPort();
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    int getPort();
  }
  /**
   * <pre>
   * ServiceReference holds a reference to Service.legacy.k8s.io
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ServiceReference}
   */
  public  static final class ServiceReference extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
      ServiceReferenceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ServiceReference.newBuilder() to construct.
    private ServiceReference(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ServiceReference() {
      namespace_ = "";
      name_ = "";
      path_ = "";
      port_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ServiceReference(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              namespace_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              name_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              path_ = bs;
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              port_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder.class);
    }

    private int bitField0_;
    public static final int NAMESPACE_FIELD_NUMBER = 1;
    private volatile java.lang.Object namespace_;
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object path_;
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    public boolean hasPath() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    public java.lang.String getPath() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          path_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    public com.google.protobuf.ByteString
        getPathBytes() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        path_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PORT_FIELD_NUMBER = 4;
    private int port_;
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    public boolean hasPort() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    public int getPort() {
      return port_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, namespace_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, path_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, port_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, namespace_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, path_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, port_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference) obj;

      boolean result = true;
      result = result && (hasNamespace() == other.hasNamespace());
      if (hasNamespace()) {
        result = result && getNamespace()
            .equals(other.getNamespace());
      }
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasPath() == other.hasPath());
      if (hasPath()) {
        result = result && getPath()
            .equals(other.getPath());
      }
      result = result && (hasPort() == other.hasPort());
      if (hasPort()) {
        result = result && (getPort()
            == other.getPort());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasPath()) {
        hash = (37 * hash) + PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPath().hashCode();
      }
      if (hasPort()) {
        hash = (37 * hash) + PORT_FIELD_NUMBER;
        hash = (53 * hash) + getPort();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ServiceReference holds a reference to Service.legacy.k8s.io
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ServiceReference}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        namespace_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        path_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        port_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.namespace_ = namespace_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.path_ = path_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.port_ = port_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance()) return this;
        if (other.hasNamespace()) {
          bitField0_ |= 0x00000001;
          namespace_ = other.namespace_;
          onChanged();
        }
        if (other.hasName()) {
          bitField0_ |= 0x00000002;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasPath()) {
          bitField0_ |= 0x00000004;
          path_ = other.path_;
          onChanged();
        }
        if (other.hasPort()) {
          setPort(other.getPort());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        namespace_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public Builder clearNamespace() {
        bitField0_ = (bitField0_ & ~0x00000001);
        namespace_ = getDefaultInstance().getNamespace();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        namespace_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000002);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object path_ = "";
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public boolean hasPath() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public java.lang.String getPath() {
        java.lang.Object ref = path_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            path_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public com.google.protobuf.ByteString
          getPathBytes() {
        java.lang.Object ref = path_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          path_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public Builder setPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        path_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public Builder clearPath() {
        bitField0_ = (bitField0_ & ~0x00000004);
        path_ = getDefaultInstance().getPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public Builder setPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        path_ = value;
        onChanged();
        return this;
      }

      private int port_ ;
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public boolean hasPort() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public int getPort() {
        return port_;
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public Builder setPort(int value) {
        bitField0_ |= 0x00000008;
        port_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public Builder clearPort() {
        bitField0_ = (bitField0_ & ~0x00000008);
        port_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ServiceReference)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ServiceReference>
        PARSER = new com.google.protobuf.AbstractParser<ServiceReference>() {
      @java.lang.Override
      public ServiceReference parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ServiceReference(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ServiceReference> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServiceReference> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TypeCheckingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> 
        getExpressionWarningsList();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getExpressionWarnings(int index);
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    int getExpressionWarningsCount();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
        getExpressionWarningsOrBuilderList();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * TypeChecking contains results of type checking the expressions in the
   * ValidatingAdmissionPolicy
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.TypeChecking}
   */
  public  static final class TypeChecking extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
      TypeCheckingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TypeChecking.newBuilder() to construct.
    private TypeChecking(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TypeChecking() {
      expressionWarnings_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TypeChecking(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                expressionWarnings_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning>();
                mutable_bitField0_ |= 0x00000001;
              }
              expressionWarnings_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          expressionWarnings_ = java.util.Collections.unmodifiableList(expressionWarnings_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.class, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder.class);
    }

    public static final int EXPRESSIONWARNINGS_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> expressionWarnings_;
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> getExpressionWarningsList() {
      return expressionWarnings_;
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
        getExpressionWarningsOrBuilderList() {
      return expressionWarnings_;
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public int getExpressionWarningsCount() {
      return expressionWarnings_.size();
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getExpressionWarnings(int index) {
      return expressionWarnings_.get(index);
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
        int index) {
      return expressionWarnings_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < expressionWarnings_.size(); i++) {
        output.writeMessage(1, expressionWarnings_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < expressionWarnings_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, expressionWarnings_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking other = (io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking) obj;

      boolean result = true;
      result = result && getExpressionWarningsList()
          .equals(other.getExpressionWarningsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getExpressionWarningsCount() > 0) {
        hash = (37 * hash) + EXPRESSIONWARNINGS_FIELD_NUMBER;
        hash = (53 * hash) + getExpressionWarningsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TypeChecking contains results of type checking the expressions in the
     * ValidatingAdmissionPolicy
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.TypeChecking}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.class, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getExpressionWarningsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (expressionWarningsBuilder_ == null) {
          expressionWarnings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          expressionWarningsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking result = new io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking(this);
        int from_bitField0_ = bitField0_;
        if (expressionWarningsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            expressionWarnings_ = java.util.Collections.unmodifiableList(expressionWarnings_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.expressionWarnings_ = expressionWarnings_;
        } else {
          result.expressionWarnings_ = expressionWarningsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance()) return this;
        if (expressionWarningsBuilder_ == null) {
          if (!other.expressionWarnings_.isEmpty()) {
            if (expressionWarnings_.isEmpty()) {
              expressionWarnings_ = other.expressionWarnings_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureExpressionWarningsIsMutable();
              expressionWarnings_.addAll(other.expressionWarnings_);
            }
            onChanged();
          }
        } else {
          if (!other.expressionWarnings_.isEmpty()) {
            if (expressionWarningsBuilder_.isEmpty()) {
              expressionWarningsBuilder_.dispose();
              expressionWarningsBuilder_ = null;
              expressionWarnings_ = other.expressionWarnings_;
              bitField0_ = (bitField0_ & ~0x00000001);
              expressionWarningsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExpressionWarningsFieldBuilder() : null;
            } else {
              expressionWarningsBuilder_.addAllMessages(other.expressionWarnings_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> expressionWarnings_ =
        java.util.Collections.emptyList();
      private void ensureExpressionWarningsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          expressionWarnings_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning>(expressionWarnings_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> expressionWarningsBuilder_;

      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> getExpressionWarningsList() {
        if (expressionWarningsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(expressionWarnings_);
        } else {
          return expressionWarningsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public int getExpressionWarningsCount() {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.size();
        } else {
          return expressionWarningsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning getExpressionWarnings(int index) {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.get(index);
        } else {
          return expressionWarningsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder setExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.set(index, value);
          onChanged();
        } else {
          expressionWarningsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder setExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.set(index, builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(value);
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(index, value);
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(index, builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addAllExpressionWarnings(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning> values) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, expressionWarnings_);
          onChanged();
        } else {
          expressionWarningsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder clearExpressionWarnings() {
        if (expressionWarningsBuilder_ == null) {
          expressionWarnings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          expressionWarningsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder removeExpressionWarnings(int index) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.remove(index);
          onChanged();
        } else {
          expressionWarningsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder getExpressionWarningsBuilder(
          int index) {
        return getExpressionWarningsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
          int index) {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.get(index);  } else {
          return expressionWarningsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
           getExpressionWarningsOrBuilderList() {
        if (expressionWarningsBuilder_ != null) {
          return expressionWarningsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(expressionWarnings_);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder addExpressionWarningsBuilder() {
        return getExpressionWarningsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance());
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder addExpressionWarningsBuilder(
          int index) {
        return getExpressionWarningsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.getDefaultInstance());
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder> 
           getExpressionWarningsBuilderList() {
        return getExpressionWarningsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder> 
          getExpressionWarningsFieldBuilder() {
        if (expressionWarningsBuilder_ == null) {
          expressionWarningsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ExpressionWarningOrBuilder>(
                  expressionWarnings_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          expressionWarnings_ = null;
        }
        return expressionWarningsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.TypeChecking)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<TypeChecking>
        PARSER = new com.google.protobuf.AbstractParser<TypeChecking>() {
      @java.lang.Override
      public TypeChecking parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TypeChecking(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TypeChecking> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TypeChecking> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus();
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * +genclient
   * +genclient:nonNamespaced
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * +k8s:prerelease-lifecycle-gen:introduced=1.28
   * ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy}
   */
  public  static final class ValidatingAdmissionPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
      ValidatingAdmissionPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicy.newBuilder() to construct.
    private ValidatingAdmissionPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicy() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = status_.toBuilder();
              }
              status_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(status_);
                status_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus status_;
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * +genclient
     * +genclient:nonNamespaced
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * +k8s:prerelease-lifecycle-gen:introduced=1.28
     * ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              status_ != null &&
              status_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance()) {
            status_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.newBuilder(status_).mergeFrom(value).buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicy>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicy>() {
      @java.lang.Override
      public ValidatingAdmissionPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources.
   * ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
   * For a given admission request, each binding will cause its policy to be
   * evaluated N times, where N is 1 for policies/bindings that don't use
   * params, otherwise N is the number of parameters selected by the binding.
   * The CEL expressions of a policy must have a computed CEL cost below the maximum
   * CEL budget. Each evaluation of the policy is given an independent CEL cost budget.
   * Adding/removing policies, bindings, or params can not affect whether a
   * given (policy, binding, param) combination is within its own CEL budget.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding}
   */
  public  static final class ValidatingAdmissionPolicyBinding extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
      ValidatingAdmissionPolicyBindingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyBinding.newBuilder() to construct.
    private ValidatingAdmissionPolicyBinding(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBinding() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyBinding(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources.
     * ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
     * For a given admission request, each binding will cause its policy to be
     * evaluated N times, where N is 1 for policies/bindings that don't use
     * params, otherwise N is the number of parameters selected by the binding.
     * The CEL expressions of a policy must have a computed CEL cost below the maximum
     * CEL budget. Each evaluation of the policy is given an independent CEL cost budget.
     * Adding/removing policies, bindings, or params can not affect whether a
     * given (policy, binding, param) combination is within its own CEL budget.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBinding>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBinding parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyBinding(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> 
        getItemsList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index);
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList}
   */
  public  static final class ValidatingAdmissionPolicyBindingList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
      ValidatingAdmissionPolicyBindingListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyBindingList.newBuilder() to construct.
    private ValidatingAdmissionPolicyBindingList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBindingList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyBindingList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> items_;
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBindingList>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBindingList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyBindingList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    boolean hasPolicyName();
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    java.lang.String getPolicyName();
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    com.google.protobuf.ByteString
        getPolicyNameBytes();

    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    boolean hasParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder();

    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    boolean hasMatchResources();
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources();
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder();

    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    java.util.List<java.lang.String>
        getValidationActionsList();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    int getValidationActionsCount();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    java.lang.String getValidationActions(int index);
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    com.google.protobuf.ByteString
        getValidationActionsBytes(int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec}
   */
  public  static final class ValidatingAdmissionPolicyBindingSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
      ValidatingAdmissionPolicyBindingSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyBindingSpec.newBuilder() to construct.
    private ValidatingAdmissionPolicyBindingSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBindingSpec() {
      policyName_ = "";
      validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyBindingSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              policyName_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = paramRef_.toBuilder();
              }
              paramRef_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paramRef_);
                paramRef_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = matchResources_.toBuilder();
              }
              matchResources_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matchResources_);
                matchResources_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                validationActions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000008;
              }
              validationActions_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          validationActions_ = validationActions_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder.class);
    }

    private int bitField0_;
    public static final int POLICYNAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object policyName_;
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public boolean hasPolicyName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public java.lang.String getPolicyName() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          policyName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public com.google.protobuf.ByteString
        getPolicyNameBytes() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        policyName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARAMREF_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef paramRef_;
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    public boolean hasParamRef() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }

    public static final int MATCHRESOURCES_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchResources_;
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    public boolean hasMatchResources() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }

    public static final int VALIDATIONACTIONS_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList validationActions_;
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getValidationActionsList() {
      return validationActions_;
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public int getValidationActionsCount() {
      return validationActions_.size();
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public java.lang.String getValidationActions(int index) {
      return validationActions_.get(index);
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public com.google.protobuf.ByteString
        getValidationActionsBytes(int index) {
      return validationActions_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, policyName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getMatchResources());
      }
      for (int i = 0; i < validationActions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, validationActions_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, policyName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getMatchResources());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < validationActions_.size(); i++) {
          dataSize += computeStringSizeNoTag(validationActions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getValidationActionsList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) obj;

      boolean result = true;
      result = result && (hasPolicyName() == other.hasPolicyName());
      if (hasPolicyName()) {
        result = result && getPolicyName()
            .equals(other.getPolicyName());
      }
      result = result && (hasParamRef() == other.hasParamRef());
      if (hasParamRef()) {
        result = result && getParamRef()
            .equals(other.getParamRef());
      }
      result = result && (hasMatchResources() == other.hasMatchResources());
      if (hasMatchResources()) {
        result = result && getMatchResources()
            .equals(other.getMatchResources());
      }
      result = result && getValidationActionsList()
          .equals(other.getValidationActionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPolicyName()) {
        hash = (37 * hash) + POLICYNAME_FIELD_NUMBER;
        hash = (53 * hash) + getPolicyName().hashCode();
      }
      if (hasParamRef()) {
        hash = (37 * hash) + PARAMREF_FIELD_NUMBER;
        hash = (53 * hash) + getParamRef().hashCode();
      }
      if (hasMatchResources()) {
        hash = (37 * hash) + MATCHRESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getMatchResources().hashCode();
      }
      if (getValidationActionsCount() > 0) {
        hash = (37 * hash) + VALIDATIONACTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getValidationActionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParamRefFieldBuilder();
          getMatchResourcesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        policyName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (paramRefBuilder_ == null) {
          paramRef_ = null;
        } else {
          paramRefBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (matchResourcesBuilder_ == null) {
          matchResources_ = null;
        } else {
          matchResourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.policyName_ = policyName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (paramRefBuilder_ == null) {
          result.paramRef_ = paramRef_;
        } else {
          result.paramRef_ = paramRefBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (matchResourcesBuilder_ == null) {
          result.matchResources_ = matchResources_;
        } else {
          result.matchResources_ = matchResourcesBuilder_.build();
        }
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          validationActions_ = validationActions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.validationActions_ = validationActions_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance()) return this;
        if (other.hasPolicyName()) {
          bitField0_ |= 0x00000001;
          policyName_ = other.policyName_;
          onChanged();
        }
        if (other.hasParamRef()) {
          mergeParamRef(other.getParamRef());
        }
        if (other.hasMatchResources()) {
          mergeMatchResources(other.getMatchResources());
        }
        if (!other.validationActions_.isEmpty()) {
          if (validationActions_.isEmpty()) {
            validationActions_ = other.validationActions_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureValidationActionsIsMutable();
            validationActions_.addAll(other.validationActions_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object policyName_ = "";
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public boolean hasPolicyName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public java.lang.String getPolicyName() {
        java.lang.Object ref = policyName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            policyName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public com.google.protobuf.ByteString
          getPolicyNameBytes() {
        java.lang.Object ref = policyName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          policyName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder setPolicyName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        policyName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder clearPolicyName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        policyName_ = getDefaultInstance().getPolicyName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder setPolicyNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        policyName_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef paramRef_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder> paramRefBuilder_;
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public boolean hasParamRef() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef getParamRef() {
        if (paramRefBuilder_ == null) {
          return paramRef_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        } else {
          return paramRefBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramRef_ = value;
          onChanged();
        } else {
          paramRefBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder builderForValue) {
        if (paramRefBuilder_ == null) {
          paramRef_ = builderForValue.build();
          onChanged();
        } else {
          paramRefBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder mergeParamRef(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              paramRef_ != null &&
              paramRef_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance()) {
            paramRef_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.newBuilder(paramRef_).mergeFrom(value).buildPartial();
          } else {
            paramRef_ = value;
          }
          onChanged();
        } else {
          paramRefBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public Builder clearParamRef() {
        if (paramRefBuilder_ == null) {
          paramRef_ = null;
          onChanged();
        } else {
          paramRefBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder getParamRefBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getParamRefFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
        if (paramRefBuilder_ != null) {
          return paramRefBuilder_.getMessageOrBuilder();
        } else {
          return paramRef_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamRef paramRef = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder> 
          getParamRefFieldBuilder() {
        if (paramRefBuilder_ == null) {
          paramRefBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamRefOrBuilder>(
                  getParamRef(),
                  getParentForChildren(),
                  isClean());
          paramRef_ = null;
        }
        return paramRefBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchResources_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> matchResourcesBuilder_;
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public boolean hasMatchResources() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchResources() {
        if (matchResourcesBuilder_ == null) {
          return matchResources_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        } else {
          return matchResourcesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchResources_ = value;
          onChanged();
        } else {
          matchResourcesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = builderForValue.build();
          onChanged();
        } else {
          matchResourcesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder mergeMatchResources(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              matchResources_ != null &&
              matchResources_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) {
            matchResources_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.newBuilder(matchResources_).mergeFrom(value).buildPartial();
          } else {
            matchResources_ = value;
          }
          onChanged();
        } else {
          matchResourcesBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public Builder clearMatchResources() {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = null;
          onChanged();
        } else {
          matchResourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder getMatchResourcesBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getMatchResourcesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
        if (matchResourcesBuilder_ != null) {
          return matchResourcesBuilder_.getMessageOrBuilder();
        } else {
          return matchResources_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        }
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchResources = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchResourcesFieldBuilder() {
        if (matchResourcesBuilder_ == null) {
          matchResourcesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchResources(),
                  getParentForChildren(),
                  isClean());
          matchResources_ = null;
        }
        return matchResourcesBuilder_;
      }

      private com.google.protobuf.LazyStringList validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureValidationActionsIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          validationActions_ = new com.google.protobuf.LazyStringArrayList(validationActions_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getValidationActionsList() {
        return validationActions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public int getValidationActionsCount() {
        return validationActions_.size();
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public java.lang.String getValidationActions(int index) {
        return validationActions_.get(index);
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public com.google.protobuf.ByteString
          getValidationActionsBytes(int index) {
        return validationActions_.getByteString(index);
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder setValidationActions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureValidationActionsIsMutable();
        validationActions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder addValidationActions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureValidationActionsIsMutable();
        validationActions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder addAllValidationActions(
          java.lang.Iterable<java.lang.String> values) {
        ensureValidationActionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, validationActions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder clearValidationActions() {
        validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder addValidationActionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureValidationActionsIsMutable();
        validationActions_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBindingSpec>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBindingSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyBindingSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getItems(int index);
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
   * +k8s:prerelease-lifecycle-gen:introduced=1.28
   * ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList}
   */
  public  static final class ValidatingAdmissionPolicyList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
      ValidatingAdmissionPolicyListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyList.newBuilder() to construct.
    private ValidatingAdmissionPolicyList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> items_;
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     * +k8s:prerelease-lifecycle-gen:introduced=1.28
     * ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyList>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicySpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    boolean hasParamKind();
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind();
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder();

    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    boolean hasMatchConstraints();
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints();
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder();

    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> 
        getValidationsList();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getValidations(int index);
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    int getValidationsCount();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
        getValidationsOrBuilderList();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
        int index);

    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> 
        getAuditAnnotationsList();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getAuditAnnotations(int index);
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    int getAuditAnnotationsCount();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
        getAuditAnnotationsOrBuilderList();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
        int index);

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> 
        getVariablesList();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index);
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    int getVariablesCount();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec}
   */
  public  static final class ValidatingAdmissionPolicySpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
      ValidatingAdmissionPolicySpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicySpec.newBuilder() to construct.
    private ValidatingAdmissionPolicySpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicySpec() {
      validations_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      auditAnnotations_ = java.util.Collections.emptyList();
      matchConditions_ = java.util.Collections.emptyList();
      variables_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicySpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = paramKind_.toBuilder();
              }
              paramKind_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paramKind_);
                paramKind_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = matchConstraints_.toBuilder();
              }
              matchConstraints_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matchConstraints_);
                matchConstraints_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                validations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation>();
                mutable_bitField0_ |= 0x00000004;
              }
              validations_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                auditAnnotations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation>();
                mutable_bitField0_ |= 0x00000010;
              }
              auditAnnotations_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.PARSER, extensionRegistry));
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000020;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable>();
                mutable_bitField0_ |= 0x00000040;
              }
              variables_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          validations_ = java.util.Collections.unmodifiableList(validations_);
        }
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          auditAnnotations_ = java.util.Collections.unmodifiableList(auditAnnotations_);
        }
        if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          variables_ = java.util.Collections.unmodifiableList(variables_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder.class);
    }

    private int bitField0_;
    public static final int PARAMKIND_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind paramKind_;
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    public boolean hasParamKind() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }

    public static final int MATCHCONSTRAINTS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchConstraints_;
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    public boolean hasMatchConstraints() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }

    public static final int VALIDATIONS_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> validations_;
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> getValidationsList() {
      return validations_;
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
        getValidationsOrBuilderList() {
      return validations_;
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    public int getValidationsCount() {
      return validations_.size();
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getValidations(int index) {
      return validations_.get(index);
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
        int index) {
      return validations_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AUDITANNOTATIONS_FIELD_NUMBER = 5;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> auditAnnotations_;
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> getAuditAnnotationsList() {
      return auditAnnotations_;
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
        getAuditAnnotationsOrBuilderList() {
      return auditAnnotations_;
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public int getAuditAnnotationsCount() {
      return auditAnnotations_.size();
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getAuditAnnotations(int index) {
      return auditAnnotations_.get(index);
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
        int index) {
      return auditAnnotations_.get(index);
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 6;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    public static final int VARIABLES_FIELD_NUMBER = 7;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> variables_;
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> getVariablesList() {
      return variables_;
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList() {
      return variables_;
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    public int getVariablesCount() {
      return variables_.size();
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index) {
      return variables_.get(index);
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index) {
      return variables_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getMatchConstraints());
      }
      for (int i = 0; i < validations_.size(); i++) {
        output.writeMessage(3, validations_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, failurePolicy_);
      }
      for (int i = 0; i < auditAnnotations_.size(); i++) {
        output.writeMessage(5, auditAnnotations_.get(i));
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(6, matchConditions_.get(i));
      }
      for (int i = 0; i < variables_.size(); i++) {
        output.writeMessage(7, variables_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMatchConstraints());
      }
      for (int i = 0; i < validations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, validations_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, failurePolicy_);
      }
      for (int i = 0; i < auditAnnotations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, auditAnnotations_.get(i));
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, matchConditions_.get(i));
      }
      for (int i = 0; i < variables_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, variables_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec) obj;

      boolean result = true;
      result = result && (hasParamKind() == other.hasParamKind());
      if (hasParamKind()) {
        result = result && getParamKind()
            .equals(other.getParamKind());
      }
      result = result && (hasMatchConstraints() == other.hasMatchConstraints());
      if (hasMatchConstraints()) {
        result = result && getMatchConstraints()
            .equals(other.getMatchConstraints());
      }
      result = result && getValidationsList()
          .equals(other.getValidationsList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && getAuditAnnotationsList()
          .equals(other.getAuditAnnotationsList());
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && getVariablesList()
          .equals(other.getVariablesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParamKind()) {
        hash = (37 * hash) + PARAMKIND_FIELD_NUMBER;
        hash = (53 * hash) + getParamKind().hashCode();
      }
      if (hasMatchConstraints()) {
        hash = (37 * hash) + MATCHCONSTRAINTS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConstraints().hashCode();
      }
      if (getValidationsCount() > 0) {
        hash = (37 * hash) + VALIDATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getValidationsList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (getAuditAnnotationsCount() > 0) {
        hash = (37 * hash) + AUDITANNOTATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAuditAnnotationsList().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      if (getVariablesCount() > 0) {
        hash = (37 * hash) + VARIABLES_FIELD_NUMBER;
        hash = (53 * hash) + getVariablesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParamKindFieldBuilder();
          getMatchConstraintsFieldBuilder();
          getValidationsFieldBuilder();
          getAuditAnnotationsFieldBuilder();
          getMatchConditionsFieldBuilder();
          getVariablesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (paramKindBuilder_ == null) {
          paramKind_ = null;
        } else {
          paramKindBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = null;
        } else {
          matchConstraintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (validationsBuilder_ == null) {
          validations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          validationsBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          auditAnnotationsBuilder_.clear();
        }
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          matchConditionsBuilder_.clear();
        }
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
        } else {
          variablesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (paramKindBuilder_ == null) {
          result.paramKind_ = paramKind_;
        } else {
          result.paramKind_ = paramKindBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (matchConstraintsBuilder_ == null) {
          result.matchConstraints_ = matchConstraints_;
        } else {
          result.matchConstraints_ = matchConstraintsBuilder_.build();
        }
        if (validationsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            validations_ = java.util.Collections.unmodifiableList(validations_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.validations_ = validations_;
        } else {
          result.validations_ = validationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (auditAnnotationsBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            auditAnnotations_ = java.util.Collections.unmodifiableList(auditAnnotations_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.auditAnnotations_ = auditAnnotations_;
        } else {
          result.auditAnnotations_ = auditAnnotationsBuilder_.build();
        }
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        if (variablesBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040)) {
            variables_ = java.util.Collections.unmodifiableList(variables_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.variables_ = variables_;
        } else {
          result.variables_ = variablesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance()) return this;
        if (other.hasParamKind()) {
          mergeParamKind(other.getParamKind());
        }
        if (other.hasMatchConstraints()) {
          mergeMatchConstraints(other.getMatchConstraints());
        }
        if (validationsBuilder_ == null) {
          if (!other.validations_.isEmpty()) {
            if (validations_.isEmpty()) {
              validations_ = other.validations_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureValidationsIsMutable();
              validations_.addAll(other.validations_);
            }
            onChanged();
          }
        } else {
          if (!other.validations_.isEmpty()) {
            if (validationsBuilder_.isEmpty()) {
              validationsBuilder_.dispose();
              validationsBuilder_ = null;
              validations_ = other.validations_;
              bitField0_ = (bitField0_ & ~0x00000004);
              validationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getValidationsFieldBuilder() : null;
            } else {
              validationsBuilder_.addAllMessages(other.validations_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000008;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (auditAnnotationsBuilder_ == null) {
          if (!other.auditAnnotations_.isEmpty()) {
            if (auditAnnotations_.isEmpty()) {
              auditAnnotations_ = other.auditAnnotations_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureAuditAnnotationsIsMutable();
              auditAnnotations_.addAll(other.auditAnnotations_);
            }
            onChanged();
          }
        } else {
          if (!other.auditAnnotations_.isEmpty()) {
            if (auditAnnotationsBuilder_.isEmpty()) {
              auditAnnotationsBuilder_.dispose();
              auditAnnotationsBuilder_ = null;
              auditAnnotations_ = other.auditAnnotations_;
              bitField0_ = (bitField0_ & ~0x00000010);
              auditAnnotationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getAuditAnnotationsFieldBuilder() : null;
            } else {
              auditAnnotationsBuilder_.addAllMessages(other.auditAnnotations_);
            }
          }
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        if (variablesBuilder_ == null) {
          if (!other.variables_.isEmpty()) {
            if (variables_.isEmpty()) {
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureVariablesIsMutable();
              variables_.addAll(other.variables_);
            }
            onChanged();
          }
        } else {
          if (!other.variables_.isEmpty()) {
            if (variablesBuilder_.isEmpty()) {
              variablesBuilder_.dispose();
              variablesBuilder_ = null;
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000040);
              variablesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVariablesFieldBuilder() : null;
            } else {
              variablesBuilder_.addAllMessages(other.variables_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind paramKind_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder> paramKindBuilder_;
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public boolean hasParamKind() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind getParamKind() {
        if (paramKindBuilder_ == null) {
          return paramKind_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        } else {
          return paramKindBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramKind_ = value;
          onChanged();
        } else {
          paramKindBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder builderForValue) {
        if (paramKindBuilder_ == null) {
          paramKind_ = builderForValue.build();
          onChanged();
        } else {
          paramKindBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder mergeParamKind(io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              paramKind_ != null &&
              paramKind_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance()) {
            paramKind_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.newBuilder(paramKind_).mergeFrom(value).buildPartial();
          } else {
            paramKind_ = value;
          }
          onChanged();
        } else {
          paramKindBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public Builder clearParamKind() {
        if (paramKindBuilder_ == null) {
          paramKind_ = null;
          onChanged();
        } else {
          paramKindBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder getParamKindBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getParamKindFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
        if (paramKindBuilder_ != null) {
          return paramKindBuilder_.getMessageOrBuilder();
        } else {
          return paramKind_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        }
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ParamKind paramKind = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder> 
          getParamKindFieldBuilder() {
        if (paramKindBuilder_ == null) {
          paramKindBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ParamKindOrBuilder>(
                  getParamKind(),
                  getParentForChildren(),
                  isClean());
          paramKind_ = null;
        }
        return paramKindBuilder_;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources matchConstraints_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> matchConstraintsBuilder_;
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public boolean hasMatchConstraints() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources getMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          return matchConstraints_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        } else {
          return matchConstraintsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchConstraints_ = value;
          onChanged();
        } else {
          matchConstraintsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = builderForValue.build();
          onChanged();
        } else {
          matchConstraintsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder mergeMatchConstraints(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              matchConstraints_ != null &&
              matchConstraints_ != io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance()) {
            matchConstraints_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.newBuilder(matchConstraints_).mergeFrom(value).buildPartial();
          } else {
            matchConstraints_ = value;
          }
          onChanged();
        } else {
          matchConstraintsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public Builder clearMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = null;
          onChanged();
        } else {
          matchConstraintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder getMatchConstraintsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMatchConstraintsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
        if (matchConstraintsBuilder_ != null) {
          return matchConstraintsBuilder_.getMessageOrBuilder();
        } else {
          return matchConstraints_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        }
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchConstraintsFieldBuilder() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraintsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchConstraints(),
                  getParentForChildren(),
                  isClean());
          matchConstraints_ = null;
        }
        return matchConstraintsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> validations_ =
        java.util.Collections.emptyList();
      private void ensureValidationsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          validations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation>(validations_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Validation, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> validationsBuilder_;

      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> getValidationsList() {
        if (validationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(validations_);
        } else {
          return validationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public int getValidationsCount() {
        if (validationsBuilder_ == null) {
          return validations_.size();
        } else {
          return validationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getValidations(int index) {
        if (validationsBuilder_ == null) {
          return validations_.get(index);
        } else {
          return validationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder setValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.set(index, value);
          onChanged();
        } else {
          validationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder setValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.set(index, builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.add(value);
          onChanged();
        } else {
          validationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.add(index, value);
          onChanged();
        } else {
          validationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.add(builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.add(index, builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder addAllValidations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.Validation> values) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, validations_);
          onChanged();
        } else {
          validationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder clearValidations() {
        if (validationsBuilder_ == null) {
          validations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          validationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public Builder removeValidations(int index) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.remove(index);
          onChanged();
        } else {
          validationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder getValidationsBuilder(
          int index) {
        return getValidationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
          int index) {
        if (validationsBuilder_ == null) {
          return validations_.get(index);  } else {
          return validationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
           getValidationsOrBuilderList() {
        if (validationsBuilder_ != null) {
          return validationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(validations_);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder addValidationsBuilder() {
        return getValidationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance());
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder addValidationsBuilder(
          int index) {
        return getValidationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance());
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Validation validations = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder> 
           getValidationsBuilderList() {
        return getValidationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Validation, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder> 
          getValidationsFieldBuilder() {
        if (validationsBuilder_ == null) {
          validationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.Validation, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder>(
                  validations_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          validations_ = null;
        }
        return validationsBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> auditAnnotations_ =
        java.util.Collections.emptyList();
      private void ensureAuditAnnotationsIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          auditAnnotations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation>(auditAnnotations_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> auditAnnotationsBuilder_;

      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> getAuditAnnotationsList() {
        if (auditAnnotationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(auditAnnotations_);
        } else {
          return auditAnnotationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public int getAuditAnnotationsCount() {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.size();
        } else {
          return auditAnnotationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation getAuditAnnotations(int index) {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.get(index);
        } else {
          return auditAnnotationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder setAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.set(index, value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder setAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.set(index, builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(index, value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(index, builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAllAuditAnnotations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation> values) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, auditAnnotations_);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder clearAuditAnnotations() {
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          auditAnnotationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder removeAuditAnnotations(int index) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.remove(index);
          onChanged();
        } else {
          auditAnnotationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder getAuditAnnotationsBuilder(
          int index) {
        return getAuditAnnotationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
          int index) {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.get(index);  } else {
          return auditAnnotationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
           getAuditAnnotationsOrBuilderList() {
        if (auditAnnotationsBuilder_ != null) {
          return auditAnnotationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(auditAnnotations_);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder addAuditAnnotationsBuilder() {
        return getAuditAnnotationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder addAuditAnnotationsBuilder(
          int index) {
        return getAuditAnnotationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder> 
           getAuditAnnotationsBuilderList() {
        return getAuditAnnotationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder> 
          getAuditAnnotationsFieldBuilder() {
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.AuditAnnotationOrBuilder>(
                  auditAnnotations_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          auditAnnotations_ = null;
        }
        return auditAnnotationsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000020) == 0x00000020),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> variables_ =
        java.util.Collections.emptyList();
      private void ensureVariablesIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable>(variables_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> variablesBuilder_;

      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> getVariablesList() {
        if (variablesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(variables_);
        } else {
          return variablesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public int getVariablesCount() {
        if (variablesBuilder_ == null) {
          return variables_.size();
        } else {
          return variablesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getVariables(int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);
        } else {
          return variablesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.set(index, value);
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.set(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(index, value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder addAllVariables(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.Variable> values) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, variables_);
          onChanged();
        } else {
          variablesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder clearVariables() {
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          variablesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public Builder removeVariables(int index) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.remove(index);
          onChanged();
        } else {
          variablesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder getVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
          int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);  } else {
          return variablesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
           getVariablesOrBuilderList() {
        if (variablesBuilder_ != null) {
          return variablesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(variables_);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder addVariablesBuilder() {
        return getVariablesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder addVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.Variable variables = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder> 
           getVariablesBuilderList() {
        return getVariablesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder> 
          getVariablesFieldBuilder() {
        if (variablesBuilder_ == null) {
          variablesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.Variable, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder>(
                  variables_,
                  ((bitField0_ & 0x00000040) == 0x00000040),
                  getParentForChildren(),
                  isClean());
          variables_ = null;
        }
        return variablesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicySpec>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicySpec>() {
      @java.lang.Override
      public ValidatingAdmissionPolicySpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicySpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicySpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicySpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    long getObservedGeneration();

    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    boolean hasTypeChecking();
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getTypeChecking();
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder();

    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.Condition> 
        getConditionsList();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Condition getConditions(int index);
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus}
   */
  public  static final class ValidatingAdmissionPolicyStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
      ValidatingAdmissionPolicyStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyStatus.newBuilder() to construct.
    private ValidatingAdmissionPolicyStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyStatus() {
      observedGeneration_ = 0L;
      conditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              observedGeneration_ = input.readInt64();
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = typeChecking_.toBuilder();
              }
              typeChecking_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(typeChecking_);
                typeChecking_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.Condition>();
                mutable_bitField0_ |= 0x00000004;
              }
              conditions_.add(
                  input.readMessage(io.kubernetes.client.proto.Meta.Condition.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          conditions_ = java.util.Collections.unmodifiableList(conditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder.class);
    }

    private int bitField0_;
    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 1;
    private long observedGeneration_;
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int TYPECHECKING_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking typeChecking_;
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    public boolean hasTypeChecking() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getTypeChecking() {
      return typeChecking_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
    }
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder() {
      return typeChecking_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.Meta.Condition> conditions_;
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.Meta.Condition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.Condition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getTypeChecking());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(3, conditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getTypeChecking());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, conditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus) obj;

      boolean result = true;
      result = result && (hasObservedGeneration() == other.hasObservedGeneration());
      if (hasObservedGeneration()) {
        result = result && (getObservedGeneration()
            == other.getObservedGeneration());
      }
      result = result && (hasTypeChecking() == other.hasTypeChecking());
      if (hasTypeChecking()) {
        result = result && getTypeChecking()
            .equals(other.getTypeChecking());
      }
      result = result && getConditionsList()
          .equals(other.getConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasTypeChecking()) {
        hash = (37 * hash) + TYPECHECKING_FIELD_NUMBER;
        hash = (53 * hash) + getTypeChecking().hashCode();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTypeCheckingFieldBuilder();
          getConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        observedGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = null;
        } else {
          typeCheckingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.observedGeneration_ = observedGeneration_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (typeCheckingBuilder_ == null) {
          result.typeChecking_ = typeChecking_;
        } else {
          result.typeChecking_ = typeCheckingBuilder_.build();
        }
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance()) return this;
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasTypeChecking()) {
          mergeTypeChecking(other.getTypeChecking());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long observedGeneration_ ;
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public Builder setObservedGeneration(long value) {
        bitField0_ |= 0x00000001;
        observedGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking typeChecking_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder> typeCheckingBuilder_;
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public boolean hasTypeChecking() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking getTypeChecking() {
        if (typeCheckingBuilder_ == null) {
          return typeChecking_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
        } else {
          return typeCheckingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder setTypeChecking(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking value) {
        if (typeCheckingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          typeChecking_ = value;
          onChanged();
        } else {
          typeCheckingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder setTypeChecking(
          io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder builderForValue) {
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = builderForValue.build();
          onChanged();
        } else {
          typeCheckingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder mergeTypeChecking(io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking value) {
        if (typeCheckingBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              typeChecking_ != null &&
              typeChecking_ != io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance()) {
            typeChecking_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.newBuilder(typeChecking_).mergeFrom(value).buildPartial();
          } else {
            typeChecking_ = value;
          }
          onChanged();
        } else {
          typeCheckingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public Builder clearTypeChecking() {
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = null;
          onChanged();
        } else {
          typeCheckingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder getTypeCheckingBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getTypeCheckingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder() {
        if (typeCheckingBuilder_ != null) {
          return typeCheckingBuilder_.getMessageOrBuilder();
        } else {
          return typeChecking_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
        }
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder> 
          getTypeCheckingFieldBuilder() {
        if (typeCheckingBuilder_ == null) {
          typeCheckingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.TypeCheckingOrBuilder>(
                  getTypeChecking(),
                  getParentForChildren(),
                  isClean());
          typeChecking_ = null;
        }
        return typeCheckingBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.Condition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.Condition>(conditions_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.Condition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.Condition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.Condition.getDefaultInstance());
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.Condition.getDefaultInstance());
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.Condition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyStatus>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    boolean hasClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder();

    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> 
        getRulesList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index);
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();

    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    boolean hasSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    java.lang.String getSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    com.google.protobuf.ByteString
        getSideEffectsBytes();

    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    int getTimeoutSeconds();

    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.util.List<java.lang.String>
        getAdmissionReviewVersionsList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    int getAdmissionReviewVersionsCount();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.lang.String getAdmissionReviewVersions(int index);
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index);

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook}
   */
  public  static final class ValidatingWebhook extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
      ValidatingWebhookOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingWebhook.newBuilder() to construct.
    private ValidatingWebhook(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhook() {
      name_ = "";
      rules_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchPolicy_ = "";
      sideEffects_ = "";
      timeoutSeconds_ = 0;
      admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      matchConditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingWebhook(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = clientConfig_.toBuilder();
              }
              clientConfig_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(clientConfig_);
                clientConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>();
                mutable_bitField0_ |= 0x00000004;
              }
              rules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 42: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = namespaceSelector_.toBuilder();
              }
              namespaceSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(namespaceSelector_);
                namespaceSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              sideEffects_ = bs;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000080;
              timeoutSeconds_ = input.readInt32();
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000200;
              }
              admissionReviewVersions_.add(bs);
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              matchPolicy_ = bs;
              break;
            }
            case 82: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = objectSelector_.toBuilder();
              }
              objectSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectSelector_);
                objectSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 90: {
              if (!((mutable_bitField0_ & 0x00000400) == 0x00000400)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000400;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000400) == 0x00000400)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CLIENTCONFIG_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_;
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    public boolean hasClientConfig() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }

    public static final int RULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_;
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Ignore.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 9;
    private volatile java.lang.Object matchPolicy_;
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Exact"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 10;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int SIDEEFFECTS_FIELD_NUMBER = 6;
    private volatile java.lang.Object sideEffects_;
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public boolean hasSideEffects() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public java.lang.String getSideEffects() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sideEffects_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: Unknown, None, Some, NoneOnDryRun
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some. Defaults to Unknown.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public com.google.protobuf.ByteString
        getSideEffectsBytes() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sideEffects_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 7;
    private int timeoutSeconds_;
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 30 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public int getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int ADMISSIONREVIEWVERSIONS_FIELD_NUMBER = 8;
    private com.google.protobuf.LazyStringList admissionReviewVersions_;
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getAdmissionReviewVersionsList() {
      return admissionReviewVersions_;
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public int getAdmissionReviewVersionsCount() {
      return admissionReviewVersions_.size();
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public java.lang.String getAdmissionReviewVersions(int index) {
      return admissionReviewVersions_.get(index);
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * Default to `['v1beta1']`.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index) {
      return admissionReviewVersions_.getByteString(index);
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 11;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(7, timeoutSeconds_);
      }
      for (int i = 0; i < admissionReviewVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, admissionReviewVersions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(10, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(11, matchConditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, timeoutSeconds_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < admissionReviewVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(admissionReviewVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAdmissionReviewVersionsList().size();
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, matchConditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasClientConfig() == other.hasClientConfig());
      if (hasClientConfig()) {
        result = result && getClientConfig()
            .equals(other.getClientConfig());
      }
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && (hasMatchPolicy() == other.hasMatchPolicy());
      if (hasMatchPolicy()) {
        result = result && getMatchPolicy()
            .equals(other.getMatchPolicy());
      }
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector()
            .equals(other.getNamespaceSelector());
      }
      result = result && (hasObjectSelector() == other.hasObjectSelector());
      if (hasObjectSelector()) {
        result = result && getObjectSelector()
            .equals(other.getObjectSelector());
      }
      result = result && (hasSideEffects() == other.hasSideEffects());
      if (hasSideEffects()) {
        result = result && getSideEffects()
            .equals(other.getSideEffects());
      }
      result = result && (hasTimeoutSeconds() == other.hasTimeoutSeconds());
      if (hasTimeoutSeconds()) {
        result = result && (getTimeoutSeconds()
            == other.getTimeoutSeconds());
      }
      result = result && getAdmissionReviewVersionsList()
          .equals(other.getAdmissionReviewVersionsList());
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasClientConfig()) {
        hash = (37 * hash) + CLIENTCONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getClientConfig().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (hasSideEffects()) {
        hash = (37 * hash) + SIDEEFFECTS_FIELD_NUMBER;
        hash = (53 * hash) + getSideEffects().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getTimeoutSeconds();
      }
      if (getAdmissionReviewVersionsCount() > 0) {
        hash = (37 * hash) + ADMISSIONREVIEWVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAdmissionReviewVersionsList().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getClientConfigFieldBuilder();
          getRulesFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          rulesBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        matchPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        sideEffects_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        timeoutSeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (clientConfigBuilder_ == null) {
          result.clientConfig_ = clientConfig_;
        } else {
          result.clientConfig_ = clientConfigBuilder_.build();
        }
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000008;
        }
        result.matchPolicy_ = matchPolicy_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000020;
        }
        if (objectSelectorBuilder_ == null) {
          result.objectSelector_ = objectSelector_;
        } else {
          result.objectSelector_ = objectSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sideEffects_ = sideEffects_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000080;
        }
        result.timeoutSeconds_ = timeoutSeconds_;
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.admissionReviewVersions_ = admissionReviewVersions_;
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) == 0x00000400)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasClientConfig()) {
          mergeClientConfig(other.getClientConfig());
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000008;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (other.hasMatchPolicy()) {
          bitField0_ |= 0x00000010;
          matchPolicy_ = other.matchPolicy_;
          onChanged();
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (other.hasSideEffects()) {
          bitField0_ |= 0x00000080;
          sideEffects_ = other.sideEffects_;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (!other.admissionReviewVersions_.isEmpty()) {
          if (admissionReviewVersions_.isEmpty()) {
            admissionReviewVersions_ = other.admissionReviewVersions_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureAdmissionReviewVersionsIsMutable();
            admissionReviewVersions_.addAll(other.admissionReviewVersions_);
          }
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000400);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig clientConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> clientConfigBuilder_;
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public boolean hasClientConfig() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getClientConfig() {
        if (clientConfigBuilder_ == null) {
          return clientConfig_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        } else {
          return clientConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientConfig_ = value;
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder builderForValue) {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = builderForValue.build();
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder mergeClientConfig(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              clientConfig_ != null &&
              clientConfig_ != io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance()) {
            clientConfig_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.newBuilder(clientConfig_).mergeFrom(value).buildPartial();
          } else {
            clientConfig_ = value;
          }
          onChanged();
        } else {
          clientConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder clearClientConfig() {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
          onChanged();
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder getClientConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getClientConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
        if (clientConfigBuilder_ != null) {
          return clientConfigBuilder_.getMessageOrBuilder();
        } else {
          return clientConfig_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder> 
          getClientConfigFieldBuilder() {
        if (clientConfigBuilder_ == null) {
          clientConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder>(
                  getClientConfig(),
                  getParentForChildren(),
                  isClean());
          clientConfig_ = null;
        }
        return clientConfigBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>(rules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Ignore.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder clearMatchPolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Exact"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020) &&
              namespaceSelector_ != null &&
              namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_).mergeFrom(value).buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040) &&
              objectSelector_ != null &&
              objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            objectSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(objectSelector_).mergeFrom(value).buildPartial();
          } else {
            objectSelector_ = value;
          }
          onChanged();
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder clearObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
          onChanged();
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.lang.Object sideEffects_ = "";
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public boolean hasSideEffects() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public java.lang.String getSideEffects() {
        java.lang.Object ref = sideEffects_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sideEffects_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public com.google.protobuf.ByteString
          getSideEffectsBytes() {
        java.lang.Object ref = sideEffects_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sideEffects_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffects(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder clearSideEffects() {
        bitField0_ = (bitField0_ & ~0x00000080);
        sideEffects_ = getDefaultInstance().getSideEffects();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: Unknown, None, Some, NoneOnDryRun
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some. Defaults to Unknown.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffectsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }

      private int timeoutSeconds_ ;
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public int getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder setTimeoutSeconds(int value) {
        bitField0_ |= 0x00000100;
        timeoutSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 30 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        timeoutSeconds_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAdmissionReviewVersionsIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList(admissionReviewVersions_);
          bitField0_ |= 0x00000200;
         }
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getAdmissionReviewVersionsList() {
        return admissionReviewVersions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public int getAdmissionReviewVersionsCount() {
        return admissionReviewVersions_.size();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public java.lang.String getAdmissionReviewVersions(int index) {
        return admissionReviewVersions_.get(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ByteString
          getAdmissionReviewVersionsBytes(int index) {
        return admissionReviewVersions_.getByteString(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder setAdmissionReviewVersions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAllAdmissionReviewVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureAdmissionReviewVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, admissionReviewVersions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder clearAdmissionReviewVersions() {
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * Default to `['v1beta1']`.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000400) == 0x00000400)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000400) == 0x00000400),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingWebhook>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhook>() {
      @java.lang.Override
      public ValidatingWebhook parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingWebhook(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhook> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhook> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> 
        getWebhooksList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getWebhooks(int index);
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    int getWebhooksCount();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
        getWebhooksOrBuilderList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
   * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration}
   */
  public  static final class ValidatingWebhookConfiguration extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
      ValidatingWebhookConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingWebhookConfiguration.newBuilder() to construct.
    private ValidatingWebhookConfiguration(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhookConfiguration() {
      webhooks_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingWebhookConfiguration(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook>();
                mutable_bitField0_ |= 0x00000002;
              }
              webhooks_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int WEBHOOKS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> webhooks_;
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> getWebhooksList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
        getWebhooksOrBuilderList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    public int getWebhooksCount() {
      return webhooks_.size();
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getWebhooks(int index) {
      return webhooks_.get(index);
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
        int index) {
      return webhooks_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        output.writeMessage(2, webhooks_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, webhooks_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getWebhooksList()
          .equals(other.getWebhooksList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getWebhooksCount() > 0) {
        hash = (37 * hash) + WEBHOOKS_FIELD_NUMBER;
        hash = (53 * hash) + getWebhooksList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
     * Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getWebhooksFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (webhooksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.webhooks_ = webhooks_;
        } else {
          result.webhooks_ = webhooksBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (webhooksBuilder_ == null) {
          if (!other.webhooks_.isEmpty()) {
            if (webhooks_.isEmpty()) {
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureWebhooksIsMutable();
              webhooks_.addAll(other.webhooks_);
            }
            onChanged();
          }
        } else {
          if (!other.webhooks_.isEmpty()) {
            if (webhooksBuilder_.isEmpty()) {
              webhooksBuilder_.dispose();
              webhooksBuilder_ = null;
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              webhooksBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getWebhooksFieldBuilder() : null;
            } else {
              webhooksBuilder_.addAllMessages(other.webhooks_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> webhooks_ =
        java.util.Collections.emptyList();
      private void ensureWebhooksIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook>(webhooks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> webhooksBuilder_;

      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> getWebhooksList() {
        if (webhooksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(webhooks_);
        } else {
          return webhooksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public int getWebhooksCount() {
        if (webhooksBuilder_ == null) {
          return webhooks_.size();
        } else {
          return webhooksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook getWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);
        } else {
          return webhooksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.set(index, value);
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.set(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(index, value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addAllWebhooks(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook> values) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, webhooks_);
          onChanged();
        } else {
          webhooksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder clearWebhooks() {
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder removeWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.remove(index);
          onChanged();
        } else {
          webhooksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder getWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
          int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);  } else {
          return webhooksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
           getWebhooksOrBuilderList() {
        if (webhooksBuilder_ != null) {
          return webhooksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(webhooks_);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder addWebhooksBuilder() {
        return getWebhooksFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder addWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder> 
           getWebhooksBuilderList() {
        return getWebhooksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder> 
          getWebhooksFieldBuilder() {
        if (webhooksBuilder_ == null) {
          webhooksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookOrBuilder>(
                  webhooks_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          webhooks_ = null;
        }
        return webhooksBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingWebhookConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhookConfiguration>() {
      @java.lang.Override
      public ValidatingWebhookConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingWebhookConfiguration(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhookConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhookConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookConfigurationListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getItems(int index);
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList}
   */
  public  static final class ValidatingWebhookConfigurationList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
      ValidatingWebhookConfigurationListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingWebhookConfigurationList.newBuilder() to construct.
    private ValidatingWebhookConfigurationList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhookConfigurationList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingWebhookConfigurationList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> items_;
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList other = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList result = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingWebhookConfigurationList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhookConfigurationList>() {
      @java.lang.Override
      public ValidatingWebhookConfigurationList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingWebhookConfigurationList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhookConfigurationList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhookConfigurationList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.Validation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();

    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    boolean hasMessage();
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    boolean hasReason();
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    java.lang.String getReason();
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    boolean hasMessageExpression();
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    java.lang.String getMessageExpression();
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    com.google.protobuf.ByteString
        getMessageExpressionBytes();
  }
  /**
   * <pre>
   * Validation specifies the CEL expression which is used to apply the validation.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Validation}
   */
  public  static final class Validation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.Validation)
      ValidationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Validation.newBuilder() to construct.
    private Validation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Validation() {
      expression_ = "";
      message_ = "";
      reason_ = "";
      messageExpression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Validation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              expression_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              message_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              reason_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              messageExpression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder.class);
    }

    private int bitField0_;
    public static final int EXPRESSION_FIELD_NUMBER = 1;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    private volatile java.lang.Object message_;
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REASON_FIELD_NUMBER = 3;
    private volatile java.lang.Object reason_;
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    public boolean hasReason() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGEEXPRESSION_FIELD_NUMBER = 4;
    private volatile java.lang.Object messageExpression_;
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    public boolean hasMessageExpression() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    public java.lang.String getMessageExpression() {
      java.lang.Object ref = messageExpression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          messageExpression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    public com.google.protobuf.ByteString
        getMessageExpressionBytes() {
      java.lang.Object ref = messageExpression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        messageExpression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, expression_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, reason_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, messageExpression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, expression_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, reason_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, messageExpression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Validation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.Validation other = (io.kubernetes.client.proto.V1beta1Admissionregistration.Validation) obj;

      boolean result = true;
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && (hasMessage() == other.hasMessage());
      if (hasMessage()) {
        result = result && getMessage()
            .equals(other.getMessage());
      }
      result = result && (hasReason() == other.hasReason());
      if (hasReason()) {
        result = result && getReason()
            .equals(other.getReason());
      }
      result = result && (hasMessageExpression() == other.hasMessageExpression());
      if (hasMessageExpression()) {
        result = result && getMessageExpression()
            .equals(other.getMessageExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessageExpression()) {
        hash = (37 * hash) + MESSAGEEXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getMessageExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Validation specifies the CEL expression which is used to apply the validation.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Validation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.Validation)
        io.kubernetes.client.proto.V1beta1Admissionregistration.ValidationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        reason_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        messageExpression_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Validation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Validation result = new io.kubernetes.client.proto.V1beta1Admissionregistration.Validation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.expression_ = expression_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.message_ = message_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.reason_ = reason_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.messageExpression_ = messageExpression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Validation) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.Validation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.Validation other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.Validation.getDefaultInstance()) return this;
        if (other.hasExpression()) {
          bitField0_ |= 0x00000001;
          expression_ = other.expression_;
          onChanged();
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000002;
          message_ = other.message_;
          onChanged();
        }
        if (other.hasReason()) {
          bitField0_ |= 0x00000004;
          reason_ = other.reason_;
          onChanged();
        }
        if (other.hasMessageExpression()) {
          bitField0_ |= 0x00000008;
          messageExpression_ = other.messageExpression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Validation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.Validation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000002);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        message_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        reason_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000004);
        reason_ = getDefaultInstance().getReason();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        reason_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object messageExpression_ = "";
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public boolean hasMessageExpression() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public java.lang.String getMessageExpression() {
        java.lang.Object ref = messageExpression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            messageExpression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public com.google.protobuf.ByteString
          getMessageExpressionBytes() {
        java.lang.Object ref = messageExpression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          messageExpression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public Builder setMessageExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        messageExpression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public Builder clearMessageExpression() {
        bitField0_ = (bitField0_ & ~0x00000008);
        messageExpression_ = getDefaultInstance().getMessageExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public Builder setMessageExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        messageExpression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.Validation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.Validation)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.Validation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.Validation();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Validation>
        PARSER = new com.google.protobuf.AbstractParser<Validation>() {
      @java.lang.Override
      public Validation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Validation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Validation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Validation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Validation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VariableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.Variable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Variable}
   */
  public  static final class Variable extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.Variable)
      VariableOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Variable.newBuilder() to construct.
    private Variable(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Variable() {
      name_ = "";
      expression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Variable(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              expression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPRESSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, expression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, expression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Variable)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.Variable other = (io.kubernetes.client.proto.V1beta1Admissionregistration.Variable) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.Variable}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.Variable)
        io.kubernetes.client.proto.V1beta1Admissionregistration.VariableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.class, io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Variable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Variable result = new io.kubernetes.client.proto.V1beta1Admissionregistration.Variable(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.expression_ = expression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.Variable) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.Variable)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.Variable other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.Variable.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasExpression()) {
          bitField0_ |= 0x00000002;
          expression_ = other.expression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.Variable parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.Variable) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000002);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.Variable)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.Variable)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.Variable DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.Variable();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Variable>
        PARSER = new com.google.protobuf.AbstractParser<Variable>() {
      @java.lang.Override
      public Variable parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Variable(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Variable> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Variable> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.Variable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface WebhookClientConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    boolean hasUrl();
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    boolean hasService();
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getService();
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder();

    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    boolean hasCaBundle();
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    com.google.protobuf.ByteString getCaBundle();
  }
  /**
   * <pre>
   * WebhookClientConfig contains the information to make a TLS
   * connection with the webhook
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig}
   */
  public  static final class WebhookClientConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
      WebhookClientConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use WebhookClientConfig.newBuilder() to construct.
    private WebhookClientConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private WebhookClientConfig() {
      url_ = "";
      caBundle_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private WebhookClientConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = service_.toBuilder();
              }
              service_ = input.readMessage(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(service_);
                service_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 18: {
              bitField0_ |= 0x00000004;
              caBundle_ = input.readBytes();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              url_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.class, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder.class);
    }

    private int bitField0_;
    public static final int URL_FIELD_NUMBER = 3;
    private volatile java.lang.Object url_;
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    public java.lang.String getUrl() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          url_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    public com.google.protobuf.ByteString
        getUrlBytes() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        url_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVICE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference service_;
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    public boolean hasService() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getService() {
      return service_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
    }
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
     */
    public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder() {
      return service_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
    }

    public static final int CABUNDLE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString caBundle_;
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    public boolean hasCaBundle() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    public com.google.protobuf.ByteString getCaBundle() {
      return caBundle_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(1, getService());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(2, caBundle_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, url_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getService());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, caBundle_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, url_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig other = (io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig) obj;

      boolean result = true;
      result = result && (hasUrl() == other.hasUrl());
      if (hasUrl()) {
        result = result && getUrl()
            .equals(other.getUrl());
      }
      result = result && (hasService() == other.hasService());
      if (hasService()) {
        result = result && getService()
            .equals(other.getService());
      }
      result = result && (hasCaBundle() == other.hasCaBundle());
      if (hasCaBundle()) {
        result = result && getCaBundle()
            .equals(other.getCaBundle());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasUrl()) {
        hash = (37 * hash) + URL_FIELD_NUMBER;
        hash = (53 * hash) + getUrl().hashCode();
      }
      if (hasService()) {
        hash = (37 * hash) + SERVICE_FIELD_NUMBER;
        hash = (53 * hash) + getService().hashCode();
      }
      if (hasCaBundle()) {
        hash = (37 * hash) + CABUNDLE_FIELD_NUMBER;
        hash = (53 * hash) + getCaBundle().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * WebhookClientConfig contains the information to make a TLS
     * connection with the webhook
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.class, io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getServiceFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        url_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (serviceBuilder_ == null) {
          service_ = null;
        } else {
          serviceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        caBundle_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig build() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig buildPartial() {
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig result = new io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.url_ = url_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (serviceBuilder_ == null) {
          result.service_ = service_;
        } else {
          result.service_ = serviceBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.caBundle_ = caBundle_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig) {
          return mergeFrom((io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig other) {
        if (other == io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig.getDefaultInstance()) return this;
        if (other.hasUrl()) {
          bitField0_ |= 0x00000001;
          url_ = other.url_;
          onChanged();
        }
        if (other.hasService()) {
          mergeService(other.getService());
        }
        if (other.hasCaBundle()) {
          setCaBundle(other.getCaBundle());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object url_ = "";
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public java.lang.String getUrl() {
        java.lang.Object ref = url_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            url_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public com.google.protobuf.ByteString
          getUrlBytes() {
        java.lang.Object ref = url_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          url_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public Builder setUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        url_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public Builder clearUrl() {
        bitField0_ = (bitField0_ & ~0x00000001);
        url_ = getDefaultInstance().getUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        url_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference service_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder> serviceBuilder_;
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public boolean hasService() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference getService() {
        if (serviceBuilder_ == null) {
          return service_ == null ? io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
        } else {
          return serviceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder setService(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference value) {
        if (serviceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          service_ = value;
          onChanged();
        } else {
          serviceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder setService(
          io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder builderForValue) {
        if (serviceBuilder_ == null) {
          service_ = builderForValue.build();
          onChanged();
        } else {
          serviceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder mergeService(io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference value) {
        if (serviceBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              service_ != null &&
              service_ != io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance()) {
            service_ =
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.newBuilder(service_).mergeFrom(value).buildPartial();
          } else {
            service_ = value;
          }
          onChanged();
        } else {
          serviceBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public Builder clearService() {
        if (serviceBuilder_ == null) {
          service_ = null;
          onChanged();
        } else {
          serviceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder getServiceBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getServiceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder() {
        if (serviceBuilder_ != null) {
          return serviceBuilder_.getMessageOrBuilder();
        } else {
          return service_ == null ?
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
        }
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1beta1.ServiceReference service = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder> 
          getServiceFieldBuilder() {
        if (serviceBuilder_ == null) {
          serviceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1beta1Admissionregistration.ServiceReferenceOrBuilder>(
                  getService(),
                  getParentForChildren(),
                  isClean());
          service_ = null;
        }
        return serviceBuilder_;
      }

      private com.google.protobuf.ByteString caBundle_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public boolean hasCaBundle() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public com.google.protobuf.ByteString getCaBundle() {
        return caBundle_;
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public Builder setCaBundle(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        caBundle_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public Builder clearCaBundle() {
        bitField0_ = (bitField0_ & ~0x00000004);
        caBundle_ = getDefaultInstance().getCaBundle();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1beta1.WebhookClientConfig)
    private static final io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig();
    }

    public static io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<WebhookClientConfig>
        PARSER = new com.google.protobuf.AbstractParser<WebhookClientConfig>() {
      @java.lang.Override
      public WebhookClientConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new WebhookClientConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<WebhookClientConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<WebhookClientConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1beta1Admissionregistration.WebhookClientConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n8k8s.io/api/admissionregistration/v1bet" +
      "a1/generated.proto\022(k8s.io.api.admission" +
      "registration.v1beta1\0323k8s.io/api/admissi" +
      "onregistration/v1/generated.proto\0324k8s.i" +
      "o/apimachinery/pkg/apis/meta/v1/generate" +
      "d.proto\032/k8s.io/apimachinery/pkg/runtime" +
      "/generated.proto\0326k8s.io/apimachinery/pk" +
      "g/runtime/schema/generated.proto\"(\n\022Appl" +
      "yConfiguration\022\022\n\nexpression\030\001 \001(\t\"7\n\017Au" +
      "ditAnnotation\022\013\n\003key\030\001 \001(\t\022\027\n\017valueExpre" +
      "ssion\030\002 \001(\t\"6\n\021ExpressionWarning\022\020\n\010fiel" +
      "dRef\030\002 \001(\t\022\017\n\007warning\030\003 \001(\t\"\037\n\tJSONPatch" +
      "\022\022\n\nexpression\030\001 \001(\t\"2\n\016MatchCondition\022\014" +
      "\n\004name\030\001 \001(\t\022\022\n\nexpression\030\002 \001(\t\"\375\002\n\016Mat" +
      "chResources\022N\n\021namespaceSelector\030\001 \001(\01323" +
      ".k8s.io.apimachinery.pkg.apis.meta.v1.La" +
      "belSelector\022K\n\016objectSelector\030\002 \001(\01323.k8" +
      "s.io.apimachinery.pkg.apis.meta.v1.Label" +
      "Selector\022X\n\rresourceRules\030\003 \003(\0132A.k8s.io" +
      ".api.admissionregistration.v1beta1.Named" +
      "RuleWithOperations\022_\n\024excludeResourceRul" +
      "es\030\004 \003(\0132A.k8s.io.api.admissionregistrat" +
      "ion.v1beta1.NamedRuleWithOperations\022\023\n\013m" +
      "atchPolicy\030\007 \001(\t\"\262\001\n\027MutatingAdmissionPo" +
      "licy\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachi" +
      "nery.pkg.apis.meta.v1.ObjectMeta\022S\n\004spec" +
      "\030\002 \001(\0132E.k8s.io.api.admissionregistratio" +
      "n.v1beta1.MutatingAdmissionPolicySpec\"\300\001" +
      "\n\036MutatingAdmissionPolicyBinding\022B\n\010meta" +
      "data\030\001 \001(\01320.k8s.io.apimachinery.pkg.api" +
      "s.meta.v1.ObjectMeta\022Z\n\004spec\030\002 \001(\0132L.k8s" +
      ".io.api.admissionregistration.v1beta1.Mu" +
      "tatingAdmissionPolicyBindingSpec\"\277\001\n\"Mut" +
      "atingAdmissionPolicyBindingList\022@\n\010metad" +
      "ata\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.ListMeta\022W\n\005items\030\002 \003(\0132H.k8s.i" +
      "o.api.admissionregistration.v1beta1.Muta" +
      "tingAdmissionPolicyBinding\"\320\001\n\"MutatingA" +
      "dmissionPolicyBindingSpec\022\022\n\npolicyName\030" +
      "\001 \001(\t\022D\n\010paramRef\030\002 \001(\01322.k8s.io.api.adm" +
      "issionregistration.v1beta1.ParamRef\022P\n\016m" +
      "atchResources\030\003 \001(\01328.k8s.io.api.admissi" +
      "onregistration.v1beta1.MatchResources\"\261\001" +
      "\n\033MutatingAdmissionPolicyList\022@\n\010metadat" +
      "a\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis.m" +
      "eta.v1.ListMeta\022P\n\005items\030\002 \003(\0132A.k8s.io." +
      "api.admissionregistration.v1beta1.Mutati" +
      "ngAdmissionPolicy\"\315\003\n\033MutatingAdmissionP" +
      "olicySpec\022F\n\tparamKind\030\001 \001(\01323.k8s.io.ap" +
      "i.admissionregistration.v1beta1.ParamKin" +
      "d\022R\n\020matchConstraints\030\002 \001(\01328.k8s.io.api" +
      ".admissionregistration.v1beta1.MatchReso" +
      "urces\022E\n\tvariables\030\003 \003(\01322.k8s.io.api.ad" +
      "missionregistration.v1beta1.Variable\022E\n\t" +
      "mutations\030\004 \003(\01322.k8s.io.api.admissionre" +
      "gistration.v1beta1.Mutation\022\025\n\rfailurePo" +
      "licy\030\005 \001(\t\022Q\n\017matchConditions\030\006 \003(\01328.k8" +
      "s.io.api.admissionregistration.v1beta1.M" +
      "atchCondition\022\032\n\022reinvocationPolicy\030\007 \001(" +
      "\t\"\302\004\n\017MutatingWebhook\022\014\n\004name\030\001 \001(\t\022S\n\014c" +
      "lientConfig\030\002 \001(\0132=.k8s.io.api.admission" +
      "registration.v1beta1.WebhookClientConfig" +
      "\022F\n\005rules\030\003 \003(\01327.k8s.io.api.admissionre" +
      "gistration.v1.RuleWithOperations\022\025\n\rfail" +
      "urePolicy\030\004 \001(\t\022\023\n\013matchPolicy\030\t \001(\t\022N\n\021" +
      "namespaceSelector\030\005 \001(\01323.k8s.io.apimach" +
      "inery.pkg.apis.meta.v1.LabelSelector\022K\n\016" +
      "objectSelector\030\013 \001(\01323.k8s.io.apimachine" +
      "ry.pkg.apis.meta.v1.LabelSelector\022\023\n\013sid" +
      "eEffects\030\006 \001(\t\022\026\n\016timeoutSeconds\030\007 \001(\005\022\037" +
      "\n\027admissionReviewVersions\030\010 \003(\t\022\032\n\022reinv" +
      "ocationPolicy\030\n \001(\t\022Q\n\017matchConditions\030\014" +
      " \003(\01328.k8s.io.api.admissionregistration." +
      "v1beta1.MatchCondition\"\257\001\n\034MutatingWebho" +
      "okConfiguration\022B\n\010metadata\030\001 \001(\01320.k8s." +
      "io.apimachinery.pkg.apis.meta.v1.ObjectM" +
      "eta\022K\n\010Webhooks\030\002 \003(\01329.k8s.io.api.admis" +
      "sionregistration.v1beta1.MutatingWebhook" +
      "\"\273\001\n MutatingWebhookConfigurationList\022@\n" +
      "\010metadata\030\001 \001(\0132..k8s.io.apimachinery.pk" +
      "g.apis.meta.v1.ListMeta\022U\n\005items\030\002 \003(\0132F" +
      ".k8s.io.api.admissionregistration.v1beta" +
      "1.MutatingWebhookConfiguration\"\277\001\n\010Mutat" +
      "ion\022\021\n\tpatchType\030\002 \001(\t\022X\n\022applyConfigura" +
      "tion\030\003 \001(\0132<.k8s.io.api.admissionregistr" +
      "ation.v1beta1.ApplyConfiguration\022F\n\tjson" +
      "Patch\030\004 \001(\01323.k8s.io.api.admissionregist" +
      "ration.v1beta1.JSONPatch\"\205\001\n\027NamedRuleWi" +
      "thOperations\022\025\n\rresourceNames\030\001 \003(\t\022S\n\022r" +
      "uleWithOperations\030\002 \001(\01327.k8s.io.api.adm" +
      "issionregistration.v1.RuleWithOperations" +
      "\"-\n\tParamKind\022\022\n\napiVersion\030\001 \001(\t\022\014\n\004kin" +
      "d\030\002 \001(\t\"\223\001\n\010ParamRef\022\014\n\004name\030\001 \001(\t\022\021\n\tna" +
      "mespace\030\002 \001(\t\022E\n\010selector\030\003 \001(\01323.k8s.io" +
      ".apimachinery.pkg.apis.meta.v1.LabelSele" +
      "ctor\022\037\n\027parameterNotFoundAction\030\004 \001(\t\"O\n" +
      "\020ServiceReference\022\021\n\tnamespace\030\001 \001(\t\022\014\n\004" +
      "name\030\002 \001(\t\022\014\n\004path\030\003 \001(\t\022\014\n\004port\030\004 \001(\005\"g" +
      "\n\014TypeChecking\022W\n\022expressionWarnings\030\001 \003" +
      "(\0132;.k8s.io.api.admissionregistration.v1" +
      "beta1.ExpressionWarning\"\221\002\n\031ValidatingAd" +
      "missionPolicy\022B\n\010metadata\030\001 \001(\01320.k8s.io" +
      ".apimachinery.pkg.apis.meta.v1.ObjectMet" +
      "a\022U\n\004spec\030\002 \001(\0132G.k8s.io.api.admissionre" +
      "gistration.v1beta1.ValidatingAdmissionPo" +
      "licySpec\022Y\n\006status\030\003 \001(\0132I.k8s.io.api.ad" +
      "missionregistration.v1beta1.ValidatingAd" +
      "missionPolicyStatus\"\304\001\n ValidatingAdmiss" +
      "ionPolicyBinding\022B\n\010metadata\030\001 \001(\01320.k8s" +
      ".io.apimachinery.pkg.apis.meta.v1.Object" +
      "Meta\022\\\n\004spec\030\002 \001(\0132N.k8s.io.api.admissio" +
      "nregistration.v1beta1.ValidatingAdmissio" +
      "nPolicyBindingSpec\"\303\001\n$ValidatingAdmissi" +
      "onPolicyBindingList\022@\n\010metadata\030\001 \001(\0132.." +
      "k8s.io.apimachinery.pkg.apis.meta.v1.Lis" +
      "tMeta\022Y\n\005items\030\002 \003(\0132J.k8s.io.api.admiss" +
      "ionregistration.v1beta1.ValidatingAdmiss" +
      "ionPolicyBinding\"\355\001\n$ValidatingAdmission" +
      "PolicyBindingSpec\022\022\n\npolicyName\030\001 \001(\t\022D\n" +
      "\010paramRef\030\002 \001(\01322.k8s.io.api.admissionre" +
      "gistration.v1beta1.ParamRef\022P\n\016matchReso" +
      "urces\030\003 \001(\01328.k8s.io.api.admissionregist" +
      "ration.v1beta1.MatchResources\022\031\n\021validat" +
      "ionActions\030\004 \003(\t\"\265\001\n\035ValidatingAdmission" +
      "PolicyList\022@\n\010metadata\030\001 \001(\0132..k8s.io.ap" +
      "imachinery.pkg.apis.meta.v1.ListMeta\022R\n\005" +
      "items\030\002 \003(\0132C.k8s.io.api.admissionregist" +
      "ration.v1beta1.ValidatingAdmissionPolicy" +
      "\"\214\004\n\035ValidatingAdmissionPolicySpec\022F\n\tpa" +
      "ramKind\030\001 \001(\01323.k8s.io.api.admissionregi" +
      "stration.v1beta1.ParamKind\022R\n\020matchConst" +
      "raints\030\002 \001(\01328.k8s.io.api.admissionregis" +
      "tration.v1beta1.MatchResources\022I\n\013valida" +
      "tions\030\003 \003(\01324.k8s.io.api.admissionregist" +
      "ration.v1beta1.Validation\022\025\n\rfailurePoli" +
      "cy\030\004 \001(\t\022S\n\020auditAnnotations\030\005 \003(\01329.k8s" +
      ".io.api.admissionregistration.v1beta1.Au" +
      "ditAnnotation\022Q\n\017matchConditions\030\006 \003(\01328" +
      ".k8s.io.api.admissionregistration.v1beta" +
      "1.MatchCondition\022E\n\tvariables\030\007 \003(\01322.k8" +
      "s.io.api.admissionregistration.v1beta1.V" +
      "ariable\"\320\001\n\037ValidatingAdmissionPolicySta" +
      "tus\022\032\n\022observedGeneration\030\001 \001(\003\022L\n\014typeC" +
      "hecking\030\002 \001(\01326.k8s.io.api.admissionregi" +
      "stration.v1beta1.TypeChecking\022C\n\nconditi" +
      "ons\030\003 \003(\0132/.k8s.io.apimachinery.pkg.apis" +
      ".meta.v1.Condition\"\250\004\n\021ValidatingWebhook" +
      "\022\014\n\004name\030\001 \001(\t\022S\n\014clientConfig\030\002 \001(\0132=.k" +
      "8s.io.api.admissionregistration.v1beta1." +
      "WebhookClientConfig\022F\n\005rules\030\003 \003(\01327.k8s" +
      ".io.api.admissionregistration.v1.RuleWit" +
      "hOperations\022\025\n\rfailurePolicy\030\004 \001(\t\022\023\n\013ma" +
      "tchPolicy\030\t \001(\t\022N\n\021namespaceSelector\030\005 \001" +
      "(\01323.k8s.io.apimachinery.pkg.apis.meta.v" +
      "1.LabelSelector\022K\n\016objectSelector\030\n \001(\0132" +
      "3.k8s.io.apimachinery.pkg.apis.meta.v1.L" +
      "abelSelector\022\023\n\013sideEffects\030\006 \001(\t\022\026\n\016tim" +
      "eoutSeconds\030\007 \001(\005\022\037\n\027admissionReviewVers" +
      "ions\030\010 \003(\t\022Q\n\017matchConditions\030\013 \003(\01328.k8" +
      "s.io.api.admissionregistration.v1beta1.M" +
      "atchCondition\"\263\001\n\036ValidatingWebhookConfi" +
      "guration\022B\n\010metadata\030\001 \001(\01320.k8s.io.apim" +
      "achinery.pkg.apis.meta.v1.ObjectMeta\022M\n\010" +
      "Webhooks\030\002 \003(\0132;.k8s.io.api.admissionreg" +
      "istration.v1beta1.ValidatingWebhook\"\277\001\n\"" +
      "ValidatingWebhookConfigurationList\022@\n\010me" +
      "tadata\030\001 \001(\0132..k8s.io.apimachinery.pkg.a" +
      "pis.meta.v1.ListMeta\022W\n\005items\030\002 \003(\0132H.k8" +
      "s.io.api.admissionregistration.v1beta1.V" +
      "alidatingWebhookConfiguration\"\\\n\nValidat" +
      "ion\022\022\n\nExpression\030\001 \001(\t\022\017\n\007message\030\002 \001(\t" +
      "\022\016\n\006reason\030\003 \001(\t\022\031\n\021messageExpression\030\004 " +
      "\001(\t\",\n\010Variable\022\014\n\004Name\030\001 \001(\t\022\022\n\nExpress" +
      "ion\030\002 \001(\t\"\201\001\n\023WebhookClientConfig\022\013\n\003url" +
      "\030\003 \001(\t\022K\n\007service\030\001 \001(\0132:.k8s.io.api.adm" +
      "issionregistration.v1beta1.ServiceRefere" +
      "nce\022\020\n\010caBundle\030\002 \001(\014Bd\n\032io.kubernetes.c" +
      "lient.protoB\034V1beta1Admissionregistratio" +
      "nZ(k8s.io/api/admissionregistration/v1be" +
      "ta1"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1Admissionregistration.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
        }, assigner);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ApplyConfiguration_descriptor,
        new java.lang.String[] { "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_AuditAnnotation_descriptor,
        new java.lang.String[] { "Key", "ValueExpression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ExpressionWarning_descriptor,
        new java.lang.String[] { "FieldRef", "Warning", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_JSONPatch_descriptor,
        new java.lang.String[] { "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MatchCondition_descriptor,
        new java.lang.String[] { "Name", "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MatchResources_descriptor,
        new java.lang.String[] { "NamespaceSelector", "ObjectSelector", "ResourceRules", "ExcludeResourceRules", "MatchPolicy", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicy_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBinding_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyBindingSpec_descriptor,
        new java.lang.String[] { "PolicyName", "ParamRef", "MatchResources", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicyList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingAdmissionPolicySpec_descriptor,
        new java.lang.String[] { "ParamKind", "MatchConstraints", "Variables", "Mutations", "FailurePolicy", "MatchConditions", "ReinvocationPolicy", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhook_descriptor,
        new java.lang.String[] { "Name", "ClientConfig", "Rules", "FailurePolicy", "MatchPolicy", "NamespaceSelector", "ObjectSelector", "SideEffects", "TimeoutSeconds", "AdmissionReviewVersions", "ReinvocationPolicy", "MatchConditions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfiguration_descriptor,
        new java.lang.String[] { "Metadata", "Webhooks", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_MutatingWebhookConfigurationList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_Mutation_descriptor,
        new java.lang.String[] { "PatchType", "ApplyConfiguration", "JsonPatch", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_NamedRuleWithOperations_descriptor,
        new java.lang.String[] { "ResourceNames", "RuleWithOperations", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ParamKind_descriptor,
        new java.lang.String[] { "ApiVersion", "Kind", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ParamRef_descriptor,
        new java.lang.String[] { "Name", "Namespace", "Selector", "ParameterNotFoundAction", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ServiceReference_descriptor,
        new java.lang.String[] { "Namespace", "Name", "Path", "Port", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_TypeChecking_descriptor,
        new java.lang.String[] { "ExpressionWarnings", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicy_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBinding_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyBindingSpec_descriptor,
        new java.lang.String[] { "PolicyName", "ParamRef", "MatchResources", "ValidationActions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicySpec_descriptor,
        new java.lang.String[] { "ParamKind", "MatchConstraints", "Validations", "FailurePolicy", "AuditAnnotations", "MatchConditions", "Variables", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingAdmissionPolicyStatus_descriptor,
        new java.lang.String[] { "ObservedGeneration", "TypeChecking", "Conditions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor =
      getDescriptor().getMessageTypes().get(28);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhook_descriptor,
        new java.lang.String[] { "Name", "ClientConfig", "Rules", "FailurePolicy", "MatchPolicy", "NamespaceSelector", "ObjectSelector", "SideEffects", "TimeoutSeconds", "AdmissionReviewVersions", "MatchConditions", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(29);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfiguration_descriptor,
        new java.lang.String[] { "Metadata", "Webhooks", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor =
      getDescriptor().getMessageTypes().get(30);
    internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_ValidatingWebhookConfigurationList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor =
      getDescriptor().getMessageTypes().get(31);
    internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_Validation_descriptor,
        new java.lang.String[] { "Expression", "Message", "Reason", "MessageExpression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor =
      getDescriptor().getMessageTypes().get(32);
    internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_Variable_descriptor,
        new java.lang.String[] { "Name", "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor =
      getDescriptor().getMessageTypes().get(33);
    internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1beta1_WebhookClientConfig_descriptor,
        new java.lang.String[] { "Url", "Service", "CaBundle", });
    io.kubernetes.client.proto.V1Admissionregistration.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
