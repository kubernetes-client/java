// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/admissionregistration/v1/generated.proto

package io.kubernetes.client.proto;

public final class V1Admissionregistration {
  private V1Admissionregistration() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface AuditAnnotationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.AuditAnnotation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    boolean hasKey();
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    java.lang.String getKey();
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    boolean hasValueExpression();
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    java.lang.String getValueExpression();
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    com.google.protobuf.ByteString
        getValueExpressionBytes();
  }
  /**
   * <pre>
   * AuditAnnotation describes how to produce an audit annotation for an API request.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.AuditAnnotation}
   */
  public  static final class AuditAnnotation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.AuditAnnotation)
      AuditAnnotationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AuditAnnotation.newBuilder() to construct.
    private AuditAnnotation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AuditAnnotation() {
      key_ = "";
      valueExpression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AuditAnnotation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              key_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              valueExpression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.class, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    private volatile java.lang.Object key_;
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * key specifies the audit annotation key. The audit annotation keys of
     * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
     * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
     * The key is combined with the resource name of the
     * ValidatingAdmissionPolicy to construct an audit annotation key:
     * "{ValidatingAdmissionPolicy name}/{key}".
     * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
     * and the same audit annotation key, the annotation key will be identical.
     * In this case, the first annotation written with the key will be included
     * in the audit event and all subsequent annotations with the same key
     * will be discarded.
     * Required.
     * </pre>
     *
     * <code>optional string key = 1;</code>
     */
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUEEXPRESSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object valueExpression_;
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    public boolean hasValueExpression() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    public java.lang.String getValueExpression() {
      java.lang.Object ref = valueExpression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          valueExpression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * valueExpression represents the expression which is evaluated by CEL to
     * produce an audit annotation value. The expression must evaluate to either
     * a string or null value. If the expression evaluates to a string, the
     * audit annotation is included with the string value. If the expression
     * evaluates to null or empty string the audit annotation will be omitted.
     * The valueExpression may be no longer than 5kb in length.
     * If the result of the valueExpression is more than 10kb in length, it
     * will be truncated to 10kb.
     * If multiple ValidatingAdmissionPolicyBinding resources match an
     * API request, then the valueExpression will be evaluated for
     * each binding. All unique values produced by the valueExpressions
     * will be joined together in a comma-separated list.
     * Required.
     * </pre>
     *
     * <code>optional string valueExpression = 2;</code>
     */
    public com.google.protobuf.ByteString
        getValueExpressionBytes() {
      java.lang.Object ref = valueExpression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        valueExpression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, valueExpression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, valueExpression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation other = (io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation) obj;

      boolean result = true;
      result = result && (hasKey() == other.hasKey());
      if (hasKey()) {
        result = result && getKey()
            .equals(other.getKey());
      }
      result = result && (hasValueExpression() == other.hasValueExpression());
      if (hasValueExpression()) {
        result = result && getValueExpression()
            .equals(other.getValueExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasValueExpression()) {
        hash = (37 * hash) + VALUEEXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getValueExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * AuditAnnotation describes how to produce an audit annotation for an API request.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.AuditAnnotation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.AuditAnnotation)
        io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.class, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        key_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        valueExpression_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation build() {
        io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation result = new io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.key_ = key_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.valueExpression_ = valueExpression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.getDefaultInstance()) return this;
        if (other.hasKey()) {
          bitField0_ |= 0x00000001;
          key_ = other.key_;
          onChanged();
        }
        if (other.hasValueExpression()) {
          bitField0_ |= 0x00000002;
          valueExpression_ = other.valueExpression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object key_ = "";
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        key_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key specifies the audit annotation key. The audit annotation keys of
       * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
       * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
       * The key is combined with the resource name of the
       * ValidatingAdmissionPolicy to construct an audit annotation key:
       * "{ValidatingAdmissionPolicy name}/{key}".
       * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
       * and the same audit annotation key, the annotation key will be identical.
       * In this case, the first annotation written with the key will be included
       * in the audit event and all subsequent annotations with the same key
       * will be discarded.
       * Required.
       * </pre>
       *
       * <code>optional string key = 1;</code>
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        key_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object valueExpression_ = "";
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public boolean hasValueExpression() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public java.lang.String getValueExpression() {
        java.lang.Object ref = valueExpression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            valueExpression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public com.google.protobuf.ByteString
          getValueExpressionBytes() {
        java.lang.Object ref = valueExpression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          valueExpression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public Builder setValueExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        valueExpression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public Builder clearValueExpression() {
        bitField0_ = (bitField0_ & ~0x00000002);
        valueExpression_ = getDefaultInstance().getValueExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * valueExpression represents the expression which is evaluated by CEL to
       * produce an audit annotation value. The expression must evaluate to either
       * a string or null value. If the expression evaluates to a string, the
       * audit annotation is included with the string value. If the expression
       * evaluates to null or empty string the audit annotation will be omitted.
       * The valueExpression may be no longer than 5kb in length.
       * If the result of the valueExpression is more than 10kb in length, it
       * will be truncated to 10kb.
       * If multiple ValidatingAdmissionPolicyBinding resources match an
       * API request, then the valueExpression will be evaluated for
       * each binding. All unique values produced by the valueExpressions
       * will be joined together in a comma-separated list.
       * Required.
       * </pre>
       *
       * <code>optional string valueExpression = 2;</code>
       */
      public Builder setValueExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        valueExpression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.AuditAnnotation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.AuditAnnotation)
    private static final io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<AuditAnnotation>
        PARSER = new com.google.protobuf.AbstractParser<AuditAnnotation>() {
      @java.lang.Override
      public AuditAnnotation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AuditAnnotation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AuditAnnotation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AuditAnnotation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExpressionWarningOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ExpressionWarning)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    boolean hasFieldRef();
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    java.lang.String getFieldRef();
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    com.google.protobuf.ByteString
        getFieldRefBytes();

    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    boolean hasWarning();
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    java.lang.String getWarning();
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    com.google.protobuf.ByteString
        getWarningBytes();
  }
  /**
   * <pre>
   * ExpressionWarning is a warning information that targets a specific expression.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ExpressionWarning}
   */
  public  static final class ExpressionWarning extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ExpressionWarning)
      ExpressionWarningOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ExpressionWarning.newBuilder() to construct.
    private ExpressionWarning(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExpressionWarning() {
      fieldRef_ = "";
      warning_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ExpressionWarning(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              fieldRef_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              warning_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.class, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder.class);
    }

    private int bitField0_;
    public static final int FIELDREF_FIELD_NUMBER = 2;
    private volatile java.lang.Object fieldRef_;
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    public boolean hasFieldRef() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    public java.lang.String getFieldRef() {
      java.lang.Object ref = fieldRef_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          fieldRef_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The path to the field that refers the expression.
     * For example, the reference to the expression of the first item of
     * validations is "spec.validations[0].expression"
     * </pre>
     *
     * <code>optional string fieldRef = 2;</code>
     */
    public com.google.protobuf.ByteString
        getFieldRefBytes() {
      java.lang.Object ref = fieldRef_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        fieldRef_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WARNING_FIELD_NUMBER = 3;
    private volatile java.lang.Object warning_;
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    public boolean hasWarning() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    public java.lang.String getWarning() {
      java.lang.Object ref = warning_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          warning_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The content of type checking information in a human-readable form.
     * Each line of the warning contains the type that the expression is checked
     * against, followed by the type check error from the compiler.
     * </pre>
     *
     * <code>optional string warning = 3;</code>
     */
    public com.google.protobuf.ByteString
        getWarningBytes() {
      java.lang.Object ref = warning_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        warning_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, fieldRef_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, warning_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, fieldRef_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, warning_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning other = (io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning) obj;

      boolean result = true;
      result = result && (hasFieldRef() == other.hasFieldRef());
      if (hasFieldRef()) {
        result = result && getFieldRef()
            .equals(other.getFieldRef());
      }
      result = result && (hasWarning() == other.hasWarning());
      if (hasWarning()) {
        result = result && getWarning()
            .equals(other.getWarning());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasFieldRef()) {
        hash = (37 * hash) + FIELDREF_FIELD_NUMBER;
        hash = (53 * hash) + getFieldRef().hashCode();
      }
      if (hasWarning()) {
        hash = (37 * hash) + WARNING_FIELD_NUMBER;
        hash = (53 * hash) + getWarning().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ExpressionWarning is a warning information that targets a specific expression.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ExpressionWarning}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ExpressionWarning)
        io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.class, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        fieldRef_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        warning_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning build() {
        io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning result = new io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.fieldRef_ = fieldRef_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.warning_ = warning_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.getDefaultInstance()) return this;
        if (other.hasFieldRef()) {
          bitField0_ |= 0x00000001;
          fieldRef_ = other.fieldRef_;
          onChanged();
        }
        if (other.hasWarning()) {
          bitField0_ |= 0x00000002;
          warning_ = other.warning_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object fieldRef_ = "";
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public boolean hasFieldRef() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public java.lang.String getFieldRef() {
        java.lang.Object ref = fieldRef_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            fieldRef_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public com.google.protobuf.ByteString
          getFieldRefBytes() {
        java.lang.Object ref = fieldRef_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fieldRef_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public Builder setFieldRef(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        fieldRef_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public Builder clearFieldRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        fieldRef_ = getDefaultInstance().getFieldRef();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to the field that refers the expression.
       * For example, the reference to the expression of the first item of
       * validations is "spec.validations[0].expression"
       * </pre>
       *
       * <code>optional string fieldRef = 2;</code>
       */
      public Builder setFieldRefBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        fieldRef_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object warning_ = "";
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public boolean hasWarning() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public java.lang.String getWarning() {
        java.lang.Object ref = warning_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            warning_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public com.google.protobuf.ByteString
          getWarningBytes() {
        java.lang.Object ref = warning_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          warning_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public Builder setWarning(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        warning_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public Builder clearWarning() {
        bitField0_ = (bitField0_ & ~0x00000002);
        warning_ = getDefaultInstance().getWarning();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The content of type checking information in a human-readable form.
       * Each line of the warning contains the type that the expression is checked
       * against, followed by the type check error from the compiler.
       * </pre>
       *
       * <code>optional string warning = 3;</code>
       */
      public Builder setWarningBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        warning_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ExpressionWarning)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ExpressionWarning)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ExpressionWarning>
        PARSER = new com.google.protobuf.AbstractParser<ExpressionWarning>() {
      @java.lang.Override
      public ExpressionWarning parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ExpressionWarning(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExpressionWarning> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExpressionWarning> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MatchConditionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.MatchCondition)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.MatchCondition}
   */
  public  static final class MatchCondition extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.MatchCondition)
      MatchConditionOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MatchCondition.newBuilder() to construct.
    private MatchCondition(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MatchCondition() {
      name_ = "";
      expression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MatchCondition(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              expression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.class, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
     * as well as providing an identifier for logging purposes. A good name should be descriptive of
     * the associated expression.
     * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
     * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
     * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
     * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPRESSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
     * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
     * 'object' - The object from the incoming request. The value is null for DELETE requests.
     * 'oldObject' - The existing object. The value is null for CREATE requests.
     * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
     * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
     * Required.
     * </pre>
     *
     * <code>optional string expression = 2;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, expression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, expression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.MatchCondition)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.MatchCondition other = (io.kubernetes.client.proto.V1Admissionregistration.MatchCondition) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.MatchCondition}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.MatchCondition)
        io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.class, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition build() {
        io.kubernetes.client.proto.V1Admissionregistration.MatchCondition result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.MatchCondition result = new io.kubernetes.client.proto.V1Admissionregistration.MatchCondition(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.expression_ = expression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.MatchCondition) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.MatchCondition)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasExpression()) {
          bitField0_ |= 0x00000002;
          expression_ = other.expression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.MatchCondition parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.MatchCondition) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
       * as well as providing an identifier for logging purposes. A good name should be descriptive of
       * the associated expression.
       * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
       * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
       * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
       * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000002);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
       * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
       * 'object' - The object from the incoming request. The value is null for DELETE requests.
       * 'oldObject' - The existing object. The value is null for CREATE requests.
       * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
       * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
       * Required.
       * </pre>
       *
       * <code>optional string expression = 2;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.MatchCondition)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.MatchCondition)
    private static final io.kubernetes.client.proto.V1Admissionregistration.MatchCondition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.MatchCondition();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MatchCondition>
        PARSER = new com.google.protobuf.AbstractParser<MatchCondition>() {
      @java.lang.Override
      public MatchCondition parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MatchCondition(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MatchCondition> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MatchCondition> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MatchResourcesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.MatchResources)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> 
        getResourceRulesList();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getResourceRules(int index);
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    int getResourceRulesCount();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getResourceRulesOrBuilderList();
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
        int index);

    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> 
        getExcludeResourceRulesList();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index);
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    int getExcludeResourceRulesCount();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getExcludeResourceRulesOrBuilderList();
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
        int index);

    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();
  }
  /**
   * <pre>
   * MatchResources decides whether to run the admission control policy on an object based
   * on whether it meets the match criteria.
   * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.MatchResources}
   */
  public  static final class MatchResources extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.MatchResources)
      MatchResourcesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MatchResources.newBuilder() to construct.
    private MatchResources(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MatchResources() {
      resourceRules_ = java.util.Collections.emptyList();
      excludeResourceRules_ = java.util.Collections.emptyList();
      matchPolicy_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MatchResources(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = namespaceSelector_.toBuilder();
              }
              namespaceSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(namespaceSelector_);
                namespaceSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = objectSelector_.toBuilder();
              }
              objectSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectSelector_);
                objectSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                resourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations>();
                mutable_bitField0_ |= 0x00000004;
              }
              resourceRules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                excludeResourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations>();
                mutable_bitField0_ |= 0x00000008;
              }
              excludeResourceRules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              matchPolicy_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          resourceRules_ = java.util.Collections.unmodifiableList(resourceRules_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          excludeResourceRules_ = java.util.Collections.unmodifiableList(excludeResourceRules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchResources_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchResources_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.class, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder.class);
    }

    private int bitField0_;
    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the admission control policy on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the policy.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the policy on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the validation based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the cel validation, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int RESOURCERULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> resourceRules_;
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> getResourceRulesList() {
      return resourceRules_;
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getResourceRulesOrBuilderList() {
      return resourceRules_;
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public int getResourceRulesCount() {
      return resourceRules_.size();
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getResourceRules(int index) {
      return resourceRules_.get(index);
    }
    /**
     * <pre>
     * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
     * The policy cares about an operation if it matches _any_ Rule.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
        int index) {
      return resourceRules_.get(index);
    }

    public static final int EXCLUDERESOURCERULES_FIELD_NUMBER = 4;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> excludeResourceRules_;
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> getExcludeResourceRulesList() {
      return excludeResourceRules_;
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
        getExcludeResourceRulesOrBuilderList() {
      return excludeResourceRules_;
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public int getExcludeResourceRulesCount() {
      return excludeResourceRules_.size();
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index) {
      return excludeResourceRules_.get(index);
    }
    /**
     * <pre>
     * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
        int index) {
      return excludeResourceRules_.get(index);
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 7;
    private volatile java.lang.Object matchPolicy_;
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 7;</code>
     */
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getObjectSelector());
      }
      for (int i = 0; i < resourceRules_.size(); i++) {
        output.writeMessage(3, resourceRules_.get(i));
      }
      for (int i = 0; i < excludeResourceRules_.size(); i++) {
        output.writeMessage(4, excludeResourceRules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, matchPolicy_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getObjectSelector());
      }
      for (int i = 0; i < resourceRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, resourceRules_.get(i));
      }
      for (int i = 0; i < excludeResourceRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, excludeResourceRules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, matchPolicy_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.MatchResources)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.MatchResources other = (io.kubernetes.client.proto.V1Admissionregistration.MatchResources) obj;

      boolean result = true;
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector()
            .equals(other.getNamespaceSelector());
      }
      result = result && (hasObjectSelector() == other.hasObjectSelector());
      if (hasObjectSelector()) {
        result = result && getObjectSelector()
            .equals(other.getObjectSelector());
      }
      result = result && getResourceRulesList()
          .equals(other.getResourceRulesList());
      result = result && getExcludeResourceRulesList()
          .equals(other.getExcludeResourceRulesList());
      result = result && (hasMatchPolicy() == other.hasMatchPolicy());
      if (hasMatchPolicy()) {
        result = result && getMatchPolicy()
            .equals(other.getMatchPolicy());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (getResourceRulesCount() > 0) {
        hash = (37 * hash) + RESOURCERULES_FIELD_NUMBER;
        hash = (53 * hash) + getResourceRulesList().hashCode();
      }
      if (getExcludeResourceRulesCount() > 0) {
        hash = (37 * hash) + EXCLUDERESOURCERULES_FIELD_NUMBER;
        hash = (53 * hash) + getExcludeResourceRulesList().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.MatchResources prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MatchResources decides whether to run the admission control policy on an object based
     * on whether it meets the match criteria.
     * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.MatchResources}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.MatchResources)
        io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchResources_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchResources_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.MatchResources.class, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.MatchResources.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getResourceRulesFieldBuilder();
          getExcludeResourceRulesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (resourceRulesBuilder_ == null) {
          resourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          resourceRulesBuilder_.clear();
        }
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          excludeResourceRulesBuilder_.clear();
        }
        matchPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MatchResources_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources build() {
        io.kubernetes.client.proto.V1Admissionregistration.MatchResources result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.MatchResources result = new io.kubernetes.client.proto.V1Admissionregistration.MatchResources(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (objectSelectorBuilder_ == null) {
          result.objectSelector_ = objectSelector_;
        } else {
          result.objectSelector_ = objectSelectorBuilder_.build();
        }
        if (resourceRulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            resourceRules_ = java.util.Collections.unmodifiableList(resourceRules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.resourceRules_ = resourceRules_;
        } else {
          result.resourceRules_ = resourceRulesBuilder_.build();
        }
        if (excludeResourceRulesBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            excludeResourceRules_ = java.util.Collections.unmodifiableList(excludeResourceRules_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.excludeResourceRules_ = excludeResourceRules_;
        } else {
          result.excludeResourceRules_ = excludeResourceRulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000004;
        }
        result.matchPolicy_ = matchPolicy_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.MatchResources) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.MatchResources)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.MatchResources other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance()) return this;
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (resourceRulesBuilder_ == null) {
          if (!other.resourceRules_.isEmpty()) {
            if (resourceRules_.isEmpty()) {
              resourceRules_ = other.resourceRules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureResourceRulesIsMutable();
              resourceRules_.addAll(other.resourceRules_);
            }
            onChanged();
          }
        } else {
          if (!other.resourceRules_.isEmpty()) {
            if (resourceRulesBuilder_.isEmpty()) {
              resourceRulesBuilder_.dispose();
              resourceRulesBuilder_ = null;
              resourceRules_ = other.resourceRules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              resourceRulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getResourceRulesFieldBuilder() : null;
            } else {
              resourceRulesBuilder_.addAllMessages(other.resourceRules_);
            }
          }
        }
        if (excludeResourceRulesBuilder_ == null) {
          if (!other.excludeResourceRules_.isEmpty()) {
            if (excludeResourceRules_.isEmpty()) {
              excludeResourceRules_ = other.excludeResourceRules_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureExcludeResourceRulesIsMutable();
              excludeResourceRules_.addAll(other.excludeResourceRules_);
            }
            onChanged();
          }
        } else {
          if (!other.excludeResourceRules_.isEmpty()) {
            if (excludeResourceRulesBuilder_.isEmpty()) {
              excludeResourceRulesBuilder_.dispose();
              excludeResourceRulesBuilder_ = null;
              excludeResourceRules_ = other.excludeResourceRules_;
              bitField0_ = (bitField0_ & ~0x00000008);
              excludeResourceRulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExcludeResourceRulesFieldBuilder() : null;
            } else {
              excludeResourceRulesBuilder_.addAllMessages(other.excludeResourceRules_);
            }
          }
        }
        if (other.hasMatchPolicy()) {
          bitField0_ |= 0x00000010;
          matchPolicy_ = other.matchPolicy_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.MatchResources parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.MatchResources) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              namespaceSelector_ != null &&
              namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_).mergeFrom(value).buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the admission control policy on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the policy.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the policy on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              objectSelector_ != null &&
              objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            objectSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(objectSelector_).mergeFrom(value).buildPartial();
          } else {
            objectSelector_ = value;
          }
          onChanged();
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public Builder clearObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
          onChanged();
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the validation based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the cel validation, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> resourceRules_ =
        java.util.Collections.emptyList();
      private void ensureResourceRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          resourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations>(resourceRules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> resourceRulesBuilder_;

      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> getResourceRulesList() {
        if (resourceRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(resourceRules_);
        } else {
          return resourceRulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public int getResourceRulesCount() {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.size();
        } else {
          return resourceRulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getResourceRules(int index) {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.get(index);
        } else {
          return resourceRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder setResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.set(index, value);
          onChanged();
        } else {
          resourceRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder setResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.add(value);
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations value) {
        if (resourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureResourceRulesIsMutable();
          resourceRules_.add(index, value);
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.add(builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          resourceRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder addAllResourceRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> values) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, resourceRules_);
          onChanged();
        } else {
          resourceRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder clearResourceRules() {
        if (resourceRulesBuilder_ == null) {
          resourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          resourceRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public Builder removeResourceRules(int index) {
        if (resourceRulesBuilder_ == null) {
          ensureResourceRulesIsMutable();
          resourceRules_.remove(index);
          onChanged();
        } else {
          resourceRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder getResourceRulesBuilder(
          int index) {
        return getResourceRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder getResourceRulesOrBuilder(
          int index) {
        if (resourceRulesBuilder_ == null) {
          return resourceRules_.get(index);  } else {
          return resourceRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
           getResourceRulesOrBuilderList() {
        if (resourceRulesBuilder_ != null) {
          return resourceRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(resourceRules_);
        }
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder addResourceRulesBuilder() {
        return getResourceRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder addResourceRulesBuilder(
          int index) {
        return getResourceRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
       * The policy cares about an operation if it matches _any_ Rule.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder> 
           getResourceRulesBuilderList() {
        return getResourceRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
          getResourceRulesFieldBuilder() {
        if (resourceRulesBuilder_ == null) {
          resourceRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder>(
                  resourceRules_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          resourceRules_ = null;
        }
        return resourceRulesBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> excludeResourceRules_ =
        java.util.Collections.emptyList();
      private void ensureExcludeResourceRulesIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          excludeResourceRules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations>(excludeResourceRules_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> excludeResourceRulesBuilder_;

      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> getExcludeResourceRulesList() {
        if (excludeResourceRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(excludeResourceRules_);
        } else {
          return excludeResourceRulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public int getExcludeResourceRulesCount() {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.size();
        } else {
          return excludeResourceRulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getExcludeResourceRules(int index) {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.get(index);
        } else {
          return excludeResourceRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder setExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.set(index, value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder setExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations value) {
        if (excludeResourceRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(index, value);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addExcludeResourceRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder builderForValue) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder addAllExcludeResourceRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations> values) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, excludeResourceRules_);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder clearExcludeResourceRules() {
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public Builder removeExcludeResourceRules(int index) {
        if (excludeResourceRulesBuilder_ == null) {
          ensureExcludeResourceRulesIsMutable();
          excludeResourceRules_.remove(index);
          onChanged();
        } else {
          excludeResourceRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder getExcludeResourceRulesBuilder(
          int index) {
        return getExcludeResourceRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder getExcludeResourceRulesOrBuilder(
          int index) {
        if (excludeResourceRulesBuilder_ == null) {
          return excludeResourceRules_.get(index);  } else {
          return excludeResourceRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
           getExcludeResourceRulesOrBuilderList() {
        if (excludeResourceRulesBuilder_ != null) {
          return excludeResourceRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(excludeResourceRules_);
        }
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder addExcludeResourceRulesBuilder() {
        return getExcludeResourceRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder addExcludeResourceRulesBuilder(
          int index) {
        return getExcludeResourceRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
       * The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder> 
           getExcludeResourceRulesBuilderList() {
        return getExcludeResourceRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder> 
          getExcludeResourceRulesFieldBuilder() {
        if (excludeResourceRulesBuilder_ == null) {
          excludeResourceRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder>(
                  excludeResourceRules_,
                  ((bitField0_ & 0x00000008) == 0x00000008),
                  getParentForChildren(),
                  isClean());
          excludeResourceRules_ = null;
        }
        return excludeResourceRulesBuilder_;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public Builder clearMatchPolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "MatchResources" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 7;</code>
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.MatchResources)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.MatchResources)
    private static final io.kubernetes.client.proto.V1Admissionregistration.MatchResources DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.MatchResources();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MatchResources getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MatchResources>
        PARSER = new com.google.protobuf.AbstractParser<MatchResources>() {
      @java.lang.Override
      public MatchResources parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MatchResources(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MatchResources> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MatchResources> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.MatchResources getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.MutatingWebhook)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    boolean hasClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder();

    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> 
        getRulesList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index);
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();

    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    boolean hasSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    java.lang.String getSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    com.google.protobuf.ByteString
        getSideEffectsBytes();

    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    int getTimeoutSeconds();

    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.util.List<java.lang.String>
        getAdmissionReviewVersionsList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    int getAdmissionReviewVersionsCount();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.lang.String getAdmissionReviewVersions(int index);
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index);

    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    boolean hasReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    java.lang.String getReinvocationPolicy();
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    com.google.protobuf.ByteString
        getReinvocationPolicyBytes();

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhook describes an admission webhook and the resources and operations it applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.MutatingWebhook}
   */
  public  static final class MutatingWebhook extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.MutatingWebhook)
      MutatingWebhookOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingWebhook.newBuilder() to construct.
    private MutatingWebhook(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhook() {
      name_ = "";
      rules_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchPolicy_ = "";
      sideEffects_ = "";
      timeoutSeconds_ = 0;
      admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      reinvocationPolicy_ = "";
      matchConditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingWebhook(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = clientConfig_.toBuilder();
              }
              clientConfig_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(clientConfig_);
                clientConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>();
                mutable_bitField0_ |= 0x00000004;
              }
              rules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 42: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = namespaceSelector_.toBuilder();
              }
              namespaceSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(namespaceSelector_);
                namespaceSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              sideEffects_ = bs;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000080;
              timeoutSeconds_ = input.readInt32();
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000200;
              }
              admissionReviewVersions_.add(bs);
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              matchPolicy_ = bs;
              break;
            }
            case 82: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000100;
              reinvocationPolicy_ = bs;
              break;
            }
            case 90: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = objectSelector_.toBuilder();
              }
              objectSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectSelector_);
                objectSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 98: {
              if (!((mutable_bitField0_ & 0x00000800) == 0x00000800)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000800;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000800) == 0x00000800)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.class, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CLIENTCONFIG_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig clientConfig_;
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    public boolean hasClientConfig() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getClientConfig() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }

    public static final int RULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_;
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 9;
    private volatile java.lang.Object matchPolicy_;
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 11;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int SIDEEFFECTS_FIELD_NUMBER = 6;
    private volatile java.lang.Object sideEffects_;
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public boolean hasSideEffects() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public java.lang.String getSideEffects() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sideEffects_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public com.google.protobuf.ByteString
        getSideEffectsBytes() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sideEffects_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 7;
    private int timeoutSeconds_;
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public int getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int ADMISSIONREVIEWVERSIONS_FIELD_NUMBER = 8;
    private com.google.protobuf.LazyStringList admissionReviewVersions_;
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getAdmissionReviewVersionsList() {
      return admissionReviewVersions_;
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public int getAdmissionReviewVersionsCount() {
      return admissionReviewVersions_.size();
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public java.lang.String getAdmissionReviewVersions(int index) {
      return admissionReviewVersions_.get(index);
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index) {
      return admissionReviewVersions_.getByteString(index);
    }

    public static final int REINVOCATIONPOLICY_FIELD_NUMBER = 10;
    private volatile java.lang.Object reinvocationPolicy_;
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    public boolean hasReinvocationPolicy() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    public java.lang.String getReinvocationPolicy() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reinvocationPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
     * Allowed values are "Never" and "IfNeeded".
     * Never: the webhook will not be called more than once in a single admission evaluation.
     * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
     * if the object being admitted is modified by other admission plugins after the initial webhook call.
     * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
     * Note:
     * * the number of additional invocations is not guaranteed to be exactly one.
     * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
     * * webhooks that use this option may be reordered to minimize the number of additional invocations.
     * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
     * Defaults to "Never".
     * +optional
     * </pre>
     *
     * <code>optional string reinvocationPolicy = 10;</code>
     */
    public com.google.protobuf.ByteString
        getReinvocationPolicyBytes() {
      java.lang.Object ref = reinvocationPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reinvocationPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 12;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(7, timeoutSeconds_);
      }
      for (int i = 0; i < admissionReviewVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, admissionReviewVersions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, reinvocationPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(11, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(12, matchConditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, timeoutSeconds_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < admissionReviewVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(admissionReviewVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAdmissionReviewVersionsList().size();
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, reinvocationPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, matchConditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook other = (io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasClientConfig() == other.hasClientConfig());
      if (hasClientConfig()) {
        result = result && getClientConfig()
            .equals(other.getClientConfig());
      }
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && (hasMatchPolicy() == other.hasMatchPolicy());
      if (hasMatchPolicy()) {
        result = result && getMatchPolicy()
            .equals(other.getMatchPolicy());
      }
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector()
            .equals(other.getNamespaceSelector());
      }
      result = result && (hasObjectSelector() == other.hasObjectSelector());
      if (hasObjectSelector()) {
        result = result && getObjectSelector()
            .equals(other.getObjectSelector());
      }
      result = result && (hasSideEffects() == other.hasSideEffects());
      if (hasSideEffects()) {
        result = result && getSideEffects()
            .equals(other.getSideEffects());
      }
      result = result && (hasTimeoutSeconds() == other.hasTimeoutSeconds());
      if (hasTimeoutSeconds()) {
        result = result && (getTimeoutSeconds()
            == other.getTimeoutSeconds());
      }
      result = result && getAdmissionReviewVersionsList()
          .equals(other.getAdmissionReviewVersionsList());
      result = result && (hasReinvocationPolicy() == other.hasReinvocationPolicy());
      if (hasReinvocationPolicy()) {
        result = result && getReinvocationPolicy()
            .equals(other.getReinvocationPolicy());
      }
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasClientConfig()) {
        hash = (37 * hash) + CLIENTCONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getClientConfig().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (hasSideEffects()) {
        hash = (37 * hash) + SIDEEFFECTS_FIELD_NUMBER;
        hash = (53 * hash) + getSideEffects().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getTimeoutSeconds();
      }
      if (getAdmissionReviewVersionsCount() > 0) {
        hash = (37 * hash) + ADMISSIONREVIEWVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAdmissionReviewVersionsList().hashCode();
      }
      if (hasReinvocationPolicy()) {
        hash = (37 * hash) + REINVOCATIONPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getReinvocationPolicy().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhook describes an admission webhook and the resources and operations it applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.MutatingWebhook}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.MutatingWebhook)
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.class, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getClientConfigFieldBuilder();
          getRulesFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          rulesBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        matchPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        sideEffects_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        timeoutSeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        reinvocationPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000400);
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook build() {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook result = new io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (clientConfigBuilder_ == null) {
          result.clientConfig_ = clientConfig_;
        } else {
          result.clientConfig_ = clientConfigBuilder_.build();
        }
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000008;
        }
        result.matchPolicy_ = matchPolicy_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000020;
        }
        if (objectSelectorBuilder_ == null) {
          result.objectSelector_ = objectSelector_;
        } else {
          result.objectSelector_ = objectSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sideEffects_ = sideEffects_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000080;
        }
        result.timeoutSeconds_ = timeoutSeconds_;
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.admissionReviewVersions_ = admissionReviewVersions_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000100;
        }
        result.reinvocationPolicy_ = reinvocationPolicy_;
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000800) == 0x00000800)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000800);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasClientConfig()) {
          mergeClientConfig(other.getClientConfig());
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000008;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (other.hasMatchPolicy()) {
          bitField0_ |= 0x00000010;
          matchPolicy_ = other.matchPolicy_;
          onChanged();
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (other.hasSideEffects()) {
          bitField0_ |= 0x00000080;
          sideEffects_ = other.sideEffects_;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (!other.admissionReviewVersions_.isEmpty()) {
          if (admissionReviewVersions_.isEmpty()) {
            admissionReviewVersions_ = other.admissionReviewVersions_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureAdmissionReviewVersionsIsMutable();
            admissionReviewVersions_.addAll(other.admissionReviewVersions_);
          }
          onChanged();
        }
        if (other.hasReinvocationPolicy()) {
          bitField0_ |= 0x00000400;
          reinvocationPolicy_ = other.reinvocationPolicy_;
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000800);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000800);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig clientConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder> clientConfigBuilder_;
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public boolean hasClientConfig() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getClientConfig() {
        if (clientConfigBuilder_ == null) {
          return clientConfig_ == null ? io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        } else {
          return clientConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientConfig_ = value;
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(
          io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder builderForValue) {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = builderForValue.build();
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder mergeClientConfig(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              clientConfig_ != null &&
              clientConfig_ != io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance()) {
            clientConfig_ =
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.newBuilder(clientConfig_).mergeFrom(value).buildPartial();
          } else {
            clientConfig_ = value;
          }
          onChanged();
        } else {
          clientConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder clearClientConfig() {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
          onChanged();
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder getClientConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getClientConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
        if (clientConfigBuilder_ != null) {
          return clientConfigBuilder_.getMessageOrBuilder();
        } else {
          return clientConfig_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder> 
          getClientConfigFieldBuilder() {
        if (clientConfigBuilder_ == null) {
          clientConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder>(
                  getClientConfig(),
                  getParentForChildren(),
                  isClean());
          clientConfig_ = null;
        }
        return clientConfigBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>(rules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder clearMatchPolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020) &&
              namespaceSelector_ != null &&
              namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_).mergeFrom(value).buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040) &&
              objectSelector_ != null &&
              objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            objectSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(objectSelector_).mergeFrom(value).buildPartial();
          } else {
            objectSelector_ = value;
          }
          onChanged();
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public Builder clearObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
          onChanged();
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.lang.Object sideEffects_ = "";
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public boolean hasSideEffects() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public java.lang.String getSideEffects() {
        java.lang.Object ref = sideEffects_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sideEffects_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public com.google.protobuf.ByteString
          getSideEffectsBytes() {
        java.lang.Object ref = sideEffects_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sideEffects_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffects(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder clearSideEffects() {
        bitField0_ = (bitField0_ & ~0x00000080);
        sideEffects_ = getDefaultInstance().getSideEffects();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffectsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }

      private int timeoutSeconds_ ;
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public int getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder setTimeoutSeconds(int value) {
        bitField0_ |= 0x00000100;
        timeoutSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        timeoutSeconds_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAdmissionReviewVersionsIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList(admissionReviewVersions_);
          bitField0_ |= 0x00000200;
         }
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getAdmissionReviewVersionsList() {
        return admissionReviewVersions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public int getAdmissionReviewVersionsCount() {
        return admissionReviewVersions_.size();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public java.lang.String getAdmissionReviewVersions(int index) {
        return admissionReviewVersions_.get(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ByteString
          getAdmissionReviewVersionsBytes(int index) {
        return admissionReviewVersions_.getByteString(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder setAdmissionReviewVersions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAllAdmissionReviewVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureAdmissionReviewVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, admissionReviewVersions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder clearAdmissionReviewVersions() {
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }

      private java.lang.Object reinvocationPolicy_ = "";
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public boolean hasReinvocationPolicy() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public java.lang.String getReinvocationPolicy() {
        java.lang.Object ref = reinvocationPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reinvocationPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public com.google.protobuf.ByteString
          getReinvocationPolicyBytes() {
        java.lang.Object ref = reinvocationPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reinvocationPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public Builder setReinvocationPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
        reinvocationPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public Builder clearReinvocationPolicy() {
        bitField0_ = (bitField0_ & ~0x00000400);
        reinvocationPolicy_ = getDefaultInstance().getReinvocationPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
       * Allowed values are "Never" and "IfNeeded".
       * Never: the webhook will not be called more than once in a single admission evaluation.
       * IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
       * if the object being admitted is modified by other admission plugins after the initial webhook call.
       * Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
       * Note:
       * * the number of additional invocations is not guaranteed to be exactly one.
       * * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
       * * webhooks that use this option may be reordered to minimize the number of additional invocations.
       * * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
       * Defaults to "Never".
       * +optional
       * </pre>
       *
       * <code>optional string reinvocationPolicy = 10;</code>
       */
      public Builder setReinvocationPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
        reinvocationPolicy_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000800) == 0x00000800)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000800;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 12;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000800) == 0x00000800),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.MutatingWebhook)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.MutatingWebhook)
    private static final io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingWebhook>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhook>() {
      @java.lang.Override
      public MutatingWebhook parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingWebhook(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhook> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhook> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook> 
        getWebhooksList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook getWebhooks(int index);
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    int getWebhooksCount();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder> 
        getWebhooksOrBuilderList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration}
   */
  public  static final class MutatingWebhookConfiguration extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration)
      MutatingWebhookConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingWebhookConfiguration.newBuilder() to construct.
    private MutatingWebhookConfiguration(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhookConfiguration() {
      webhooks_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingWebhookConfiguration(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook>();
                mutable_bitField0_ |= 0x00000002;
              }
              webhooks_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.class, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int WEBHOOKS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook> webhooks_;
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook> getWebhooksList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder> 
        getWebhooksOrBuilderList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    public int getWebhooksCount() {
      return webhooks_.size();
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook getWebhooks(int index) {
      return webhooks_.get(index);
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
        int index) {
      return webhooks_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        output.writeMessage(2, webhooks_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, webhooks_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration other = (io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getWebhooksList()
          .equals(other.getWebhooksList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getWebhooksCount() > 0) {
        hash = (37 * hash) + WEBHOOKS_FIELD_NUMBER;
        hash = (53 * hash) + getWebhooksList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration)
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.class, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getWebhooksFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration build() {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration result = new io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (webhooksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.webhooks_ = webhooks_;
        } else {
          result.webhooks_ = webhooksBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (webhooksBuilder_ == null) {
          if (!other.webhooks_.isEmpty()) {
            if (webhooks_.isEmpty()) {
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureWebhooksIsMutable();
              webhooks_.addAll(other.webhooks_);
            }
            onChanged();
          }
        } else {
          if (!other.webhooks_.isEmpty()) {
            if (webhooksBuilder_.isEmpty()) {
              webhooksBuilder_.dispose();
              webhooksBuilder_ = null;
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              webhooksBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getWebhooksFieldBuilder() : null;
            } else {
              webhooksBuilder_.addAllMessages(other.webhooks_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook> webhooks_ =
        java.util.Collections.emptyList();
      private void ensureWebhooksIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook>(webhooks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder> webhooksBuilder_;

      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook> getWebhooksList() {
        if (webhooksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(webhooks_);
        } else {
          return webhooksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public int getWebhooksCount() {
        if (webhooksBuilder_ == null) {
          return webhooks_.size();
        } else {
          return webhooksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook getWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);
        } else {
          return webhooksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.set(index, value);
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.set(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(index, value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder addAllWebhooks(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook> values) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, webhooks_);
          onChanged();
        } else {
          webhooksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder clearWebhooks() {
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public Builder removeWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.remove(index);
          onChanged();
        } else {
          webhooksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder getWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder getWebhooksOrBuilder(
          int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);  } else {
          return webhooksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder> 
           getWebhooksOrBuilderList() {
        if (webhooksBuilder_ != null) {
          return webhooksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(webhooks_);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder addWebhooksBuilder() {
        return getWebhooksFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder addWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder> 
           getWebhooksBuilderList() {
        return getWebhooksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder> 
          getWebhooksFieldBuilder() {
        if (webhooksBuilder_ == null) {
          webhooksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhook.Builder, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookOrBuilder>(
                  webhooks_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          webhooks_ = null;
        }
        return webhooksBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration)
    private static final io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingWebhookConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhookConfiguration>() {
      @java.lang.Override
      public MutatingWebhookConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingWebhookConfiguration(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhookConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhookConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MutatingWebhookConfigurationListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration> 
        getItemsList();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration getItems(int index);
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList}
   */
  public  static final class MutatingWebhookConfigurationList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList)
      MutatingWebhookConfigurationListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MutatingWebhookConfigurationList.newBuilder() to construct.
    private MutatingWebhookConfigurationList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MutatingWebhookConfigurationList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MutatingWebhookConfigurationList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration> items_;
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of MutatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList other = (io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList)
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList build() {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList result = new io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of MutatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.MutatingWebhookConfigurationList)
    private static final io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<MutatingWebhookConfigurationList>
        PARSER = new com.google.protobuf.AbstractParser<MutatingWebhookConfigurationList>() {
      @java.lang.Override
      public MutatingWebhookConfigurationList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new MutatingWebhookConfigurationList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MutatingWebhookConfigurationList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MutatingWebhookConfigurationList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.MutatingWebhookConfigurationList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NamedRuleWithOperationsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.NamedRuleWithOperations)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    java.util.List<java.lang.String>
        getResourceNamesList();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    int getResourceNamesCount();
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    java.lang.String getResourceNames(int index);
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    com.google.protobuf.ByteString
        getResourceNamesBytes(int index);

    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    boolean hasRuleWithOperations();
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations();
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder();
  }
  /**
   * <pre>
   * NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.NamedRuleWithOperations}
   */
  public  static final class NamedRuleWithOperations extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.NamedRuleWithOperations)
      NamedRuleWithOperationsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NamedRuleWithOperations.newBuilder() to construct.
    private NamedRuleWithOperations(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NamedRuleWithOperations() {
      resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NamedRuleWithOperations(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                resourceNames_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              resourceNames_.add(bs);
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = ruleWithOperations_.toBuilder();
              }
              ruleWithOperations_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ruleWithOperations_);
                ruleWithOperations_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          resourceNames_ = resourceNames_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.class, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder.class);
    }

    private int bitField0_;
    public static final int RESOURCENAMES_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList resourceNames_;
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getResourceNamesList() {
      return resourceNames_;
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public int getResourceNamesCount() {
      return resourceNames_.size();
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public java.lang.String getResourceNames(int index) {
      return resourceNames_.get(index);
    }
    /**
     * <pre>
     * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated string resourceNames = 1;</code>
     */
    public com.google.protobuf.ByteString
        getResourceNamesBytes(int index) {
      return resourceNames_.getByteString(index);
    }

    public static final int RULEWITHOPERATIONS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations ruleWithOperations_;
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    public boolean hasRuleWithOperations() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations() {
      return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder() {
      return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < resourceNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, resourceNames_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(2, getRuleWithOperations());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < resourceNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(resourceNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getResourceNamesList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRuleWithOperations());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations other = (io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations) obj;

      boolean result = true;
      result = result && getResourceNamesList()
          .equals(other.getResourceNamesList());
      result = result && (hasRuleWithOperations() == other.hasRuleWithOperations());
      if (hasRuleWithOperations()) {
        result = result && getRuleWithOperations()
            .equals(other.getRuleWithOperations());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getResourceNamesCount() > 0) {
        hash = (37 * hash) + RESOURCENAMES_FIELD_NUMBER;
        hash = (53 * hash) + getResourceNamesList().hashCode();
      }
      if (hasRuleWithOperations()) {
        hash = (37 * hash) + RULEWITHOPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getRuleWithOperations().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.NamedRuleWithOperations}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.NamedRuleWithOperations)
        io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperationsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.class, io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRuleWithOperationsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = null;
        } else {
          ruleWithOperationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations build() {
        io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations result = new io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          resourceNames_ = resourceNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.resourceNames_ = resourceNames_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        if (ruleWithOperationsBuilder_ == null) {
          result.ruleWithOperations_ = ruleWithOperations_;
        } else {
          result.ruleWithOperations_ = ruleWithOperationsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations.getDefaultInstance()) return this;
        if (!other.resourceNames_.isEmpty()) {
          if (resourceNames_.isEmpty()) {
            resourceNames_ = other.resourceNames_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureResourceNamesIsMutable();
            resourceNames_.addAll(other.resourceNames_);
          }
          onChanged();
        }
        if (other.hasRuleWithOperations()) {
          mergeRuleWithOperations(other.getRuleWithOperations());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureResourceNamesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          resourceNames_ = new com.google.protobuf.LazyStringArrayList(resourceNames_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getResourceNamesList() {
        return resourceNames_.getUnmodifiableView();
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public int getResourceNamesCount() {
        return resourceNames_.size();
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public java.lang.String getResourceNames(int index) {
        return resourceNames_.get(index);
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public com.google.protobuf.ByteString
          getResourceNamesBytes(int index) {
        return resourceNames_.getByteString(index);
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder setResourceNames(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourceNamesIsMutable();
        resourceNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder addResourceNames(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourceNamesIsMutable();
        resourceNames_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder addAllResourceNames(
          java.lang.Iterable<java.lang.String> values) {
        ensureResourceNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, resourceNames_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder clearResourceNames() {
        resourceNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated string resourceNames = 1;</code>
       */
      public Builder addResourceNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourceNamesIsMutable();
        resourceNames_.add(value);
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations ruleWithOperations_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> ruleWithOperationsBuilder_;
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public boolean hasRuleWithOperations() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRuleWithOperations() {
        if (ruleWithOperationsBuilder_ == null) {
          return ruleWithOperations_ == null ? io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
        } else {
          return ruleWithOperationsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder setRuleWithOperations(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (ruleWithOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ruleWithOperations_ = value;
          onChanged();
        } else {
          ruleWithOperationsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder setRuleWithOperations(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = builderForValue.build();
          onChanged();
        } else {
          ruleWithOperationsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder mergeRuleWithOperations(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (ruleWithOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              ruleWithOperations_ != null &&
              ruleWithOperations_ != io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance()) {
            ruleWithOperations_ =
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.newBuilder(ruleWithOperations_).mergeFrom(value).buildPartial();
          } else {
            ruleWithOperations_ = value;
          }
          onChanged();
        } else {
          ruleWithOperationsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public Builder clearRuleWithOperations() {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperations_ = null;
          onChanged();
        } else {
          ruleWithOperationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRuleWithOperationsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRuleWithOperationsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRuleWithOperationsOrBuilder() {
        if (ruleWithOperationsBuilder_ != null) {
          return ruleWithOperationsBuilder_.getMessageOrBuilder();
        } else {
          return ruleWithOperations_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance() : ruleWithOperations_;
        }
      }
      /**
       * <pre>
       * RuleWithOperations is a tuple of Operations and Resources.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRuleWithOperationsFieldBuilder() {
        if (ruleWithOperationsBuilder_ == null) {
          ruleWithOperationsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  getRuleWithOperations(),
                  getParentForChildren(),
                  isClean());
          ruleWithOperations_ = null;
        }
        return ruleWithOperationsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.NamedRuleWithOperations)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.NamedRuleWithOperations)
    private static final io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<NamedRuleWithOperations>
        PARSER = new com.google.protobuf.AbstractParser<NamedRuleWithOperations>() {
      @java.lang.Override
      public NamedRuleWithOperations parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NamedRuleWithOperations(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NamedRuleWithOperations> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NamedRuleWithOperations> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.NamedRuleWithOperations getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParamKindOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ParamKind)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    boolean hasApiVersion();
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    java.lang.String getApiVersion();
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    com.google.protobuf.ByteString
        getApiVersionBytes();

    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    boolean hasKind();
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    java.lang.String getKind();
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    com.google.protobuf.ByteString
        getKindBytes();
  }
  /**
   * <pre>
   * ParamKind is a tuple of Group Kind and Version.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ParamKind}
   */
  public  static final class ParamKind extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ParamKind)
      ParamKindOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ParamKind.newBuilder() to construct.
    private ParamKind(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ParamKind() {
      apiVersion_ = "";
      kind_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ParamKind(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              apiVersion_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              kind_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamKind_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamKind_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ParamKind.class, io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder.class);
    }

    private int bitField0_;
    public static final int APIVERSION_FIELD_NUMBER = 1;
    private volatile java.lang.Object apiVersion_;
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    public boolean hasApiVersion() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    public java.lang.String getApiVersion() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          apiVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * APIVersion is the API group version the resources belong to.
     * In format of "group/version".
     * Required.
     * </pre>
     *
     * <code>optional string apiVersion = 1;</code>
     */
    public com.google.protobuf.ByteString
        getApiVersionBytes() {
      java.lang.Object ref = apiVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        apiVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KIND_FIELD_NUMBER = 2;
    private volatile java.lang.Object kind_;
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    public boolean hasKind() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          kind_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Kind is the API kind the resources belong to.
     * Required.
     * </pre>
     *
     * <code>optional string kind = 2;</code>
     */
    public com.google.protobuf.ByteString
        getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, apiVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, kind_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, apiVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, kind_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ParamKind)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ParamKind other = (io.kubernetes.client.proto.V1Admissionregistration.ParamKind) obj;

      boolean result = true;
      result = result && (hasApiVersion() == other.hasApiVersion());
      if (hasApiVersion()) {
        result = result && getApiVersion()
            .equals(other.getApiVersion());
      }
      result = result && (hasKind() == other.hasKind());
      if (hasKind()) {
        result = result && getKind()
            .equals(other.getKind());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasApiVersion()) {
        hash = (37 * hash) + APIVERSION_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersion().hashCode();
      }
      if (hasKind()) {
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + getKind().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ParamKind prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ParamKind is a tuple of Group Kind and Version.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ParamKind}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ParamKind)
        io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamKind_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamKind_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ParamKind.class, io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ParamKind.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        apiVersion_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        kind_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamKind_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ParamKind getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ParamKind build() {
        io.kubernetes.client.proto.V1Admissionregistration.ParamKind result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ParamKind buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ParamKind result = new io.kubernetes.client.proto.V1Admissionregistration.ParamKind(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.apiVersion_ = apiVersion_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.kind_ = kind_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ParamKind) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ParamKind)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ParamKind other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance()) return this;
        if (other.hasApiVersion()) {
          bitField0_ |= 0x00000001;
          apiVersion_ = other.apiVersion_;
          onChanged();
        }
        if (other.hasKind()) {
          bitField0_ |= 0x00000002;
          kind_ = other.kind_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ParamKind parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ParamKind) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object apiVersion_ = "";
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public boolean hasApiVersion() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public java.lang.String getApiVersion() {
        java.lang.Object ref = apiVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            apiVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public com.google.protobuf.ByteString
          getApiVersionBytes() {
        java.lang.Object ref = apiVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          apiVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public Builder setApiVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        apiVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public Builder clearApiVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        apiVersion_ = getDefaultInstance().getApiVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersion is the API group version the resources belong to.
       * In format of "group/version".
       * Required.
       * </pre>
       *
       * <code>optional string apiVersion = 1;</code>
       */
      public Builder setApiVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        apiVersion_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object kind_ = "";
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public boolean hasKind() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public java.lang.String getKind() {
        java.lang.Object ref = kind_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            kind_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public com.google.protobuf.ByteString
          getKindBytes() {
        java.lang.Object ref = kind_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          kind_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public Builder setKind(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        kind_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public Builder clearKind() {
        bitField0_ = (bitField0_ & ~0x00000002);
        kind_ = getDefaultInstance().getKind();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kind is the API kind the resources belong to.
       * Required.
       * </pre>
       *
       * <code>optional string kind = 2;</code>
       */
      public Builder setKindBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        kind_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ParamKind)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ParamKind)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ParamKind DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ParamKind();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ParamKind getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ParamKind>
        PARSER = new com.google.protobuf.AbstractParser<ParamKind>() {
      @java.lang.Override
      public ParamKind parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ParamKind(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ParamKind> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParamKind> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ParamKind getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParamRefOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ParamRef)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    boolean hasNamespace();
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    boolean hasSelector();
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    boolean hasParameterNotFoundAction();
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    java.lang.String getParameterNotFoundAction();
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    com.google.protobuf.ByteString
        getParameterNotFoundActionBytes();
  }
  /**
   * <pre>
   * ParamRef describes how to locate the params to be used as input to
   * expressions of rules applied by a policy binding.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ParamRef}
   */
  public  static final class ParamRef extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ParamRef)
      ParamRefOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ParamRef.newBuilder() to construct.
    private ParamRef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ParamRef() {
      name_ = "";
      namespace_ = "";
      parameterNotFoundAction_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ParamRef(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              namespace_ = bs;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = selector_.toBuilder();
              }
              selector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(selector_);
                selector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              parameterNotFoundAction_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamRef_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamRef_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ParamRef.class, io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * name is the name of the resource being referenced.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * A single parameter used for all admission requests can be configured
     * by setting the `name` field, leaving `selector` blank, and setting namespace
     * if `paramKind` is namespace-scoped.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACE_FIELD_NUMBER = 2;
    private volatile java.lang.Object namespace_;
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * namespace is the namespace of the referenced resource. Allows limiting
     * the search for params to a specific namespace. Applies to both `name` and
     * `selector` fields.
     * A per-namespace parameter may be used by specifying a namespace-scoped
     * `paramKind` in the policy and leaving this field empty.
     * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
     * field results in a configuration error.
     * - If `paramKind` is namespace-scoped, the namespace of the object being
     * evaluated for admission will be used when this field is left unset. Take
     * care that if this is left empty the binding must not match any cluster-scoped
     * resources, which will result in an error.
     * +optional
     * </pre>
     *
     * <code>optional string namespace = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SELECTOR_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * selector can be used to match multiple param objects based on their labels.
     * Supply selector: {} to match all resources of the ParamKind.
     * If multiple params are found, they are all evaluated with the policy expressions
     * and the results are ANDed together.
     * One of `name` or `selector` must be set, but `name` and `selector` are
     * mutually exclusive properties. If one is set, the other must be unset.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int PARAMETERNOTFOUNDACTION_FIELD_NUMBER = 4;
    private volatile java.lang.Object parameterNotFoundAction_;
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    public boolean hasParameterNotFoundAction() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    public java.lang.String getParameterNotFoundAction() {
      java.lang.Object ref = parameterNotFoundAction_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          parameterNotFoundAction_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `parameterNotFoundAction` controls the behavior of the binding when the resource
     * exists, and name or selector is valid, but there are no parameters
     * matched by the binding. If the value is set to `Allow`, then no
     * matched parameters will be treated as successful validation by the binding.
     * If set to `Deny`, then no matched parameters will be subject to the
     * `failurePolicy` of the policy.
     * Allowed values are `Allow` or `Deny`
     * Required
     * </pre>
     *
     * <code>optional string parameterNotFoundAction = 4;</code>
     */
    public com.google.protobuf.ByteString
        getParameterNotFoundActionBytes() {
      java.lang.Object ref = parameterNotFoundAction_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        parameterNotFoundAction_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, namespace_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getSelector());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, parameterNotFoundAction_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, namespace_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getSelector());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, parameterNotFoundAction_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ParamRef)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ParamRef other = (io.kubernetes.client.proto.V1Admissionregistration.ParamRef) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasNamespace() == other.hasNamespace());
      if (hasNamespace()) {
        result = result && getNamespace()
            .equals(other.getNamespace());
      }
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector()
            .equals(other.getSelector());
      }
      result = result && (hasParameterNotFoundAction() == other.hasParameterNotFoundAction());
      if (hasParameterNotFoundAction()) {
        result = result && getParameterNotFoundAction()
            .equals(other.getParameterNotFoundAction());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasParameterNotFoundAction()) {
        hash = (37 * hash) + PARAMETERNOTFOUNDACTION_FIELD_NUMBER;
        hash = (53 * hash) + getParameterNotFoundAction().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ParamRef prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ParamRef describes how to locate the params to be used as input to
     * expressions of rules applied by a policy binding.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ParamRef}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ParamRef)
        io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamRef_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamRef_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ParamRef.class, io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ParamRef.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        namespace_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        parameterNotFoundAction_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ParamRef_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ParamRef getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ParamRef build() {
        io.kubernetes.client.proto.V1Admissionregistration.ParamRef result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ParamRef buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ParamRef result = new io.kubernetes.client.proto.V1Admissionregistration.ParamRef(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.namespace_ = namespace_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.parameterNotFoundAction_ = parameterNotFoundAction_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ParamRef) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ParamRef)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ParamRef other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasNamespace()) {
          bitField0_ |= 0x00000002;
          namespace_ = other.namespace_;
          onChanged();
        }
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasParameterNotFoundAction()) {
          bitField0_ |= 0x00000008;
          parameterNotFoundAction_ = other.parameterNotFoundAction_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ParamRef parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ParamRef) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the name of the resource being referenced.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * A single parameter used for all admission requests can be configured
       * by setting the `name` field, leaving `selector` blank, and setting namespace
       * if `paramKind` is namespace-scoped.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        namespace_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public Builder clearNamespace() {
        bitField0_ = (bitField0_ & ~0x00000002);
        namespace_ = getDefaultInstance().getNamespace();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace is the namespace of the referenced resource. Allows limiting
       * the search for params to a specific namespace. Applies to both `name` and
       * `selector` fields.
       * A per-namespace parameter may be used by specifying a namespace-scoped
       * `paramKind` in the policy and leaving this field empty.
       * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
       * field results in a configuration error.
       * - If `paramKind` is namespace-scoped, the namespace of the object being
       * evaluated for admission will be used when this field is left unset. Take
       * care that if this is left empty the binding must not match any cluster-scoped
       * resources, which will result in an error.
       * +optional
       * </pre>
       *
       * <code>optional string namespace = 2;</code>
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        namespace_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              selector_ != null &&
              selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_).mergeFrom(value).buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * selector can be used to match multiple param objects based on their labels.
       * Supply selector: {} to match all resources of the ParamKind.
       * If multiple params are found, they are all evaluated with the policy expressions
       * and the results are ANDed together.
       * One of `name` or `selector` must be set, but `name` and `selector` are
       * mutually exclusive properties. If one is set, the other must be unset.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private java.lang.Object parameterNotFoundAction_ = "";
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public boolean hasParameterNotFoundAction() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public java.lang.String getParameterNotFoundAction() {
        java.lang.Object ref = parameterNotFoundAction_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            parameterNotFoundAction_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public com.google.protobuf.ByteString
          getParameterNotFoundActionBytes() {
        java.lang.Object ref = parameterNotFoundAction_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          parameterNotFoundAction_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public Builder setParameterNotFoundAction(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        parameterNotFoundAction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public Builder clearParameterNotFoundAction() {
        bitField0_ = (bitField0_ & ~0x00000008);
        parameterNotFoundAction_ = getDefaultInstance().getParameterNotFoundAction();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `parameterNotFoundAction` controls the behavior of the binding when the resource
       * exists, and name or selector is valid, but there are no parameters
       * matched by the binding. If the value is set to `Allow`, then no
       * matched parameters will be treated as successful validation by the binding.
       * If set to `Deny`, then no matched parameters will be subject to the
       * `failurePolicy` of the policy.
       * Allowed values are `Allow` or `Deny`
       * Required
       * </pre>
       *
       * <code>optional string parameterNotFoundAction = 4;</code>
       */
      public Builder setParameterNotFoundActionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        parameterNotFoundAction_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ParamRef)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ParamRef)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ParamRef DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ParamRef();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ParamRef getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ParamRef>
        PARSER = new com.google.protobuf.AbstractParser<ParamRef>() {
      @java.lang.Override
      public ParamRef parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ParamRef(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ParamRef> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParamRef> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ParamRef getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RuleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.Rule)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    java.util.List<java.lang.String>
        getApiGroupsList();
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    int getApiGroupsCount();
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    java.lang.String getApiGroups(int index);
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    com.google.protobuf.ByteString
        getApiGroupsBytes(int index);

    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    java.util.List<java.lang.String>
        getApiVersionsList();
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    int getApiVersionsCount();
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    java.lang.String getApiVersions(int index);
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    com.google.protobuf.ByteString
        getApiVersionsBytes(int index);

    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    java.util.List<java.lang.String>
        getResourcesList();
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    int getResourcesCount();
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    java.lang.String getResources(int index);
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    com.google.protobuf.ByteString
        getResourcesBytes(int index);

    /**
     * <pre>
     * scope specifies the scope of this rule.
     * Valid values are "Cluster", "Namespaced", and "*"
     * "Cluster" means that only cluster-scoped resources will match this rule.
     * Namespace API objects are cluster-scoped.
     * "Namespaced" means that only namespaced resources will match this rule.
     * "*" means that there are no scope restrictions.
     * Subresources match the scope of their parent resource.
     * Default is "*".
     * +optional
     * </pre>
     *
     * <code>optional string scope = 4;</code>
     */
    boolean hasScope();
    /**
     * <pre>
     * scope specifies the scope of this rule.
     * Valid values are "Cluster", "Namespaced", and "*"
     * "Cluster" means that only cluster-scoped resources will match this rule.
     * Namespace API objects are cluster-scoped.
     * "Namespaced" means that only namespaced resources will match this rule.
     * "*" means that there are no scope restrictions.
     * Subresources match the scope of their parent resource.
     * Default is "*".
     * +optional
     * </pre>
     *
     * <code>optional string scope = 4;</code>
     */
    java.lang.String getScope();
    /**
     * <pre>
     * scope specifies the scope of this rule.
     * Valid values are "Cluster", "Namespaced", and "*"
     * "Cluster" means that only cluster-scoped resources will match this rule.
     * Namespace API objects are cluster-scoped.
     * "Namespaced" means that only namespaced resources will match this rule.
     * "*" means that there are no scope restrictions.
     * Subresources match the scope of their parent resource.
     * Default is "*".
     * +optional
     * </pre>
     *
     * <code>optional string scope = 4;</code>
     */
    com.google.protobuf.ByteString
        getScopeBytes();
  }
  /**
   * <pre>
   * Rule is a tuple of APIGroups, APIVersion, and Resources.It is recommended
   * to make sure that all the tuple expansions are valid.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.Rule}
   */
  public  static final class Rule extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.Rule)
      RuleOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Rule.newBuilder() to construct.
    private Rule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Rule() {
      apiGroups_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      apiVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      resources_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      scope_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Rule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                apiGroups_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              apiGroups_.add(bs);
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                apiVersions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000002;
              }
              apiVersions_.add(bs);
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                resources_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              resources_.add(bs);
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              scope_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          apiGroups_ = apiGroups_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          apiVersions_ = apiVersions_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          resources_ = resources_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Rule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Rule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.Rule.class, io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder.class);
    }

    private int bitField0_;
    public static final int APIGROUPS_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList apiGroups_;
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getApiGroupsList() {
      return apiGroups_;
    }
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    public int getApiGroupsCount() {
      return apiGroups_.size();
    }
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    public java.lang.String getApiGroups(int index) {
      return apiGroups_.get(index);
    }
    /**
     * <pre>
     * APIGroups is the API groups the resources belong to. '*' is all groups.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiGroups = 1;</code>
     */
    public com.google.protobuf.ByteString
        getApiGroupsBytes(int index) {
      return apiGroups_.getByteString(index);
    }

    public static final int APIVERSIONS_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList apiVersions_;
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getApiVersionsList() {
      return apiVersions_;
    }
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    public int getApiVersionsCount() {
      return apiVersions_.size();
    }
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    public java.lang.String getApiVersions(int index) {
      return apiVersions_.get(index);
    }
    /**
     * <pre>
     * APIVersions is the API versions the resources belong to. '*' is all versions.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string apiVersions = 2;</code>
     */
    public com.google.protobuf.ByteString
        getApiVersionsBytes(int index) {
      return apiVersions_.getByteString(index);
    }

    public static final int RESOURCES_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList resources_;
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getResourcesList() {
      return resources_;
    }
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    public int getResourcesCount() {
      return resources_.size();
    }
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    public java.lang.String getResources(int index) {
      return resources_.get(index);
    }
    /**
     * <pre>
     * Resources is a list of resources this rule applies to.
     * For example:
     * 'pods' means pods.
     * 'pods/log' means the log subresource of pods.
     * '*' means all resources, but not subresources.
     * 'pods/&#42;' means all subresources of pods.
     * '*&#47;scale' means all scale subresources.
     * '*&#47;&#42;' means all resources and their subresources.
     * If wildcard is present, the validation rule will ensure resources do not
     * overlap with each other.
     * Depending on the enclosing object, subresources might not be allowed.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string resources = 3;</code>
     */
    public com.google.protobuf.ByteString
        getResourcesBytes(int index) {
      return resources_.getByteString(index);
    }

    public static final int SCOPE_FIELD_NUMBER = 4;
    private volatile java.lang.Object scope_;
    /**
     * <pre>
     * scope specifies the scope of this rule.
     * Valid values are "Cluster", "Namespaced", and "*"
     * "Cluster" means that only cluster-scoped resources will match this rule.
     * Namespace API objects are cluster-scoped.
     * "Namespaced" means that only namespaced resources will match this rule.
     * "*" means that there are no scope restrictions.
     * Subresources match the scope of their parent resource.
     * Default is "*".
     * +optional
     * </pre>
     *
     * <code>optional string scope = 4;</code>
     */
    public boolean hasScope() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * scope specifies the scope of this rule.
     * Valid values are "Cluster", "Namespaced", and "*"
     * "Cluster" means that only cluster-scoped resources will match this rule.
     * Namespace API objects are cluster-scoped.
     * "Namespaced" means that only namespaced resources will match this rule.
     * "*" means that there are no scope restrictions.
     * Subresources match the scope of their parent resource.
     * Default is "*".
     * +optional
     * </pre>
     *
     * <code>optional string scope = 4;</code>
     */
    public java.lang.String getScope() {
      java.lang.Object ref = scope_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          scope_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * scope specifies the scope of this rule.
     * Valid values are "Cluster", "Namespaced", and "*"
     * "Cluster" means that only cluster-scoped resources will match this rule.
     * Namespace API objects are cluster-scoped.
     * "Namespaced" means that only namespaced resources will match this rule.
     * "*" means that there are no scope restrictions.
     * Subresources match the scope of their parent resource.
     * Default is "*".
     * +optional
     * </pre>
     *
     * <code>optional string scope = 4;</code>
     */
    public com.google.protobuf.ByteString
        getScopeBytes() {
      java.lang.Object ref = scope_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        scope_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < apiGroups_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, apiGroups_.getRaw(i));
      }
      for (int i = 0; i < apiVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, apiVersions_.getRaw(i));
      }
      for (int i = 0; i < resources_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, resources_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, scope_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < apiGroups_.size(); i++) {
          dataSize += computeStringSizeNoTag(apiGroups_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getApiGroupsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < apiVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(apiVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getApiVersionsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < resources_.size(); i++) {
          dataSize += computeStringSizeNoTag(resources_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getResourcesList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, scope_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.Rule)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.Rule other = (io.kubernetes.client.proto.V1Admissionregistration.Rule) obj;

      boolean result = true;
      result = result && getApiGroupsList()
          .equals(other.getApiGroupsList());
      result = result && getApiVersionsList()
          .equals(other.getApiVersionsList());
      result = result && getResourcesList()
          .equals(other.getResourcesList());
      result = result && (hasScope() == other.hasScope());
      if (hasScope()) {
        result = result && getScope()
            .equals(other.getScope());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getApiGroupsCount() > 0) {
        hash = (37 * hash) + APIGROUPS_FIELD_NUMBER;
        hash = (53 * hash) + getApiGroupsList().hashCode();
      }
      if (getApiVersionsCount() > 0) {
        hash = (37 * hash) + APIVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getApiVersionsList().hashCode();
      }
      if (getResourcesCount() > 0) {
        hash = (37 * hash) + RESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getResourcesList().hashCode();
      }
      if (hasScope()) {
        hash = (37 * hash) + SCOPE_FIELD_NUMBER;
        hash = (53 * hash) + getScope().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Rule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.Rule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Rule is a tuple of APIGroups, APIVersion, and Resources.It is recommended
     * to make sure that all the tuple expansions are valid.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.Rule}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.Rule)
        io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Rule_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Rule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.Rule.class, io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.Rule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        apiGroups_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        apiVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        resources_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        scope_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Rule_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Rule getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Rule build() {
        io.kubernetes.client.proto.V1Admissionregistration.Rule result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Rule buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.Rule result = new io.kubernetes.client.proto.V1Admissionregistration.Rule(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          apiGroups_ = apiGroups_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.apiGroups_ = apiGroups_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          apiVersions_ = apiVersions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.apiVersions_ = apiVersions_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          resources_ = resources_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.resources_ = resources_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000001;
        }
        result.scope_ = scope_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.Rule) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.Rule)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.Rule other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance()) return this;
        if (!other.apiGroups_.isEmpty()) {
          if (apiGroups_.isEmpty()) {
            apiGroups_ = other.apiGroups_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureApiGroupsIsMutable();
            apiGroups_.addAll(other.apiGroups_);
          }
          onChanged();
        }
        if (!other.apiVersions_.isEmpty()) {
          if (apiVersions_.isEmpty()) {
            apiVersions_ = other.apiVersions_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureApiVersionsIsMutable();
            apiVersions_.addAll(other.apiVersions_);
          }
          onChanged();
        }
        if (!other.resources_.isEmpty()) {
          if (resources_.isEmpty()) {
            resources_ = other.resources_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureResourcesIsMutable();
            resources_.addAll(other.resources_);
          }
          onChanged();
        }
        if (other.hasScope()) {
          bitField0_ |= 0x00000008;
          scope_ = other.scope_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.Rule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.Rule) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList apiGroups_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureApiGroupsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          apiGroups_ = new com.google.protobuf.LazyStringArrayList(apiGroups_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getApiGroupsList() {
        return apiGroups_.getUnmodifiableView();
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public int getApiGroupsCount() {
        return apiGroups_.size();
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public java.lang.String getApiGroups(int index) {
        return apiGroups_.get(index);
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public com.google.protobuf.ByteString
          getApiGroupsBytes(int index) {
        return apiGroups_.getByteString(index);
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public Builder setApiGroups(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureApiGroupsIsMutable();
        apiGroups_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public Builder addApiGroups(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureApiGroupsIsMutable();
        apiGroups_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public Builder addAllApiGroups(
          java.lang.Iterable<java.lang.String> values) {
        ensureApiGroupsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, apiGroups_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public Builder clearApiGroups() {
        apiGroups_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIGroups is the API groups the resources belong to. '*' is all groups.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiGroups = 1;</code>
       */
      public Builder addApiGroupsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureApiGroupsIsMutable();
        apiGroups_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList apiVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureApiVersionsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          apiVersions_ = new com.google.protobuf.LazyStringArrayList(apiVersions_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getApiVersionsList() {
        return apiVersions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public int getApiVersionsCount() {
        return apiVersions_.size();
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public java.lang.String getApiVersions(int index) {
        return apiVersions_.get(index);
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public com.google.protobuf.ByteString
          getApiVersionsBytes(int index) {
        return apiVersions_.getByteString(index);
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public Builder setApiVersions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureApiVersionsIsMutable();
        apiVersions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public Builder addApiVersions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureApiVersionsIsMutable();
        apiVersions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public Builder addAllApiVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureApiVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, apiVersions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public Builder clearApiVersions() {
        apiVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * APIVersions is the API versions the resources belong to. '*' is all versions.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string apiVersions = 2;</code>
       */
      public Builder addApiVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureApiVersionsIsMutable();
        apiVersions_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList resources_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureResourcesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          resources_ = new com.google.protobuf.LazyStringArrayList(resources_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getResourcesList() {
        return resources_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public int getResourcesCount() {
        return resources_.size();
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public java.lang.String getResources(int index) {
        return resources_.get(index);
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public com.google.protobuf.ByteString
          getResourcesBytes(int index) {
        return resources_.getByteString(index);
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public Builder setResources(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourcesIsMutable();
        resources_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public Builder addResources(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourcesIsMutable();
        resources_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public Builder addAllResources(
          java.lang.Iterable<java.lang.String> values) {
        ensureResourcesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, resources_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public Builder clearResources() {
        resources_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Resources is a list of resources this rule applies to.
       * For example:
       * 'pods' means pods.
       * 'pods/log' means the log subresource of pods.
       * '*' means all resources, but not subresources.
       * 'pods/&#42;' means all subresources of pods.
       * '*&#47;scale' means all scale subresources.
       * '*&#47;&#42;' means all resources and their subresources.
       * If wildcard is present, the validation rule will ensure resources do not
       * overlap with each other.
       * Depending on the enclosing object, subresources might not be allowed.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string resources = 3;</code>
       */
      public Builder addResourcesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureResourcesIsMutable();
        resources_.add(value);
        onChanged();
        return this;
      }

      private java.lang.Object scope_ = "";
      /**
       * <pre>
       * scope specifies the scope of this rule.
       * Valid values are "Cluster", "Namespaced", and "*"
       * "Cluster" means that only cluster-scoped resources will match this rule.
       * Namespace API objects are cluster-scoped.
       * "Namespaced" means that only namespaced resources will match this rule.
       * "*" means that there are no scope restrictions.
       * Subresources match the scope of their parent resource.
       * Default is "*".
       * +optional
       * </pre>
       *
       * <code>optional string scope = 4;</code>
       */
      public boolean hasScope() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * scope specifies the scope of this rule.
       * Valid values are "Cluster", "Namespaced", and "*"
       * "Cluster" means that only cluster-scoped resources will match this rule.
       * Namespace API objects are cluster-scoped.
       * "Namespaced" means that only namespaced resources will match this rule.
       * "*" means that there are no scope restrictions.
       * Subresources match the scope of their parent resource.
       * Default is "*".
       * +optional
       * </pre>
       *
       * <code>optional string scope = 4;</code>
       */
      public java.lang.String getScope() {
        java.lang.Object ref = scope_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            scope_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * scope specifies the scope of this rule.
       * Valid values are "Cluster", "Namespaced", and "*"
       * "Cluster" means that only cluster-scoped resources will match this rule.
       * Namespace API objects are cluster-scoped.
       * "Namespaced" means that only namespaced resources will match this rule.
       * "*" means that there are no scope restrictions.
       * Subresources match the scope of their parent resource.
       * Default is "*".
       * +optional
       * </pre>
       *
       * <code>optional string scope = 4;</code>
       */
      public com.google.protobuf.ByteString
          getScopeBytes() {
        java.lang.Object ref = scope_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          scope_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * scope specifies the scope of this rule.
       * Valid values are "Cluster", "Namespaced", and "*"
       * "Cluster" means that only cluster-scoped resources will match this rule.
       * Namespace API objects are cluster-scoped.
       * "Namespaced" means that only namespaced resources will match this rule.
       * "*" means that there are no scope restrictions.
       * Subresources match the scope of their parent resource.
       * Default is "*".
       * +optional
       * </pre>
       *
       * <code>optional string scope = 4;</code>
       */
      public Builder setScope(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        scope_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * scope specifies the scope of this rule.
       * Valid values are "Cluster", "Namespaced", and "*"
       * "Cluster" means that only cluster-scoped resources will match this rule.
       * Namespace API objects are cluster-scoped.
       * "Namespaced" means that only namespaced resources will match this rule.
       * "*" means that there are no scope restrictions.
       * Subresources match the scope of their parent resource.
       * Default is "*".
       * +optional
       * </pre>
       *
       * <code>optional string scope = 4;</code>
       */
      public Builder clearScope() {
        bitField0_ = (bitField0_ & ~0x00000008);
        scope_ = getDefaultInstance().getScope();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * scope specifies the scope of this rule.
       * Valid values are "Cluster", "Namespaced", and "*"
       * "Cluster" means that only cluster-scoped resources will match this rule.
       * Namespace API objects are cluster-scoped.
       * "Namespaced" means that only namespaced resources will match this rule.
       * "*" means that there are no scope restrictions.
       * Subresources match the scope of their parent resource.
       * Default is "*".
       * +optional
       * </pre>
       *
       * <code>optional string scope = 4;</code>
       */
      public Builder setScopeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        scope_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.Rule)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.Rule)
    private static final io.kubernetes.client.proto.V1Admissionregistration.Rule DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.Rule();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.Rule getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Rule>
        PARSER = new com.google.protobuf.AbstractParser<Rule>() {
      @java.lang.Override
      public Rule parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Rule(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Rule> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Rule> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.Rule getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RuleWithOperationsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.RuleWithOperations)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    java.util.List<java.lang.String>
        getOperationsList();
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    int getOperationsCount();
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    java.lang.String getOperations(int index);
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    com.google.protobuf.ByteString
        getOperationsBytes(int index);

    /**
     * <pre>
     * Rule is embedded, it describes other criteria of the rule, like
     * APIGroups, APIVersions, Resources, etc.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
     */
    boolean hasRule();
    /**
     * <pre>
     * Rule is embedded, it describes other criteria of the rule, like
     * APIGroups, APIVersions, Resources, etc.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.Rule getRule();
    /**
     * <pre>
     * Rule is embedded, it describes other criteria of the rule, like
     * APIGroups, APIVersions, Resources, etc.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder getRuleOrBuilder();
  }
  /**
   * <pre>
   * RuleWithOperations is a tuple of Operations and Resources. It is recommended to make
   * sure that all the tuple expansions are valid.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.RuleWithOperations}
   */
  public  static final class RuleWithOperations extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.RuleWithOperations)
      RuleWithOperationsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RuleWithOperations.newBuilder() to construct.
    private RuleWithOperations(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RuleWithOperations() {
      operations_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RuleWithOperations(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                operations_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              operations_.add(bs);
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = rule_.toBuilder();
              }
              rule_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.Rule.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(rule_);
                rule_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          operations_ = operations_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.class, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder.class);
    }

    private int bitField0_;
    public static final int OPERATIONS_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList operations_;
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getOperationsList() {
      return operations_;
    }
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    public int getOperationsCount() {
      return operations_.size();
    }
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    public java.lang.String getOperations(int index) {
      return operations_.get(index);
    }
    /**
     * <pre>
     * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
     * for all of those operations and any future admission operations that are added.
     * If '*' is present, the length of the slice must be one.
     * Required.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string operations = 1;</code>
     */
    public com.google.protobuf.ByteString
        getOperationsBytes(int index) {
      return operations_.getByteString(index);
    }

    public static final int RULE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.Rule rule_;
    /**
     * <pre>
     * Rule is embedded, it describes other criteria of the rule, like
     * APIGroups, APIVersions, Resources, etc.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
     */
    public boolean hasRule() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Rule is embedded, it describes other criteria of the rule, like
     * APIGroups, APIVersions, Resources, etc.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.Rule getRule() {
      return rule_ == null ? io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance() : rule_;
    }
    /**
     * <pre>
     * Rule is embedded, it describes other criteria of the rule, like
     * APIGroups, APIVersions, Resources, etc.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder getRuleOrBuilder() {
      return rule_ == null ? io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance() : rule_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < operations_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, operations_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(2, getRule());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < operations_.size(); i++) {
          dataSize += computeStringSizeNoTag(operations_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getOperationsList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRule());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations other = (io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations) obj;

      boolean result = true;
      result = result && getOperationsList()
          .equals(other.getOperationsList());
      result = result && (hasRule() == other.hasRule());
      if (hasRule()) {
        result = result && getRule()
            .equals(other.getRule());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getOperationsCount() > 0) {
        hash = (37 * hash) + OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOperationsList().hashCode();
      }
      if (hasRule()) {
        hash = (37 * hash) + RULE_FIELD_NUMBER;
        hash = (53 * hash) + getRule().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RuleWithOperations is a tuple of Operations and Resources. It is recommended to make
     * sure that all the tuple expansions are valid.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.RuleWithOperations}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.RuleWithOperations)
        io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.class, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRuleFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        operations_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (ruleBuilder_ == null) {
          rule_ = null;
        } else {
          ruleBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations build() {
        io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations result = new io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          operations_ = operations_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.operations_ = operations_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000001;
        }
        if (ruleBuilder_ == null) {
          result.rule_ = rule_;
        } else {
          result.rule_ = ruleBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance()) return this;
        if (!other.operations_.isEmpty()) {
          if (operations_.isEmpty()) {
            operations_ = other.operations_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureOperationsIsMutable();
            operations_.addAll(other.operations_);
          }
          onChanged();
        }
        if (other.hasRule()) {
          mergeRule(other.getRule());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList operations_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureOperationsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          operations_ = new com.google.protobuf.LazyStringArrayList(operations_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getOperationsList() {
        return operations_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public int getOperationsCount() {
        return operations_.size();
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public java.lang.String getOperations(int index) {
        return operations_.get(index);
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public com.google.protobuf.ByteString
          getOperationsBytes(int index) {
        return operations_.getByteString(index);
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public Builder setOperations(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOperationsIsMutable();
        operations_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public Builder addOperations(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOperationsIsMutable();
        operations_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public Builder addAllOperations(
          java.lang.Iterable<java.lang.String> values) {
        ensureOperationsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, operations_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public Builder clearOperations() {
        operations_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
       * for all of those operations and any future admission operations that are added.
       * If '*' is present, the length of the slice must be one.
       * Required.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string operations = 1;</code>
       */
      public Builder addOperationsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOperationsIsMutable();
        operations_.add(value);
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.Rule rule_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.Rule, io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder> ruleBuilder_;
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public boolean hasRule() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Rule getRule() {
        if (ruleBuilder_ == null) {
          return rule_ == null ? io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance() : rule_;
        } else {
          return ruleBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public Builder setRule(io.kubernetes.client.proto.V1Admissionregistration.Rule value) {
        if (ruleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rule_ = value;
          onChanged();
        } else {
          ruleBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public Builder setRule(
          io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder builderForValue) {
        if (ruleBuilder_ == null) {
          rule_ = builderForValue.build();
          onChanged();
        } else {
          ruleBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public Builder mergeRule(io.kubernetes.client.proto.V1Admissionregistration.Rule value) {
        if (ruleBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              rule_ != null &&
              rule_ != io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance()) {
            rule_ =
              io.kubernetes.client.proto.V1Admissionregistration.Rule.newBuilder(rule_).mergeFrom(value).buildPartial();
          } else {
            rule_ = value;
          }
          onChanged();
        } else {
          ruleBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public Builder clearRule() {
        if (ruleBuilder_ == null) {
          rule_ = null;
          onChanged();
        } else {
          ruleBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder getRuleBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRuleFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder getRuleOrBuilder() {
        if (ruleBuilder_ != null) {
          return ruleBuilder_.getMessageOrBuilder();
        } else {
          return rule_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.Rule.getDefaultInstance() : rule_;
        }
      }
      /**
       * <pre>
       * Rule is embedded, it describes other criteria of the rule, like
       * APIGroups, APIVersions, Resources, etc.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.Rule rule = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.Rule, io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder> 
          getRuleFieldBuilder() {
        if (ruleBuilder_ == null) {
          ruleBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.Rule, io.kubernetes.client.proto.V1Admissionregistration.Rule.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleOrBuilder>(
                  getRule(),
                  getParentForChildren(),
                  isClean());
          rule_ = null;
        }
        return ruleBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.RuleWithOperations)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.RuleWithOperations)
    private static final io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<RuleWithOperations>
        PARSER = new com.google.protobuf.AbstractParser<RuleWithOperations>() {
      @java.lang.Override
      public RuleWithOperations parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RuleWithOperations(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RuleWithOperations> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RuleWithOperations> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServiceReferenceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ServiceReference)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    boolean hasNamespace();
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    boolean hasPath();
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    java.lang.String getPath();
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    com.google.protobuf.ByteString
        getPathBytes();

    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    boolean hasPort();
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    int getPort();
  }
  /**
   * <pre>
   * ServiceReference holds a reference to Service.legacy.k8s.io
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ServiceReference}
   */
  public  static final class ServiceReference extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ServiceReference)
      ServiceReferenceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ServiceReference.newBuilder() to construct.
    private ServiceReference(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ServiceReference() {
      namespace_ = "";
      name_ = "";
      path_ = "";
      port_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ServiceReference(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              namespace_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              name_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              path_ = bs;
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              port_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.class, io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder.class);
    }

    private int bitField0_;
    public static final int NAMESPACE_FIELD_NUMBER = 1;
    private volatile java.lang.Object namespace_;
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    public java.lang.String getNamespace() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          namespace_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `namespace` is the namespace of the service.
     * Required
     * </pre>
     *
     * <code>optional string namespace = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      java.lang.Object ref = namespace_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        namespace_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `name` is the name of the service.
     * Required
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object path_;
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    public boolean hasPath() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    public java.lang.String getPath() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          path_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `path` is an optional URL path which will be sent in any request to
     * this service.
     * +optional
     * </pre>
     *
     * <code>optional string path = 3;</code>
     */
    public com.google.protobuf.ByteString
        getPathBytes() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        path_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PORT_FIELD_NUMBER = 4;
    private int port_;
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    public boolean hasPort() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * If specified, the port on the service that hosting webhook.
     * Default to 443 for backward compatibility.
     * `port` should be a valid port number (1-65535, inclusive).
     * +optional
     * </pre>
     *
     * <code>optional int32 port = 4;</code>
     */
    public int getPort() {
      return port_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, namespace_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, path_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, port_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, namespace_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, path_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, port_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ServiceReference)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ServiceReference other = (io.kubernetes.client.proto.V1Admissionregistration.ServiceReference) obj;

      boolean result = true;
      result = result && (hasNamespace() == other.hasNamespace());
      if (hasNamespace()) {
        result = result && getNamespace()
            .equals(other.getNamespace());
      }
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasPath() == other.hasPath());
      if (hasPath()) {
        result = result && getPath()
            .equals(other.getPath());
      }
      result = result && (hasPort() == other.hasPort());
      if (hasPort()) {
        result = result && (getPort()
            == other.getPort());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNamespace()) {
        hash = (37 * hash) + NAMESPACE_FIELD_NUMBER;
        hash = (53 * hash) + getNamespace().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasPath()) {
        hash = (37 * hash) + PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPath().hashCode();
      }
      if (hasPort()) {
        hash = (37 * hash) + PORT_FIELD_NUMBER;
        hash = (53 * hash) + getPort();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ServiceReference prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ServiceReference holds a reference to Service.legacy.k8s.io
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ServiceReference}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ServiceReference)
        io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.class, io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        namespace_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        path_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        port_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference build() {
        io.kubernetes.client.proto.V1Admissionregistration.ServiceReference result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ServiceReference result = new io.kubernetes.client.proto.V1Admissionregistration.ServiceReference(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.namespace_ = namespace_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.path_ = path_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.port_ = port_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ServiceReference) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ServiceReference)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ServiceReference other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance()) return this;
        if (other.hasNamespace()) {
          bitField0_ |= 0x00000001;
          namespace_ = other.namespace_;
          onChanged();
        }
        if (other.hasName()) {
          bitField0_ |= 0x00000002;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasPath()) {
          bitField0_ |= 0x00000004;
          path_ = other.path_;
          onChanged();
        }
        if (other.hasPort()) {
          setPort(other.getPort());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ServiceReference parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ServiceReference) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object namespace_ = "";
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public boolean hasNamespace() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public java.lang.String getNamespace() {
        java.lang.Object ref = namespace_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            namespace_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        java.lang.Object ref = namespace_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          namespace_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public Builder setNamespace(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        namespace_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public Builder clearNamespace() {
        bitField0_ = (bitField0_ & ~0x00000001);
        namespace_ = getDefaultInstance().getNamespace();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `namespace` is the namespace of the service.
       * Required
       * </pre>
       *
       * <code>optional string namespace = 1;</code>
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        namespace_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000002);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `name` is the name of the service.
       * Required
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object path_ = "";
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public boolean hasPath() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public java.lang.String getPath() {
        java.lang.Object ref = path_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            path_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public com.google.protobuf.ByteString
          getPathBytes() {
        java.lang.Object ref = path_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          path_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public Builder setPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        path_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public Builder clearPath() {
        bitField0_ = (bitField0_ & ~0x00000004);
        path_ = getDefaultInstance().getPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `path` is an optional URL path which will be sent in any request to
       * this service.
       * +optional
       * </pre>
       *
       * <code>optional string path = 3;</code>
       */
      public Builder setPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        path_ = value;
        onChanged();
        return this;
      }

      private int port_ ;
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public boolean hasPort() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public int getPort() {
        return port_;
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public Builder setPort(int value) {
        bitField0_ |= 0x00000008;
        port_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the port on the service that hosting webhook.
       * Default to 443 for backward compatibility.
       * `port` should be a valid port number (1-65535, inclusive).
       * +optional
       * </pre>
       *
       * <code>optional int32 port = 4;</code>
       */
      public Builder clearPort() {
        bitField0_ = (bitField0_ & ~0x00000008);
        port_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ServiceReference)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ServiceReference)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ServiceReference DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ServiceReference();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ServiceReference getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ServiceReference>
        PARSER = new com.google.protobuf.AbstractParser<ServiceReference>() {
      @java.lang.Override
      public ServiceReference parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ServiceReference(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ServiceReference> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServiceReference> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TypeCheckingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.TypeChecking)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning> 
        getExpressionWarningsList();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning getExpressionWarnings(int index);
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    int getExpressionWarningsCount();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder> 
        getExpressionWarningsOrBuilderList();
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * TypeChecking contains results of type checking the expressions in the
   * ValidatingAdmissionPolicy
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.TypeChecking}
   */
  public  static final class TypeChecking extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.TypeChecking)
      TypeCheckingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TypeChecking.newBuilder() to construct.
    private TypeChecking(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TypeChecking() {
      expressionWarnings_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TypeChecking(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                expressionWarnings_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning>();
                mutable_bitField0_ |= 0x00000001;
              }
              expressionWarnings_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          expressionWarnings_ = java.util.Collections.unmodifiableList(expressionWarnings_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.class, io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder.class);
    }

    public static final int EXPRESSIONWARNINGS_FIELD_NUMBER = 1;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning> expressionWarnings_;
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning> getExpressionWarningsList() {
      return expressionWarnings_;
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder> 
        getExpressionWarningsOrBuilderList() {
      return expressionWarnings_;
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public int getExpressionWarningsCount() {
      return expressionWarnings_.size();
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning getExpressionWarnings(int index) {
      return expressionWarnings_.get(index);
    }
    /**
     * <pre>
     * The type checking warnings for each expression.
     * +optional
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
        int index) {
      return expressionWarnings_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < expressionWarnings_.size(); i++) {
        output.writeMessage(1, expressionWarnings_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < expressionWarnings_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, expressionWarnings_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.TypeChecking)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.TypeChecking other = (io.kubernetes.client.proto.V1Admissionregistration.TypeChecking) obj;

      boolean result = true;
      result = result && getExpressionWarningsList()
          .equals(other.getExpressionWarningsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getExpressionWarningsCount() > 0) {
        hash = (37 * hash) + EXPRESSIONWARNINGS_FIELD_NUMBER;
        hash = (53 * hash) + getExpressionWarningsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.TypeChecking prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TypeChecking contains results of type checking the expressions in the
     * ValidatingAdmissionPolicy
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.TypeChecking}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.TypeChecking)
        io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.class, io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getExpressionWarningsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (expressionWarningsBuilder_ == null) {
          expressionWarnings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          expressionWarningsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking build() {
        io.kubernetes.client.proto.V1Admissionregistration.TypeChecking result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.TypeChecking result = new io.kubernetes.client.proto.V1Admissionregistration.TypeChecking(this);
        int from_bitField0_ = bitField0_;
        if (expressionWarningsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            expressionWarnings_ = java.util.Collections.unmodifiableList(expressionWarnings_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.expressionWarnings_ = expressionWarnings_;
        } else {
          result.expressionWarnings_ = expressionWarningsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.TypeChecking) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.TypeChecking)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.TypeChecking other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance()) return this;
        if (expressionWarningsBuilder_ == null) {
          if (!other.expressionWarnings_.isEmpty()) {
            if (expressionWarnings_.isEmpty()) {
              expressionWarnings_ = other.expressionWarnings_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureExpressionWarningsIsMutable();
              expressionWarnings_.addAll(other.expressionWarnings_);
            }
            onChanged();
          }
        } else {
          if (!other.expressionWarnings_.isEmpty()) {
            if (expressionWarningsBuilder_.isEmpty()) {
              expressionWarningsBuilder_.dispose();
              expressionWarningsBuilder_ = null;
              expressionWarnings_ = other.expressionWarnings_;
              bitField0_ = (bitField0_ & ~0x00000001);
              expressionWarningsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExpressionWarningsFieldBuilder() : null;
            } else {
              expressionWarningsBuilder_.addAllMessages(other.expressionWarnings_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.TypeChecking parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.TypeChecking) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning> expressionWarnings_ =
        java.util.Collections.emptyList();
      private void ensureExpressionWarningsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          expressionWarnings_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning>(expressionWarnings_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder> expressionWarningsBuilder_;

      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning> getExpressionWarningsList() {
        if (expressionWarningsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(expressionWarnings_);
        } else {
          return expressionWarningsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public int getExpressionWarningsCount() {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.size();
        } else {
          return expressionWarningsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning getExpressionWarnings(int index) {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.get(index);
        } else {
          return expressionWarningsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder setExpressionWarnings(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.set(index, value);
          onChanged();
        } else {
          expressionWarningsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder setExpressionWarnings(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.set(index, builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(value);
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning value) {
        if (expressionWarningsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(index, value);
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addExpressionWarnings(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder builderForValue) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.add(index, builderForValue.build());
          onChanged();
        } else {
          expressionWarningsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder addAllExpressionWarnings(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning> values) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, expressionWarnings_);
          onChanged();
        } else {
          expressionWarningsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder clearExpressionWarnings() {
        if (expressionWarningsBuilder_ == null) {
          expressionWarnings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          expressionWarningsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public Builder removeExpressionWarnings(int index) {
        if (expressionWarningsBuilder_ == null) {
          ensureExpressionWarningsIsMutable();
          expressionWarnings_.remove(index);
          onChanged();
        } else {
          expressionWarningsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder getExpressionWarningsBuilder(
          int index) {
        return getExpressionWarningsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder getExpressionWarningsOrBuilder(
          int index) {
        if (expressionWarningsBuilder_ == null) {
          return expressionWarnings_.get(index);  } else {
          return expressionWarningsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder> 
           getExpressionWarningsOrBuilderList() {
        if (expressionWarningsBuilder_ != null) {
          return expressionWarningsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(expressionWarnings_);
        }
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder addExpressionWarningsBuilder() {
        return getExpressionWarningsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.getDefaultInstance());
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder addExpressionWarningsBuilder(
          int index) {
        return getExpressionWarningsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.getDefaultInstance());
      }
      /**
       * <pre>
       * The type checking warnings for each expression.
       * +optional
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder> 
           getExpressionWarningsBuilderList() {
        return getExpressionWarningsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder> 
          getExpressionWarningsFieldBuilder() {
        if (expressionWarningsBuilder_ == null) {
          expressionWarningsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarning.Builder, io.kubernetes.client.proto.V1Admissionregistration.ExpressionWarningOrBuilder>(
                  expressionWarnings_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          expressionWarnings_ = null;
        }
        return expressionWarningsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.TypeChecking)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.TypeChecking)
    private static final io.kubernetes.client.proto.V1Admissionregistration.TypeChecking DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.TypeChecking();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.TypeChecking getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<TypeChecking>
        PARSER = new com.google.protobuf.AbstractParser<TypeChecking>() {
      @java.lang.Override
      public TypeChecking parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TypeChecking(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TypeChecking> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TypeChecking> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus();
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy}
   */
  public  static final class ValidatingAdmissionPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy)
      ValidatingAdmissionPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicy.newBuilder() to construct.
    private ValidatingAdmissionPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicy() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = status_.toBuilder();
              }
              status_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(status_);
                status_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus status_;
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
     * behaves in the expected way.
     * Populated by the system.
     * Read-only.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              status_ != null &&
              status_ != io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance()) {
            status_ =
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.newBuilder(status_).mergeFrom(value).buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy
       * behaves in the expected way.
       * Populated by the system.
       * Read-only.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicy>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicy>() {
      @java.lang.Override
      public ValidatingAdmissionPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicy> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec();
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder();
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources.
   * ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
   * For a given admission request, each binding will cause its policy to be
   * evaluated N times, where N is 1 for policies/bindings that don't use
   * params, otherwise N is the number of parameters selected by the binding.
   * The CEL expressions of a policy must have a computed CEL cost below the maximum
   * CEL budget. Each evaluation of the policy is given an independent CEL cost budget.
   * Adding/removing policies, bindings, or params can not affect whether a
   * given (policy, binding, param) combination is within its own CEL budget.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding}
   */
  public  static final class ValidatingAdmissionPolicyBinding extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding)
      ValidatingAdmissionPolicyBindingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyBinding.newBuilder() to construct.
    private ValidatingAdmissionPolicyBinding(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBinding() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyBinding(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec spec_;
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources.
     * ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.
     * For a given admission request, each binding will cause its policy to be
     * evaluated N times, where N is 1 for policies/bindings that don't use
     * params, otherwise N is the number of parameters selected by the binding.
     * The CEL expressions of a policy must have a computed CEL cost below the maximum
     * CEL budget. Each evaluation of the policy is given an independent CEL cost budget.
     * Adding/removing policies, bindings, or params can not affect whether a
     * given (policy, binding, param) combination is within its own CEL budget.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBinding>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBinding parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyBinding(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBinding> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding> 
        getItemsList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index);
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList}
   */
  public  static final class ValidatingAdmissionPolicyBindingList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList)
      ValidatingAdmissionPolicyBindingListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyBindingList.newBuilder() to construct.
    private ValidatingAdmissionPolicyBindingList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBindingList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyBindingList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding> items_;
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of PolicyBinding.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.getDefaultInstance());
      }
      /**
       * <pre>
       * List of PolicyBinding.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBinding.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBindingList>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBindingList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyBindingList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyBindingSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    boolean hasPolicyName();
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    java.lang.String getPolicyName();
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    com.google.protobuf.ByteString
        getPolicyNameBytes();

    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
     */
    boolean hasParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ParamRef getParamRef();
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder();

    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
     */
    boolean hasMatchResources();
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchResources getMatchResources();
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder();

    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    java.util.List<java.lang.String>
        getValidationActionsList();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    int getValidationActionsCount();
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    java.lang.String getValidationActions(int index);
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    com.google.protobuf.ByteString
        getValidationActionsBytes(int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec}
   */
  public  static final class ValidatingAdmissionPolicyBindingSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec)
      ValidatingAdmissionPolicyBindingSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyBindingSpec.newBuilder() to construct.
    private ValidatingAdmissionPolicyBindingSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyBindingSpec() {
      policyName_ = "";
      validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyBindingSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              policyName_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = paramRef_.toBuilder();
              }
              paramRef_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ParamRef.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paramRef_);
                paramRef_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = matchResources_.toBuilder();
              }
              matchResources_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MatchResources.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matchResources_);
                matchResources_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                validationActions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000008;
              }
              validationActions_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          validationActions_ = validationActions_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder.class);
    }

    private int bitField0_;
    public static final int POLICYNAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object policyName_;
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public boolean hasPolicyName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public java.lang.String getPolicyName() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          policyName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
     * If the referenced resource does not exist, this binding is considered invalid and will be ignored
     * Required.
     * </pre>
     *
     * <code>optional string policyName = 1;</code>
     */
    public com.google.protobuf.ByteString
        getPolicyNameBytes() {
      java.lang.Object ref = policyName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        policyName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARAMREF_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.ParamRef paramRef_;
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
     */
    public boolean hasParamRef() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ParamRef getParamRef() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }
    /**
     * <pre>
     * paramRef specifies the parameter resource used to configure the admission control policy.
     * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
     * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
     * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
      return paramRef_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
    }

    public static final int MATCHRESOURCES_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Admissionregistration.MatchResources matchResources_;
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
     */
    public boolean hasMatchResources() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchResources getMatchResources() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }
    /**
     * <pre>
     * MatchResources declares what resources match this binding and will be validated by it.
     * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
     * If this is unset, all resources matched by the policy are validated by this binding
     * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
     * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
      return matchResources_ == null ? io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
    }

    public static final int VALIDATIONACTIONS_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList validationActions_;
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getValidationActionsList() {
      return validationActions_;
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public int getValidationActionsCount() {
      return validationActions_.size();
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public java.lang.String getValidationActions(int index) {
      return validationActions_.get(index);
    }
    /**
     * <pre>
     * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
     * If a validation evaluates to false it is always enforced according to these actions.
     * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
     * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
     * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
     * validationActions is declared as a set of action values. Order does
     * not matter. validationActions may not contain duplicates of the same action.
     * The supported actions values are:
     * "Deny" specifies that a validation failure results in a denied request.
     * "Warn" specifies that a validation failure is reported to the request client
     * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
     * both for allowed or denied admission responses.
     * "Audit" specifies that a validation failure is included in the published
     * audit event for the request. The audit event will contain a
     * `validation.policy.admission.k8s.io/validation_failure` audit annotation
     * with a value containing the details of the validation failures, formatted as
     * a JSON list of objects, each with the following fields:
     * - message: The validation failure message string
     * - policy: The resource name of the ValidatingAdmissionPolicy
     * - binding: The resource name of the ValidatingAdmissionPolicyBinding
     * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
     * - validationActions: The enforcement actions enacted for the validation failure
     * Example audit annotation:
     * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
     * Clients should expect to handle additional values by ignoring
     * any values not recognized.
     * "Deny" and "Warn" may not be used together since this combination
     * needlessly duplicates the validation failure both in the
     * API response body and the HTTP warning headers.
     * Required.
     * +listType=set
     * </pre>
     *
     * <code>repeated string validationActions = 4;</code>
     */
    public com.google.protobuf.ByteString
        getValidationActionsBytes(int index) {
      return validationActions_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, policyName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getMatchResources());
      }
      for (int i = 0; i < validationActions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, validationActions_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, policyName_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getParamRef());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getMatchResources());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < validationActions_.size(); i++) {
          dataSize += computeStringSizeNoTag(validationActions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getValidationActionsList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) obj;

      boolean result = true;
      result = result && (hasPolicyName() == other.hasPolicyName());
      if (hasPolicyName()) {
        result = result && getPolicyName()
            .equals(other.getPolicyName());
      }
      result = result && (hasParamRef() == other.hasParamRef());
      if (hasParamRef()) {
        result = result && getParamRef()
            .equals(other.getParamRef());
      }
      result = result && (hasMatchResources() == other.hasMatchResources());
      if (hasMatchResources()) {
        result = result && getMatchResources()
            .equals(other.getMatchResources());
      }
      result = result && getValidationActionsList()
          .equals(other.getValidationActionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPolicyName()) {
        hash = (37 * hash) + POLICYNAME_FIELD_NUMBER;
        hash = (53 * hash) + getPolicyName().hashCode();
      }
      if (hasParamRef()) {
        hash = (37 * hash) + PARAMREF_FIELD_NUMBER;
        hash = (53 * hash) + getParamRef().hashCode();
      }
      if (hasMatchResources()) {
        hash = (37 * hash) + MATCHRESOURCES_FIELD_NUMBER;
        hash = (53 * hash) + getMatchResources().hashCode();
      }
      if (getValidationActionsCount() > 0) {
        hash = (37 * hash) + VALIDATIONACTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getValidationActionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParamRefFieldBuilder();
          getMatchResourcesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        policyName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (paramRefBuilder_ == null) {
          paramRef_ = null;
        } else {
          paramRefBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (matchResourcesBuilder_ == null) {
          matchResources_ = null;
        } else {
          matchResourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.policyName_ = policyName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (paramRefBuilder_ == null) {
          result.paramRef_ = paramRef_;
        } else {
          result.paramRef_ = paramRefBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (matchResourcesBuilder_ == null) {
          result.matchResources_ = matchResources_;
        } else {
          result.matchResources_ = matchResourcesBuilder_.build();
        }
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          validationActions_ = validationActions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.validationActions_ = validationActions_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec.getDefaultInstance()) return this;
        if (other.hasPolicyName()) {
          bitField0_ |= 0x00000001;
          policyName_ = other.policyName_;
          onChanged();
        }
        if (other.hasParamRef()) {
          mergeParamRef(other.getParamRef());
        }
        if (other.hasMatchResources()) {
          mergeMatchResources(other.getMatchResources());
        }
        if (!other.validationActions_.isEmpty()) {
          if (validationActions_.isEmpty()) {
            validationActions_ = other.validationActions_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureValidationActionsIsMutable();
            validationActions_.addAll(other.validationActions_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object policyName_ = "";
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public boolean hasPolicyName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public java.lang.String getPolicyName() {
        java.lang.Object ref = policyName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            policyName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public com.google.protobuf.ByteString
          getPolicyNameBytes() {
        java.lang.Object ref = policyName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          policyName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder setPolicyName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        policyName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder clearPolicyName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        policyName_ = getDefaultInstance().getPolicyName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to.
       * If the referenced resource does not exist, this binding is considered invalid and will be ignored
       * Required.
       * </pre>
       *
       * <code>optional string policyName = 1;</code>
       */
      public Builder setPolicyNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        policyName_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.ParamRef paramRef_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder> paramRefBuilder_;
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public boolean hasParamRef() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ParamRef getParamRef() {
        if (paramRefBuilder_ == null) {
          return paramRef_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        } else {
          return paramRefBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(io.kubernetes.client.proto.V1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramRef_ = value;
          onChanged();
        } else {
          paramRefBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public Builder setParamRef(
          io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder builderForValue) {
        if (paramRefBuilder_ == null) {
          paramRef_ = builderForValue.build();
          onChanged();
        } else {
          paramRefBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public Builder mergeParamRef(io.kubernetes.client.proto.V1Admissionregistration.ParamRef value) {
        if (paramRefBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              paramRef_ != null &&
              paramRef_ != io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance()) {
            paramRef_ =
              io.kubernetes.client.proto.V1Admissionregistration.ParamRef.newBuilder(paramRef_).mergeFrom(value).buildPartial();
          } else {
            paramRef_ = value;
          }
          onChanged();
        } else {
          paramRefBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public Builder clearParamRef() {
        if (paramRefBuilder_ == null) {
          paramRef_ = null;
          onChanged();
        } else {
          paramRefBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder getParamRefBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getParamRefFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder getParamRefOrBuilder() {
        if (paramRefBuilder_ != null) {
          return paramRefBuilder_.getMessageOrBuilder();
        } else {
          return paramRef_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.ParamRef.getDefaultInstance() : paramRef_;
        }
      }
      /**
       * <pre>
       * paramRef specifies the parameter resource used to configure the admission control policy.
       * It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy.
       * If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied.
       * If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamRef paramRef = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder> 
          getParamRefFieldBuilder() {
        if (paramRefBuilder_ == null) {
          paramRefBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ParamRef, io.kubernetes.client.proto.V1Admissionregistration.ParamRef.Builder, io.kubernetes.client.proto.V1Admissionregistration.ParamRefOrBuilder>(
                  getParamRef(),
                  getParentForChildren(),
                  isClean());
          paramRef_ = null;
        }
        return paramRefBuilder_;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.MatchResources matchResources_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder> matchResourcesBuilder_;
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public boolean hasMatchResources() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources getMatchResources() {
        if (matchResourcesBuilder_ == null) {
          return matchResources_ == null ? io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        } else {
          return matchResourcesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(io.kubernetes.client.proto.V1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchResources_ = value;
          onChanged();
        } else {
          matchResourcesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public Builder setMatchResources(
          io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = builderForValue.build();
          onChanged();
        } else {
          matchResourcesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public Builder mergeMatchResources(io.kubernetes.client.proto.V1Admissionregistration.MatchResources value) {
        if (matchResourcesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              matchResources_ != null &&
              matchResources_ != io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance()) {
            matchResources_ =
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.newBuilder(matchResources_).mergeFrom(value).buildPartial();
          } else {
            matchResources_ = value;
          }
          onChanged();
        } else {
          matchResourcesBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public Builder clearMatchResources() {
        if (matchResourcesBuilder_ == null) {
          matchResources_ = null;
          onChanged();
        } else {
          matchResourcesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder getMatchResourcesBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getMatchResourcesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder getMatchResourcesOrBuilder() {
        if (matchResourcesBuilder_ != null) {
          return matchResourcesBuilder_.getMessageOrBuilder();
        } else {
          return matchResources_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchResources_;
        }
      }
      /**
       * <pre>
       * MatchResources declares what resources match this binding and will be validated by it.
       * Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this.
       * If this is unset, all resources matched by the policy are validated by this binding
       * When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated.
       * Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchResources = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchResourcesFieldBuilder() {
        if (matchResourcesBuilder_ == null) {
          matchResourcesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchResources(),
                  getParentForChildren(),
                  isClean());
          matchResources_ = null;
        }
        return matchResourcesBuilder_;
      }

      private com.google.protobuf.LazyStringList validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureValidationActionsIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          validationActions_ = new com.google.protobuf.LazyStringArrayList(validationActions_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getValidationActionsList() {
        return validationActions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public int getValidationActionsCount() {
        return validationActions_.size();
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public java.lang.String getValidationActions(int index) {
        return validationActions_.get(index);
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public com.google.protobuf.ByteString
          getValidationActionsBytes(int index) {
        return validationActions_.getByteString(index);
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder setValidationActions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureValidationActionsIsMutable();
        validationActions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder addValidationActions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureValidationActionsIsMutable();
        validationActions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder addAllValidationActions(
          java.lang.Iterable<java.lang.String> values) {
        ensureValidationActionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, validationActions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder clearValidationActions() {
        validationActions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced.
       * If a validation evaluates to false it is always enforced according to these actions.
       * Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
       * to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
       * ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
       * validationActions is declared as a set of action values. Order does
       * not matter. validationActions may not contain duplicates of the same action.
       * The supported actions values are:
       * "Deny" specifies that a validation failure results in a denied request.
       * "Warn" specifies that a validation failure is reported to the request client
       * in HTTP Warning headers, with a warning code of 299. Warnings can be sent
       * both for allowed or denied admission responses.
       * "Audit" specifies that a validation failure is included in the published
       * audit event for the request. The audit event will contain a
       * `validation.policy.admission.k8s.io/validation_failure` audit annotation
       * with a value containing the details of the validation failures, formatted as
       * a JSON list of objects, each with the following fields:
       * - message: The validation failure message string
       * - policy: The resource name of the ValidatingAdmissionPolicy
       * - binding: The resource name of the ValidatingAdmissionPolicyBinding
       * - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy
       * - validationActions: The enforcement actions enacted for the validation failure
       * Example audit annotation:
       * `"validation.policy.admission.k8s.io/validation_failure": "[{&#92;"message&#92;": &#92;"Invalid value&#92;", {&#92;"policy&#92;": &#92;"policy.example.com&#92;", {&#92;"binding&#92;": &#92;"policybinding.example.com&#92;", {&#92;"expressionIndex&#92;": &#92;"1&#92;", {&#92;"validationActions&#92;": [&#92;"Audit&#92;"]}]"`
       * Clients should expect to handle additional values by ignoring
       * any values not recognized.
       * "Deny" and "Warn" may not be used together since this combination
       * needlessly duplicates the validation failure both in the
       * API response body and the HTTP warning headers.
       * Required.
       * +listType=set
       * </pre>
       *
       * <code>repeated string validationActions = 4;</code>
       */
      public Builder addValidationActionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureValidationActionsIsMutable();
        validationActions_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyBindingSpec>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyBindingSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyBindingSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyBindingSpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyBindingSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy getItems(int index);
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList}
   */
  public  static final class ValidatingAdmissionPolicyList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList)
      ValidatingAdmissionPolicyListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyList.newBuilder() to construct.
    private ValidatingAdmissionPolicyList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy> items_;
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingAdmissionPolicy.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingAdmissionPolicy.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicy.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyList)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyList>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicySpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
     */
    boolean hasParamKind();
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ParamKind getParamKind();
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder();

    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
     */
    boolean hasMatchConstraints();
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchResources getMatchConstraints();
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder();

    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Validation> 
        getValidationsList();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.Validation getValidations(int index);
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    int getValidationsCount();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder> 
        getValidationsOrBuilderList();
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
        int index);

    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation> 
        getAuditAnnotationsList();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation getAuditAnnotations(int index);
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    int getAuditAnnotationsCount();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder> 
        getAuditAnnotationsOrBuilderList();
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
        int index);

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);

    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Variable> 
        getVariablesList();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.Variable getVariables(int index);
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    int getVariablesCount();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList();
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec}
   */
  public  static final class ValidatingAdmissionPolicySpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec)
      ValidatingAdmissionPolicySpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicySpec.newBuilder() to construct.
    private ValidatingAdmissionPolicySpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicySpec() {
      validations_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      auditAnnotations_ = java.util.Collections.emptyList();
      matchConditions_ = java.util.Collections.emptyList();
      variables_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicySpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = paramKind_.toBuilder();
              }
              paramKind_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ParamKind.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paramKind_);
                paramKind_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = matchConstraints_.toBuilder();
              }
              matchConstraints_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MatchResources.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matchConstraints_);
                matchConstraints_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                validations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.Validation>();
                mutable_bitField0_ |= 0x00000004;
              }
              validations_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.Validation.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                auditAnnotations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation>();
                mutable_bitField0_ |= 0x00000010;
              }
              auditAnnotations_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.PARSER, extensionRegistry));
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000020;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.Variable>();
                mutable_bitField0_ |= 0x00000040;
              }
              variables_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.Variable.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          validations_ = java.util.Collections.unmodifiableList(validations_);
        }
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          auditAnnotations_ = java.util.Collections.unmodifiableList(auditAnnotations_);
        }
        if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          variables_ = java.util.Collections.unmodifiableList(variables_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder.class);
    }

    private int bitField0_;
    public static final int PARAMKIND_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1Admissionregistration.ParamKind paramKind_;
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
     */
    public boolean hasParamKind() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ParamKind getParamKind() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }
    /**
     * <pre>
     * ParamKind specifies the kind of resources used to parameterize this policy.
     * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
     * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
     * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
      return paramKind_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
    }

    public static final int MATCHCONSTRAINTS_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.MatchResources matchConstraints_;
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
     */
    public boolean hasMatchConstraints() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchResources getMatchConstraints() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }
    /**
     * <pre>
     * MatchConstraints specifies what resources this policy is designed to validate.
     * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
     * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
     * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
     * Required.
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
      return matchConstraints_ == null ? io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
    }

    public static final int VALIDATIONS_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Validation> validations_;
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Validation> getValidationsList() {
      return validations_;
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder> 
        getValidationsOrBuilderList() {
      return validations_;
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    public int getValidationsCount() {
      return validations_.size();
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.Validation getValidations(int index) {
      return validations_.get(index);
    }
    /**
     * <pre>
     * Validations contain CEL expressions which is used to apply the validation.
     * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
        int index) {
      return validations_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * failurePolicy defines how to handle failures for the admission policy. Failures can
     * occur from CEL expression parse errors, type check errors, runtime errors and invalid
     * or mis-configured policy definitions or bindings.
     * A policy is invalid if spec.paramKind refers to a non-existent Kind.
     * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
     * failurePolicy does not define how validations that evaluate to false are handled.
     * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
     * define how failures are enforced.
     * Allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AUDITANNOTATIONS_FIELD_NUMBER = 5;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation> auditAnnotations_;
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation> getAuditAnnotationsList() {
      return auditAnnotations_;
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder> 
        getAuditAnnotationsOrBuilderList() {
      return auditAnnotations_;
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public int getAuditAnnotationsCount() {
      return auditAnnotations_.size();
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation getAuditAnnotations(int index) {
      return auditAnnotations_.get(index);
    }
    /**
     * <pre>
     * auditAnnotations contains CEL expressions which are used to produce audit
     * annotations for the audit event of the API request.
     * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
     * required.
     * +listType=atomic
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
        int index) {
      return auditAnnotations_.get(index);
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 6;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be validated.
     * Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * If a parameter object is provided, it can be accessed via the `params` handle in the same
     * manner as validation expressions.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the policy is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    public static final int VARIABLES_FIELD_NUMBER = 7;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Variable> variables_;
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Variable> getVariablesList() {
      return variables_;
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder> 
        getVariablesOrBuilderList() {
      return variables_;
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    public int getVariablesCount() {
      return variables_.size();
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.Variable getVariables(int index) {
      return variables_.get(index);
    }
    /**
     * <pre>
     * Variables contain definitions of variables that can be used in composition of other expressions.
     * Each variable is defined as a named CEL expression.
     * The variables defined here will be available under `variables` in other expressions of the policy
     * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
     * The expression of a variable can refer to other variables defined earlier in the list but not those after.
     * Thus, Variables must be sorted by the order of first appearance and acyclic.
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
        int index) {
      return variables_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getMatchConstraints());
      }
      for (int i = 0; i < validations_.size(); i++) {
        output.writeMessage(3, validations_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, failurePolicy_);
      }
      for (int i = 0; i < auditAnnotations_.size(); i++) {
        output.writeMessage(5, auditAnnotations_.get(i));
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(6, matchConditions_.get(i));
      }
      for (int i = 0; i < variables_.size(); i++) {
        output.writeMessage(7, variables_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getParamKind());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMatchConstraints());
      }
      for (int i = 0; i < validations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, validations_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, failurePolicy_);
      }
      for (int i = 0; i < auditAnnotations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, auditAnnotations_.get(i));
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, matchConditions_.get(i));
      }
      for (int i = 0; i < variables_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, variables_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec) obj;

      boolean result = true;
      result = result && (hasParamKind() == other.hasParamKind());
      if (hasParamKind()) {
        result = result && getParamKind()
            .equals(other.getParamKind());
      }
      result = result && (hasMatchConstraints() == other.hasMatchConstraints());
      if (hasMatchConstraints()) {
        result = result && getMatchConstraints()
            .equals(other.getMatchConstraints());
      }
      result = result && getValidationsList()
          .equals(other.getValidationsList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && getAuditAnnotationsList()
          .equals(other.getAuditAnnotationsList());
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && getVariablesList()
          .equals(other.getVariablesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasParamKind()) {
        hash = (37 * hash) + PARAMKIND_FIELD_NUMBER;
        hash = (53 * hash) + getParamKind().hashCode();
      }
      if (hasMatchConstraints()) {
        hash = (37 * hash) + MATCHCONSTRAINTS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConstraints().hashCode();
      }
      if (getValidationsCount() > 0) {
        hash = (37 * hash) + VALIDATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getValidationsList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (getAuditAnnotationsCount() > 0) {
        hash = (37 * hash) + AUDITANNOTATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAuditAnnotationsList().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      if (getVariablesCount() > 0) {
        hash = (37 * hash) + VARIABLES_FIELD_NUMBER;
        hash = (53 * hash) + getVariablesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParamKindFieldBuilder();
          getMatchConstraintsFieldBuilder();
          getValidationsFieldBuilder();
          getAuditAnnotationsFieldBuilder();
          getMatchConditionsFieldBuilder();
          getVariablesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (paramKindBuilder_ == null) {
          paramKind_ = null;
        } else {
          paramKindBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = null;
        } else {
          matchConstraintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (validationsBuilder_ == null) {
          validations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          validationsBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          auditAnnotationsBuilder_.clear();
        }
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          matchConditionsBuilder_.clear();
        }
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
        } else {
          variablesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (paramKindBuilder_ == null) {
          result.paramKind_ = paramKind_;
        } else {
          result.paramKind_ = paramKindBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (matchConstraintsBuilder_ == null) {
          result.matchConstraints_ = matchConstraints_;
        } else {
          result.matchConstraints_ = matchConstraintsBuilder_.build();
        }
        if (validationsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            validations_ = java.util.Collections.unmodifiableList(validations_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.validations_ = validations_;
        } else {
          result.validations_ = validationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (auditAnnotationsBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            auditAnnotations_ = java.util.Collections.unmodifiableList(auditAnnotations_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.auditAnnotations_ = auditAnnotations_;
        } else {
          result.auditAnnotations_ = auditAnnotationsBuilder_.build();
        }
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        if (variablesBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040)) {
            variables_ = java.util.Collections.unmodifiableList(variables_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.variables_ = variables_;
        } else {
          result.variables_ = variablesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec.getDefaultInstance()) return this;
        if (other.hasParamKind()) {
          mergeParamKind(other.getParamKind());
        }
        if (other.hasMatchConstraints()) {
          mergeMatchConstraints(other.getMatchConstraints());
        }
        if (validationsBuilder_ == null) {
          if (!other.validations_.isEmpty()) {
            if (validations_.isEmpty()) {
              validations_ = other.validations_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureValidationsIsMutable();
              validations_.addAll(other.validations_);
            }
            onChanged();
          }
        } else {
          if (!other.validations_.isEmpty()) {
            if (validationsBuilder_.isEmpty()) {
              validationsBuilder_.dispose();
              validationsBuilder_ = null;
              validations_ = other.validations_;
              bitField0_ = (bitField0_ & ~0x00000004);
              validationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getValidationsFieldBuilder() : null;
            } else {
              validationsBuilder_.addAllMessages(other.validations_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000008;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (auditAnnotationsBuilder_ == null) {
          if (!other.auditAnnotations_.isEmpty()) {
            if (auditAnnotations_.isEmpty()) {
              auditAnnotations_ = other.auditAnnotations_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureAuditAnnotationsIsMutable();
              auditAnnotations_.addAll(other.auditAnnotations_);
            }
            onChanged();
          }
        } else {
          if (!other.auditAnnotations_.isEmpty()) {
            if (auditAnnotationsBuilder_.isEmpty()) {
              auditAnnotationsBuilder_.dispose();
              auditAnnotationsBuilder_ = null;
              auditAnnotations_ = other.auditAnnotations_;
              bitField0_ = (bitField0_ & ~0x00000010);
              auditAnnotationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getAuditAnnotationsFieldBuilder() : null;
            } else {
              auditAnnotationsBuilder_.addAllMessages(other.auditAnnotations_);
            }
          }
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000020);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        if (variablesBuilder_ == null) {
          if (!other.variables_.isEmpty()) {
            if (variables_.isEmpty()) {
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureVariablesIsMutable();
              variables_.addAll(other.variables_);
            }
            onChanged();
          }
        } else {
          if (!other.variables_.isEmpty()) {
            if (variablesBuilder_.isEmpty()) {
              variablesBuilder_.dispose();
              variablesBuilder_ = null;
              variables_ = other.variables_;
              bitField0_ = (bitField0_ & ~0x00000040);
              variablesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVariablesFieldBuilder() : null;
            } else {
              variablesBuilder_.addAllMessages(other.variables_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.V1Admissionregistration.ParamKind paramKind_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder> paramKindBuilder_;
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public boolean hasParamKind() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ParamKind getParamKind() {
        if (paramKindBuilder_ == null) {
          return paramKind_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        } else {
          return paramKindBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(io.kubernetes.client.proto.V1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          paramKind_ = value;
          onChanged();
        } else {
          paramKindBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public Builder setParamKind(
          io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder builderForValue) {
        if (paramKindBuilder_ == null) {
          paramKind_ = builderForValue.build();
          onChanged();
        } else {
          paramKindBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public Builder mergeParamKind(io.kubernetes.client.proto.V1Admissionregistration.ParamKind value) {
        if (paramKindBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              paramKind_ != null &&
              paramKind_ != io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance()) {
            paramKind_ =
              io.kubernetes.client.proto.V1Admissionregistration.ParamKind.newBuilder(paramKind_).mergeFrom(value).buildPartial();
          } else {
            paramKind_ = value;
          }
          onChanged();
        } else {
          paramKindBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public Builder clearParamKind() {
        if (paramKindBuilder_ == null) {
          paramKind_ = null;
          onChanged();
        } else {
          paramKindBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder getParamKindBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getParamKindFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder getParamKindOrBuilder() {
        if (paramKindBuilder_ != null) {
          return paramKindBuilder_.getMessageOrBuilder();
        } else {
          return paramKind_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.ParamKind.getDefaultInstance() : paramKind_;
        }
      }
      /**
       * <pre>
       * ParamKind specifies the kind of resources used to parameterize this policy.
       * If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions.
       * If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied.
       * If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ParamKind paramKind = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder> 
          getParamKindFieldBuilder() {
        if (paramKindBuilder_ == null) {
          paramKindBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ParamKind, io.kubernetes.client.proto.V1Admissionregistration.ParamKind.Builder, io.kubernetes.client.proto.V1Admissionregistration.ParamKindOrBuilder>(
                  getParamKind(),
                  getParentForChildren(),
                  isClean());
          paramKind_ = null;
        }
        return paramKindBuilder_;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.MatchResources matchConstraints_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder> matchConstraintsBuilder_;
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public boolean hasMatchConstraints() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources getMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          return matchConstraints_ == null ? io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        } else {
          return matchConstraintsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(io.kubernetes.client.proto.V1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matchConstraints_ = value;
          onChanged();
        } else {
          matchConstraintsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public Builder setMatchConstraints(
          io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder builderForValue) {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = builderForValue.build();
          onChanged();
        } else {
          matchConstraintsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public Builder mergeMatchConstraints(io.kubernetes.client.proto.V1Admissionregistration.MatchResources value) {
        if (matchConstraintsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              matchConstraints_ != null &&
              matchConstraints_ != io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance()) {
            matchConstraints_ =
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.newBuilder(matchConstraints_).mergeFrom(value).buildPartial();
          } else {
            matchConstraints_ = value;
          }
          onChanged();
        } else {
          matchConstraintsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public Builder clearMatchConstraints() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraints_ = null;
          onChanged();
        } else {
          matchConstraintsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder getMatchConstraintsBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getMatchConstraintsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder getMatchConstraintsOrBuilder() {
        if (matchConstraintsBuilder_ != null) {
          return matchConstraintsBuilder_.getMessageOrBuilder();
        } else {
          return matchConstraints_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources.getDefaultInstance() : matchConstraints_;
        }
      }
      /**
       * <pre>
       * MatchConstraints specifies what resources this policy is designed to validate.
       * The AdmissionPolicy cares about a request if it matches _all_ Constraints.
       * However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API
       * ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding.
       * Required.
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.MatchResources matchConstraints = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder> 
          getMatchConstraintsFieldBuilder() {
        if (matchConstraintsBuilder_ == null) {
          matchConstraintsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MatchResources, io.kubernetes.client.proto.V1Admissionregistration.MatchResources.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchResourcesOrBuilder>(
                  getMatchConstraints(),
                  getParentForChildren(),
                  isClean());
          matchConstraints_ = null;
        }
        return matchConstraintsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Validation> validations_ =
        java.util.Collections.emptyList();
      private void ensureValidationsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          validations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.Validation>(validations_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.Validation, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder> validationsBuilder_;

      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Validation> getValidationsList() {
        if (validationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(validations_);
        } else {
          return validationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public int getValidationsCount() {
        if (validationsBuilder_ == null) {
          return validations_.size();
        } else {
          return validationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Validation getValidations(int index) {
        if (validationsBuilder_ == null) {
          return validations_.get(index);
        } else {
          return validationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder setValidations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.set(index, value);
          onChanged();
        } else {
          validationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder setValidations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.set(index, builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder addValidations(io.kubernetes.client.proto.V1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.add(value);
          onChanged();
        } else {
          validationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Validation value) {
        if (validationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValidationsIsMutable();
          validations_.add(index, value);
          onChanged();
        } else {
          validationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.add(builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder addValidations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder builderForValue) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.add(index, builderForValue.build());
          onChanged();
        } else {
          validationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder addAllValidations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.Validation> values) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, validations_);
          onChanged();
        } else {
          validationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder clearValidations() {
        if (validationsBuilder_ == null) {
          validations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          validationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public Builder removeValidations(int index) {
        if (validationsBuilder_ == null) {
          ensureValidationsIsMutable();
          validations_.remove(index);
          onChanged();
        } else {
          validationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder getValidationsBuilder(
          int index) {
        return getValidationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder getValidationsOrBuilder(
          int index) {
        if (validationsBuilder_ == null) {
          return validations_.get(index);  } else {
          return validationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder> 
           getValidationsOrBuilderList() {
        if (validationsBuilder_ != null) {
          return validationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(validations_);
        }
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder addValidationsBuilder() {
        return getValidationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.Validation.getDefaultInstance());
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder addValidationsBuilder(
          int index) {
        return getValidationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.Validation.getDefaultInstance());
      }
      /**
       * <pre>
       * Validations contain CEL expressions which is used to apply the validation.
       * Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Validation validations = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder> 
           getValidationsBuilderList() {
        return getValidationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.Validation, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder> 
          getValidationsFieldBuilder() {
        if (validationsBuilder_ == null) {
          validationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.Validation, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder>(
                  validations_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          validations_ = null;
        }
        return validationsBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * failurePolicy defines how to handle failures for the admission policy. Failures can
       * occur from CEL expression parse errors, type check errors, runtime errors and invalid
       * or mis-configured policy definitions or bindings.
       * A policy is invalid if spec.paramKind refers to a non-existent Kind.
       * A binding is invalid if spec.paramRef.name refers to a non-existent resource.
       * failurePolicy does not define how validations that evaluate to false are handled.
       * When failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions
       * define how failures are enforced.
       * Allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation> auditAnnotations_ =
        java.util.Collections.emptyList();
      private void ensureAuditAnnotationsIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          auditAnnotations_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation>(auditAnnotations_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder> auditAnnotationsBuilder_;

      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation> getAuditAnnotationsList() {
        if (auditAnnotationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(auditAnnotations_);
        } else {
          return auditAnnotationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public int getAuditAnnotationsCount() {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.size();
        } else {
          return auditAnnotationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation getAuditAnnotations(int index) {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.get(index);
        } else {
          return auditAnnotationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder setAuditAnnotations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.set(index, value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder setAuditAnnotations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.set(index, builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation value) {
        if (auditAnnotationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(index, value);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAuditAnnotations(
          int index, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder builderForValue) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.add(index, builderForValue.build());
          onChanged();
        } else {
          auditAnnotationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder addAllAuditAnnotations(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation> values) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, auditAnnotations_);
          onChanged();
        } else {
          auditAnnotationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder clearAuditAnnotations() {
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          auditAnnotationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public Builder removeAuditAnnotations(int index) {
        if (auditAnnotationsBuilder_ == null) {
          ensureAuditAnnotationsIsMutable();
          auditAnnotations_.remove(index);
          onChanged();
        } else {
          auditAnnotationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder getAuditAnnotationsBuilder(
          int index) {
        return getAuditAnnotationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder getAuditAnnotationsOrBuilder(
          int index) {
        if (auditAnnotationsBuilder_ == null) {
          return auditAnnotations_.get(index);  } else {
          return auditAnnotationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder> 
           getAuditAnnotationsOrBuilderList() {
        if (auditAnnotationsBuilder_ != null) {
          return auditAnnotationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(auditAnnotations_);
        }
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder addAuditAnnotationsBuilder() {
        return getAuditAnnotationsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder addAuditAnnotationsBuilder(
          int index) {
        return getAuditAnnotationsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * auditAnnotations contains CEL expressions which are used to produce audit
       * annotations for the audit event of the API request.
       * validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
       * required.
       * +listType=atomic
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder> 
           getAuditAnnotationsBuilderList() {
        return getAuditAnnotationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder> 
          getAuditAnnotationsFieldBuilder() {
        if (auditAnnotationsBuilder_ == null) {
          auditAnnotationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotation.Builder, io.kubernetes.client.proto.V1Admissionregistration.AuditAnnotationOrBuilder>(
                  auditAnnotations_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          auditAnnotations_ = null;
        }
        return auditAnnotationsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be validated.
       * Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * If a parameter object is provided, it can be accessed via the `params` handle in the same
       * manner as validation expressions.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the policy is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 6;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000020) == 0x00000020),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Variable> variables_ =
        java.util.Collections.emptyList();
      private void ensureVariablesIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          variables_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.Variable>(variables_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.Variable, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder> variablesBuilder_;

      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Variable> getVariablesList() {
        if (variablesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(variables_);
        } else {
          return variablesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public int getVariablesCount() {
        if (variablesBuilder_ == null) {
          return variables_.size();
        } else {
          return variablesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Variable getVariables(int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);
        } else {
          return variablesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.set(index, value);
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder setVariables(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.set(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder addVariables(io.kubernetes.client.proto.V1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Variable value) {
        if (variablesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVariablesIsMutable();
          variables_.add(index, value);
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder addVariables(
          int index, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder builderForValue) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.add(index, builderForValue.build());
          onChanged();
        } else {
          variablesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder addAllVariables(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.Variable> values) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, variables_);
          onChanged();
        } else {
          variablesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder clearVariables() {
        if (variablesBuilder_ == null) {
          variables_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          variablesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public Builder removeVariables(int index) {
        if (variablesBuilder_ == null) {
          ensureVariablesIsMutable();
          variables_.remove(index);
          onChanged();
        } else {
          variablesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder getVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder getVariablesOrBuilder(
          int index) {
        if (variablesBuilder_ == null) {
          return variables_.get(index);  } else {
          return variablesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder> 
           getVariablesOrBuilderList() {
        if (variablesBuilder_ != null) {
          return variablesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(variables_);
        }
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder addVariablesBuilder() {
        return getVariablesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder addVariablesBuilder(
          int index) {
        return getVariablesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.Variable.getDefaultInstance());
      }
      /**
       * <pre>
       * Variables contain definitions of variables that can be used in composition of other expressions.
       * Each variable is defined as a named CEL expression.
       * The variables defined here will be available under `variables` in other expressions of the policy
       * except MatchConditions because MatchConditions are evaluated before the rest of the policy.
       * The expression of a variable can refer to other variables defined earlier in the list but not those after.
       * Thus, Variables must be sorted by the order of first appearance and acyclic.
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.Variable variables = 7;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder> 
           getVariablesBuilderList() {
        return getVariablesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.Variable, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder> 
          getVariablesFieldBuilder() {
        if (variablesBuilder_ == null) {
          variablesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.Variable, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder, io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder>(
                  variables_,
                  ((bitField0_ & 0x00000040) == 0x00000040),
                  getParentForChildren(),
                  isClean());
          variables_ = null;
        }
        return variablesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicySpec)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicySpec>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicySpec>() {
      @java.lang.Override
      public ValidatingAdmissionPolicySpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicySpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicySpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicySpec> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicySpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingAdmissionPolicyStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    long getObservedGeneration();

    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
     */
    boolean hasTypeChecking();
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.TypeChecking getTypeChecking();
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder();

    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.Meta.Condition> 
        getConditionsList();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    io.kubernetes.client.proto.Meta.Condition getConditions(int index);
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    int getConditionsCount();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
        getConditionsOrBuilderList();
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus}
   */
  public  static final class ValidatingAdmissionPolicyStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus)
      ValidatingAdmissionPolicyStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingAdmissionPolicyStatus.newBuilder() to construct.
    private ValidatingAdmissionPolicyStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingAdmissionPolicyStatus() {
      observedGeneration_ = 0L;
      conditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingAdmissionPolicyStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              observedGeneration_ = input.readInt64();
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = typeChecking_.toBuilder();
              }
              typeChecking_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(typeChecking_);
                typeChecking_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.Condition>();
                mutable_bitField0_ |= 0x00000004;
              }
              conditions_.add(
                  input.readMessage(io.kubernetes.client.proto.Meta.Condition.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          conditions_ = java.util.Collections.unmodifiableList(conditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder.class);
    }

    private int bitField0_;
    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 1;
    private long observedGeneration_;
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The generation observed by the controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 1;</code>
     */
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int TYPECHECKING_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.TypeChecking typeChecking_;
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
     */
    public boolean hasTypeChecking() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking getTypeChecking() {
      return typeChecking_ == null ? io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
    }
    /**
     * <pre>
     * The results of type checking for each expression.
     * Presence of this field indicates the completion of the type checking.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder() {
      return typeChecking_ == null ? io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
    }

    public static final int CONDITIONS_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.Meta.Condition> conditions_;
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.Meta.Condition> getConditionsList() {
      return conditions_;
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
        getConditionsOrBuilderList() {
      return conditions_;
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public int getConditionsCount() {
      return conditions_.size();
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.Condition getConditions(int index) {
      return conditions_.get(index);
    }
    /**
     * <pre>
     * The conditions represent the latest available observations of a policy's current state.
     * +optional
     * +listType=map
     * +listMapKey=type
     * </pre>
     *
     * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
     */
    public io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
        int index) {
      return conditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getTypeChecking());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        output.writeMessage(3, conditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, observedGeneration_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getTypeChecking());
      }
      for (int i = 0; i < conditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, conditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus) obj;

      boolean result = true;
      result = result && (hasObservedGeneration() == other.hasObservedGeneration());
      if (hasObservedGeneration()) {
        result = result && (getObservedGeneration()
            == other.getObservedGeneration());
      }
      result = result && (hasTypeChecking() == other.hasTypeChecking());
      if (hasTypeChecking()) {
        result = result && getTypeChecking()
            .equals(other.getTypeChecking());
      }
      result = result && getConditionsList()
          .equals(other.getConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasTypeChecking()) {
        hash = (37 * hash) + TYPECHECKING_FIELD_NUMBER;
        hash = (53 * hash) + getTypeChecking().hashCode();
      }
      if (getConditionsCount() > 0) {
        hash = (37 * hash) + CONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTypeCheckingFieldBuilder();
          getConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        observedGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = null;
        } else {
          typeCheckingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.observedGeneration_ = observedGeneration_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (typeCheckingBuilder_ == null) {
          result.typeChecking_ = typeChecking_;
        } else {
          result.typeChecking_ = typeCheckingBuilder_.build();
        }
        if (conditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            conditions_ = java.util.Collections.unmodifiableList(conditions_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.conditions_ = conditions_;
        } else {
          result.conditions_ = conditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus.getDefaultInstance()) return this;
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasTypeChecking()) {
          mergeTypeChecking(other.getTypeChecking());
        }
        if (conditionsBuilder_ == null) {
          if (!other.conditions_.isEmpty()) {
            if (conditions_.isEmpty()) {
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureConditionsIsMutable();
              conditions_.addAll(other.conditions_);
            }
            onChanged();
          }
        } else {
          if (!other.conditions_.isEmpty()) {
            if (conditionsBuilder_.isEmpty()) {
              conditionsBuilder_.dispose();
              conditionsBuilder_ = null;
              conditions_ = other.conditions_;
              bitField0_ = (bitField0_ & ~0x00000004);
              conditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getConditionsFieldBuilder() : null;
            } else {
              conditionsBuilder_.addAllMessages(other.conditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long observedGeneration_ ;
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public Builder setObservedGeneration(long value) {
        bitField0_ |= 0x00000001;
        observedGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The generation observed by the controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 1;</code>
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000001);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.TypeChecking typeChecking_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder> typeCheckingBuilder_;
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public boolean hasTypeChecking() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking getTypeChecking() {
        if (typeCheckingBuilder_ == null) {
          return typeChecking_ == null ? io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
        } else {
          return typeCheckingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public Builder setTypeChecking(io.kubernetes.client.proto.V1Admissionregistration.TypeChecking value) {
        if (typeCheckingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          typeChecking_ = value;
          onChanged();
        } else {
          typeCheckingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public Builder setTypeChecking(
          io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder builderForValue) {
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = builderForValue.build();
          onChanged();
        } else {
          typeCheckingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public Builder mergeTypeChecking(io.kubernetes.client.proto.V1Admissionregistration.TypeChecking value) {
        if (typeCheckingBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              typeChecking_ != null &&
              typeChecking_ != io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance()) {
            typeChecking_ =
              io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.newBuilder(typeChecking_).mergeFrom(value).buildPartial();
          } else {
            typeChecking_ = value;
          }
          onChanged();
        } else {
          typeCheckingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public Builder clearTypeChecking() {
        if (typeCheckingBuilder_ == null) {
          typeChecking_ = null;
          onChanged();
        } else {
          typeCheckingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder getTypeCheckingBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getTypeCheckingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder getTypeCheckingOrBuilder() {
        if (typeCheckingBuilder_ != null) {
          return typeCheckingBuilder_.getMessageOrBuilder();
        } else {
          return typeChecking_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.getDefaultInstance() : typeChecking_;
        }
      }
      /**
       * <pre>
       * The results of type checking for each expression.
       * Presence of this field indicates the completion of the type checking.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.TypeChecking typeChecking = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder> 
          getTypeCheckingFieldBuilder() {
        if (typeCheckingBuilder_ == null) {
          typeCheckingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.TypeChecking, io.kubernetes.client.proto.V1Admissionregistration.TypeChecking.Builder, io.kubernetes.client.proto.V1Admissionregistration.TypeCheckingOrBuilder>(
                  getTypeChecking(),
                  getParentForChildren(),
                  isClean());
          typeChecking_ = null;
        }
        return typeCheckingBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.Meta.Condition> conditions_ =
        java.util.Collections.emptyList();
      private void ensureConditionsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          conditions_ = new java.util.ArrayList<io.kubernetes.client.proto.Meta.Condition>(conditions_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder> conditionsBuilder_;

      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.Condition> getConditionsList() {
        if (conditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(conditions_);
        } else {
          return conditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public int getConditionsCount() {
        if (conditionsBuilder_ == null) {
          return conditions_.size();
        } else {
          return conditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition getConditions(int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);
        } else {
          return conditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.set(index, value);
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder setConditions(
          int index, io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.Meta.Condition value) {
        if (conditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConditionsIsMutable();
          conditions_.add(index, value);
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addConditions(
          int index, io.kubernetes.client.proto.Meta.Condition.Builder builderForValue) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          conditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder addAllConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.Meta.Condition> values) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, conditions_);
          onChanged();
        } else {
          conditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder clearConditions() {
        if (conditionsBuilder_ == null) {
          conditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          conditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public Builder removeConditions(int index) {
        if (conditionsBuilder_ == null) {
          ensureConditionsIsMutable();
          conditions_.remove(index);
          onChanged();
        } else {
          conditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder getConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.ConditionOrBuilder getConditionsOrBuilder(
          int index) {
        if (conditionsBuilder_ == null) {
          return conditions_.get(index);  } else {
          return conditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
           getConditionsOrBuilderList() {
        if (conditionsBuilder_ != null) {
          return conditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(conditions_);
        }
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder addConditionsBuilder() {
        return getConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.Meta.Condition.getDefaultInstance());
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public io.kubernetes.client.proto.Meta.Condition.Builder addConditionsBuilder(
          int index) {
        return getConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.Meta.Condition.getDefaultInstance());
      }
      /**
       * <pre>
       * The conditions represent the latest available observations of a policy's current state.
       * +optional
       * +listType=map
       * +listMapKey=type
       * </pre>
       *
       * <code>repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.Meta.Condition.Builder> 
           getConditionsBuilderList() {
        return getConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder> 
          getConditionsFieldBuilder() {
        if (conditionsBuilder_ == null) {
          conditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.Meta.Condition, io.kubernetes.client.proto.Meta.Condition.Builder, io.kubernetes.client.proto.Meta.ConditionOrBuilder>(
                  conditions_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          conditions_ = null;
        }
        return conditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingAdmissionPolicyStatus>() {
      @java.lang.Override
      public ValidatingAdmissionPolicyStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingAdmissionPolicyStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingAdmissionPolicyStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingAdmissionPolicyStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingWebhook)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    boolean hasClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getClientConfig();
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder();

    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> 
        getRulesList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index);
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList();
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index);

    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    boolean hasFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    java.lang.String getFailurePolicy();
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    com.google.protobuf.ByteString
        getFailurePolicyBytes();

    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    boolean hasMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    java.lang.String getMatchPolicy();
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    com.google.protobuf.ByteString
        getMatchPolicyBytes();

    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    boolean hasNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector();
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder();

    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    boolean hasObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector();
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder();

    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    boolean hasSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    java.lang.String getSideEffects();
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    com.google.protobuf.ByteString
        getSideEffectsBytes();

    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    boolean hasTimeoutSeconds();
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    int getTimeoutSeconds();

    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.util.List<java.lang.String>
        getAdmissionReviewVersionsList();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    int getAdmissionReviewVersionsCount();
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    java.lang.String getAdmissionReviewVersions(int index);
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index);

    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> 
        getMatchConditionsList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index);
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    int getMatchConditionsCount();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList();
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingWebhook}
   */
  public  static final class ValidatingWebhook extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingWebhook)
      ValidatingWebhookOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingWebhook.newBuilder() to construct.
    private ValidatingWebhook(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhook() {
      name_ = "";
      rules_ = java.util.Collections.emptyList();
      failurePolicy_ = "";
      matchPolicy_ = "";
      sideEffects_ = "";
      timeoutSeconds_ = 0;
      admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      matchConditions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingWebhook(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = clientConfig_.toBuilder();
              }
              clientConfig_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(clientConfig_);
                clientConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>();
                mutable_bitField0_ |= 0x00000004;
              }
              rules_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.PARSER, extensionRegistry));
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              failurePolicy_ = bs;
              break;
            }
            case 42: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = namespaceSelector_.toBuilder();
              }
              namespaceSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(namespaceSelector_);
                namespaceSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              sideEffects_ = bs;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000080;
              timeoutSeconds_ = input.readInt32();
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000200;
              }
              admissionReviewVersions_.add(bs);
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              matchPolicy_ = bs;
              break;
            }
            case 82: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = objectSelector_.toBuilder();
              }
              objectSelector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectSelector_);
                objectSelector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 90: {
              if (!((mutable_bitField0_ & 0x00000400) == 0x00000400)) {
                matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition>();
                mutable_bitField0_ |= 0x00000400;
              }
              matchConditions_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000400) == 0x00000400)) {
          matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the admission webhook.
     * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
     * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
     * of the organization.
     * Required.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CLIENTCONFIG_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig clientConfig_;
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    public boolean hasClientConfig() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getClientConfig() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }
    /**
     * <pre>
     * ClientConfig defines how to communicate with the hook.
     * Required
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
      return clientConfig_ == null ? io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
    }

    public static final int RULES_FIELD_NUMBER = 3;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_;
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * Rules describes what operations on what resources/subresources the webhook cares about.
     * The webhook cares about an operation if it matches _any_ Rule.
     * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
     * from putting the cluster in a state which cannot be recovered from without completely
     * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
     * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    public static final int FAILUREPOLICY_FIELD_NUMBER = 4;
    private volatile java.lang.Object failurePolicy_;
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public boolean hasFailurePolicy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public java.lang.String getFailurePolicy() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          failurePolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
     * allowed values are Ignore or Fail. Defaults to Fail.
     * +optional
     * </pre>
     *
     * <code>optional string failurePolicy = 4;</code>
     */
    public com.google.protobuf.ByteString
        getFailurePolicyBytes() {
      java.lang.Object ref = failurePolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        failurePolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MATCHPOLICY_FIELD_NUMBER = 9;
    private volatile java.lang.Object matchPolicy_;
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public boolean hasMatchPolicy() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public java.lang.String getMatchPolicy() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          matchPolicy_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * matchPolicy defines how the "rules" list is used to match incoming requests.
     * Allowed values are "Exact" or "Equivalent".
     * - Exact: match a request only if it exactly matches a specified rule.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
     * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
     * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
     * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
     * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
     * Defaults to "Equivalent"
     * +optional
     * </pre>
     *
     * <code>optional string matchPolicy = 9;</code>
     */
    public com.google.protobuf.ByteString
        getMatchPolicyBytes() {
      java.lang.Object ref = matchPolicy_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        matchPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAMESPACESELECTOR_FIELD_NUMBER = 5;
    private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_;
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public boolean hasNamespaceSelector() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }
    /**
     * <pre>
     * NamespaceSelector decides whether to run the webhook on an object based
     * on whether the namespace for that object matches the selector. If the
     * object itself is a namespace, the matching is performed on
     * object.metadata.labels. If the object is another cluster scoped resource,
     * it never skips the webhook.
     * For example, to run the webhook on any objects whose namespace is not
     * associated with "runlevel" of "0" or "1";  you will set the selector as
     * follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "runlevel",
     *       "operator": "NotIn",
     *       "values": [
     *         "0",
     *         "1"
     *       ]
     *     }
     *   ]
     * }
     * If instead you want to only run the webhook on any objects whose
     * namespace is associated with the "environment" of "prod" or "staging";
     * you will set the selector as follows:
     * "namespaceSelector": {
     *   "matchExpressions": [
     *     {
     *       "key": "environment",
     *       "operator": "In",
     *       "values": [
     *         "prod",
     *         "staging"
     *       ]
     *     }
     *   ]
     * }
     * See
     * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
     * for more examples of label selectors.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
      return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
    }

    public static final int OBJECTSELECTOR_FIELD_NUMBER = 10;
    private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_;
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    public boolean hasObjectSelector() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }
    /**
     * <pre>
     * ObjectSelector decides whether to run the webhook based on if the
     * object has matching labels. objectSelector is evaluated against both
     * the oldObject and newObject that would be sent to the webhook, and
     * is considered to match if either object matches the selector. A null
     * object (oldObject in the case of create, or newObject in the case of
     * delete) or an object that cannot have labels (like a
     * DeploymentRollback or a PodProxyOptions object) is not considered to
     * match.
     * Use the object selector only if the webhook is opt-in, because end
     * users may skip the admission webhook by setting the labels.
     * Default to the empty LabelSelector, which matches everything.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
      return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
    }

    public static final int SIDEEFFECTS_FIELD_NUMBER = 6;
    private volatile java.lang.Object sideEffects_;
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public boolean hasSideEffects() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public java.lang.String getSideEffects() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sideEffects_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * SideEffects states whether this webhook has side effects.
     * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
     * Webhooks with side effects MUST implement a reconciliation system, since a request may be
     * rejected by a future step in the admission chain and the side effects therefore need to be undone.
     * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
     * sideEffects == Unknown or Some.
     * </pre>
     *
     * <code>optional string sideEffects = 6;</code>
     */
    public com.google.protobuf.ByteString
        getSideEffectsBytes() {
      java.lang.Object ref = sideEffects_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sideEffects_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TIMEOUTSECONDS_FIELD_NUMBER = 7;
    private int timeoutSeconds_;
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public boolean hasTimeoutSeconds() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
     * the webhook call will be ignored or the API call will fail based on the
     * failure policy.
     * The timeout value must be between 1 and 30 seconds.
     * Default to 10 seconds.
     * +optional
     * </pre>
     *
     * <code>optional int32 timeoutSeconds = 7;</code>
     */
    public int getTimeoutSeconds() {
      return timeoutSeconds_;
    }

    public static final int ADMISSIONREVIEWVERSIONS_FIELD_NUMBER = 8;
    private com.google.protobuf.LazyStringList admissionReviewVersions_;
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getAdmissionReviewVersionsList() {
      return admissionReviewVersions_;
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public int getAdmissionReviewVersionsCount() {
      return admissionReviewVersions_.size();
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public java.lang.String getAdmissionReviewVersions(int index) {
      return admissionReviewVersions_.get(index);
    }
    /**
     * <pre>
     * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
     * versions the Webhook expects. API server will try to use first version in
     * the list which it supports. If none of the versions specified in this list
     * supported by API server, validation will fail for this object.
     * If a persisted webhook configuration specifies allowed versions and does not
     * include any versions known to the API Server, calls to the webhook will fail
     * and be subject to the failure policy.
     * +listType=atomic
     * </pre>
     *
     * <code>repeated string admissionReviewVersions = 8;</code>
     */
    public com.google.protobuf.ByteString
        getAdmissionReviewVersionsBytes(int index) {
      return admissionReviewVersions_.getByteString(index);
    }

    public static final int MATCHCONDITIONS_FIELD_NUMBER = 11;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> matchConditions_;
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> getMatchConditionsList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
        getMatchConditionsOrBuilderList() {
      return matchConditions_;
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    public int getMatchConditionsCount() {
      return matchConditions_.size();
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index) {
      return matchConditions_.get(index);
    }
    /**
     * <pre>
     * MatchConditions is a list of conditions that must be met for a request to be sent to this
     * webhook. Match conditions filter requests that have already been matched by the rules,
     * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
     * There are a maximum of 64 match conditions allowed.
     * The exact matching logic is (in order):
     *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
     *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
     *   3. If any matchCondition evaluates to an error (but none are FALSE):
     *      - If failurePolicy=Fail, reject the request
     *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * +optional
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
        int index) {
      return matchConditions_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(7, timeoutSeconds_);
      }
      for (int i = 0; i < admissionReviewVersions_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, admissionReviewVersions_.getRaw(i));
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(10, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        output.writeMessage(11, matchConditions_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientConfig());
      }
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, rules_.get(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, failurePolicy_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getNamespaceSelector());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, sideEffects_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, timeoutSeconds_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < admissionReviewVersions_.size(); i++) {
          dataSize += computeStringSizeNoTag(admissionReviewVersions_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAdmissionReviewVersionsList().size();
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, matchPolicy_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getObjectSelector());
      }
      for (int i = 0; i < matchConditions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, matchConditions_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasClientConfig() == other.hasClientConfig());
      if (hasClientConfig()) {
        result = result && getClientConfig()
            .equals(other.getClientConfig());
      }
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && (hasFailurePolicy() == other.hasFailurePolicy());
      if (hasFailurePolicy()) {
        result = result && getFailurePolicy()
            .equals(other.getFailurePolicy());
      }
      result = result && (hasMatchPolicy() == other.hasMatchPolicy());
      if (hasMatchPolicy()) {
        result = result && getMatchPolicy()
            .equals(other.getMatchPolicy());
      }
      result = result && (hasNamespaceSelector() == other.hasNamespaceSelector());
      if (hasNamespaceSelector()) {
        result = result && getNamespaceSelector()
            .equals(other.getNamespaceSelector());
      }
      result = result && (hasObjectSelector() == other.hasObjectSelector());
      if (hasObjectSelector()) {
        result = result && getObjectSelector()
            .equals(other.getObjectSelector());
      }
      result = result && (hasSideEffects() == other.hasSideEffects());
      if (hasSideEffects()) {
        result = result && getSideEffects()
            .equals(other.getSideEffects());
      }
      result = result && (hasTimeoutSeconds() == other.hasTimeoutSeconds());
      if (hasTimeoutSeconds()) {
        result = result && (getTimeoutSeconds()
            == other.getTimeoutSeconds());
      }
      result = result && getAdmissionReviewVersionsList()
          .equals(other.getAdmissionReviewVersionsList());
      result = result && getMatchConditionsList()
          .equals(other.getMatchConditionsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasClientConfig()) {
        hash = (37 * hash) + CLIENTCONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getClientConfig().hashCode();
      }
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      if (hasFailurePolicy()) {
        hash = (37 * hash) + FAILUREPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getFailurePolicy().hashCode();
      }
      if (hasMatchPolicy()) {
        hash = (37 * hash) + MATCHPOLICY_FIELD_NUMBER;
        hash = (53 * hash) + getMatchPolicy().hashCode();
      }
      if (hasNamespaceSelector()) {
        hash = (37 * hash) + NAMESPACESELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getNamespaceSelector().hashCode();
      }
      if (hasObjectSelector()) {
        hash = (37 * hash) + OBJECTSELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getObjectSelector().hashCode();
      }
      if (hasSideEffects()) {
        hash = (37 * hash) + SIDEEFFECTS_FIELD_NUMBER;
        hash = (53 * hash) + getSideEffects().hashCode();
      }
      if (hasTimeoutSeconds()) {
        hash = (37 * hash) + TIMEOUTSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getTimeoutSeconds();
      }
      if (getAdmissionReviewVersionsCount() > 0) {
        hash = (37 * hash) + ADMISSIONREVIEWVERSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAdmissionReviewVersionsList().hashCode();
      }
      if (getMatchConditionsCount() > 0) {
        hash = (37 * hash) + MATCHCONDITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMatchConditionsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingWebhook}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingWebhook)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getClientConfigFieldBuilder();
          getRulesFieldBuilder();
          getNamespaceSelectorFieldBuilder();
          getObjectSelectorFieldBuilder();
          getMatchConditionsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          rulesBuilder_.clear();
        }
        failurePolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        matchPolicy_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        sideEffects_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        timeoutSeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (clientConfigBuilder_ == null) {
          result.clientConfig_ = clientConfig_;
        } else {
          result.clientConfig_ = clientConfigBuilder_.build();
        }
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.failurePolicy_ = failurePolicy_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000008;
        }
        result.matchPolicy_ = matchPolicy_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        if (namespaceSelectorBuilder_ == null) {
          result.namespaceSelector_ = namespaceSelector_;
        } else {
          result.namespaceSelector_ = namespaceSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000020;
        }
        if (objectSelectorBuilder_ == null) {
          result.objectSelector_ = objectSelector_;
        } else {
          result.objectSelector_ = objectSelectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sideEffects_ = sideEffects_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000080;
        }
        result.timeoutSeconds_ = timeoutSeconds_;
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = admissionReviewVersions_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.admissionReviewVersions_ = admissionReviewVersions_;
        if (matchConditionsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) == 0x00000400)) {
            matchConditions_ = java.util.Collections.unmodifiableList(matchConditions_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.matchConditions_ = matchConditions_;
        } else {
          result.matchConditions_ = matchConditionsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasClientConfig()) {
          mergeClientConfig(other.getClientConfig());
        }
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000004);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        if (other.hasFailurePolicy()) {
          bitField0_ |= 0x00000008;
          failurePolicy_ = other.failurePolicy_;
          onChanged();
        }
        if (other.hasMatchPolicy()) {
          bitField0_ |= 0x00000010;
          matchPolicy_ = other.matchPolicy_;
          onChanged();
        }
        if (other.hasNamespaceSelector()) {
          mergeNamespaceSelector(other.getNamespaceSelector());
        }
        if (other.hasObjectSelector()) {
          mergeObjectSelector(other.getObjectSelector());
        }
        if (other.hasSideEffects()) {
          bitField0_ |= 0x00000080;
          sideEffects_ = other.sideEffects_;
          onChanged();
        }
        if (other.hasTimeoutSeconds()) {
          setTimeoutSeconds(other.getTimeoutSeconds());
        }
        if (!other.admissionReviewVersions_.isEmpty()) {
          if (admissionReviewVersions_.isEmpty()) {
            admissionReviewVersions_ = other.admissionReviewVersions_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureAdmissionReviewVersionsIsMutable();
            admissionReviewVersions_.addAll(other.admissionReviewVersions_);
          }
          onChanged();
        }
        if (matchConditionsBuilder_ == null) {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditions_.isEmpty()) {
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureMatchConditionsIsMutable();
              matchConditions_.addAll(other.matchConditions_);
            }
            onChanged();
          }
        } else {
          if (!other.matchConditions_.isEmpty()) {
            if (matchConditionsBuilder_.isEmpty()) {
              matchConditionsBuilder_.dispose();
              matchConditionsBuilder_ = null;
              matchConditions_ = other.matchConditions_;
              bitField0_ = (bitField0_ & ~0x00000400);
              matchConditionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMatchConditionsFieldBuilder() : null;
            } else {
              matchConditionsBuilder_.addAllMessages(other.matchConditions_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the admission webhook.
       * Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
       * "imagepolicy" is the name of the webhook, and kubernetes.io is the name
       * of the organization.
       * Required.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig clientConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder> clientConfigBuilder_;
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public boolean hasClientConfig() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getClientConfig() {
        if (clientConfigBuilder_ == null) {
          return clientConfig_ == null ? io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        } else {
          return clientConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientConfig_ = value;
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder setClientConfig(
          io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder builderForValue) {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = builderForValue.build();
          onChanged();
        } else {
          clientConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder mergeClientConfig(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig value) {
        if (clientConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              clientConfig_ != null &&
              clientConfig_ != io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance()) {
            clientConfig_ =
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.newBuilder(clientConfig_).mergeFrom(value).buildPartial();
          } else {
            clientConfig_ = value;
          }
          onChanged();
        } else {
          clientConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public Builder clearClientConfig() {
        if (clientConfigBuilder_ == null) {
          clientConfig_ = null;
          onChanged();
        } else {
          clientConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder getClientConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getClientConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder getClientConfigOrBuilder() {
        if (clientConfigBuilder_ != null) {
          return clientConfigBuilder_.getMessageOrBuilder();
        } else {
          return clientConfig_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance() : clientConfig_;
        }
      }
      /**
       * <pre>
       * ClientConfig defines how to communicate with the hook.
       * Required
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder> 
          getClientConfigFieldBuilder() {
        if (clientConfigBuilder_ == null) {
          clientConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder>(
                  getClientConfig(),
                  getParentForChildren(),
                  isClean());
          clientConfig_ = null;
        }
        return clientConfigBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          rules_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations>(rules_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder setRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addRules(
          int index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder addAllRules(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.getDefaultInstance());
      }
      /**
       * <pre>
       * Rules describes what operations on what resources/subresources the webhook cares about.
       * The webhook cares about an operation if it matches _any_ Rule.
       * However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
       * from putting the cluster in a state which cannot be recovered from without completely
       * disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
       * on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.RuleWithOperations rules = 3;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder> 
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder> 
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperations.Builder, io.kubernetes.client.proto.V1Admissionregistration.RuleWithOperationsOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }

      private java.lang.Object failurePolicy_ = "";
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public boolean hasFailurePolicy() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public java.lang.String getFailurePolicy() {
        java.lang.Object ref = failurePolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            failurePolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public com.google.protobuf.ByteString
          getFailurePolicyBytes() {
        java.lang.Object ref = failurePolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          failurePolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder clearFailurePolicy() {
        bitField0_ = (bitField0_ & ~0x00000008);
        failurePolicy_ = getDefaultInstance().getFailurePolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
       * allowed values are Ignore or Fail. Defaults to Fail.
       * +optional
       * </pre>
       *
       * <code>optional string failurePolicy = 4;</code>
       */
      public Builder setFailurePolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        failurePolicy_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object matchPolicy_ = "";
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public boolean hasMatchPolicy() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public java.lang.String getMatchPolicy() {
        java.lang.Object ref = matchPolicy_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            matchPolicy_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public com.google.protobuf.ByteString
          getMatchPolicyBytes() {
        java.lang.Object ref = matchPolicy_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          matchPolicy_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicy(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder clearMatchPolicy() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchPolicy_ = getDefaultInstance().getMatchPolicy();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * matchPolicy defines how the "rules" list is used to match incoming requests.
       * Allowed values are "Exact" or "Equivalent".
       * - Exact: match a request only if it exactly matches a specified rule.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
       * - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
       * For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
       * and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
       * a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
       * Defaults to "Equivalent"
       * +optional
       * </pre>
       *
       * <code>optional string matchPolicy = 9;</code>
       */
      public Builder setMatchPolicyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        matchPolicy_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector namespaceSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> namespaceSelectorBuilder_;
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public boolean hasNamespaceSelector() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          return namespaceSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        } else {
          return namespaceSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          namespaceSelector_ = value;
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder setNamespaceSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = builderForValue.build();
          onChanged();
        } else {
          namespaceSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder mergeNamespaceSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (namespaceSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020) &&
              namespaceSelector_ != null &&
              namespaceSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            namespaceSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(namespaceSelector_).mergeFrom(value).buildPartial();
          } else {
            namespaceSelector_ = value;
          }
          onChanged();
        } else {
          namespaceSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public Builder clearNamespaceSelector() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelector_ = null;
          onChanged();
        } else {
          namespaceSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getNamespaceSelectorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getNamespaceSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getNamespaceSelectorOrBuilder() {
        if (namespaceSelectorBuilder_ != null) {
          return namespaceSelectorBuilder_.getMessageOrBuilder();
        } else {
          return namespaceSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : namespaceSelector_;
        }
      }
      /**
       * <pre>
       * NamespaceSelector decides whether to run the webhook on an object based
       * on whether the namespace for that object matches the selector. If the
       * object itself is a namespace, the matching is performed on
       * object.metadata.labels. If the object is another cluster scoped resource,
       * it never skips the webhook.
       * For example, to run the webhook on any objects whose namespace is not
       * associated with "runlevel" of "0" or "1";  you will set the selector as
       * follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "runlevel",
       *       "operator": "NotIn",
       *       "values": [
       *         "0",
       *         "1"
       *       ]
       *     }
       *   ]
       * }
       * If instead you want to only run the webhook on any objects whose
       * namespace is associated with the "environment" of "prod" or "staging";
       * you will set the selector as follows:
       * "namespaceSelector": {
       *   "matchExpressions": [
       *     {
       *       "key": "environment",
       *       "operator": "In",
       *       "values": [
       *         "prod",
       *         "staging"
       *       ]
       *     }
       *   ]
       * }
       * See
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       * for more examples of label selectors.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getNamespaceSelectorFieldBuilder() {
        if (namespaceSelectorBuilder_ == null) {
          namespaceSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getNamespaceSelector(),
                  getParentForChildren(),
                  isClean());
          namespaceSelector_ = null;
        }
        return namespaceSelectorBuilder_;
      }

      private io.kubernetes.client.proto.Meta.LabelSelector objectSelector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> objectSelectorBuilder_;
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public boolean hasObjectSelector() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          return objectSelector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        } else {
          return objectSelectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder setObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectSelector_ = value;
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder setObjectSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = builderForValue.build();
          onChanged();
        } else {
          objectSelectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder mergeObjectSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (objectSelectorBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040) &&
              objectSelector_ != null &&
              objectSelector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            objectSelector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(objectSelector_).mergeFrom(value).buildPartial();
          } else {
            objectSelector_ = value;
          }
          onChanged();
        } else {
          objectSelectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public Builder clearObjectSelector() {
        if (objectSelectorBuilder_ == null) {
          objectSelector_ = null;
          onChanged();
        } else {
          objectSelectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getObjectSelectorBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getObjectSelectorOrBuilder() {
        if (objectSelectorBuilder_ != null) {
          return objectSelectorBuilder_.getMessageOrBuilder();
        } else {
          return objectSelector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : objectSelector_;
        }
      }
      /**
       * <pre>
       * ObjectSelector decides whether to run the webhook based on if the
       * object has matching labels. objectSelector is evaluated against both
       * the oldObject and newObject that would be sent to the webhook, and
       * is considered to match if either object matches the selector. A null
       * object (oldObject in the case of create, or newObject in the case of
       * delete) or an object that cannot have labels (like a
       * DeploymentRollback or a PodProxyOptions object) is not considered to
       * match.
       * Use the object selector only if the webhook is opt-in, because end
       * users may skip the admission webhook by setting the labels.
       * Default to the empty LabelSelector, which matches everything.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getObjectSelectorFieldBuilder() {
        if (objectSelectorBuilder_ == null) {
          objectSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getObjectSelector(),
                  getParentForChildren(),
                  isClean());
          objectSelector_ = null;
        }
        return objectSelectorBuilder_;
      }

      private java.lang.Object sideEffects_ = "";
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public boolean hasSideEffects() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public java.lang.String getSideEffects() {
        java.lang.Object ref = sideEffects_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sideEffects_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public com.google.protobuf.ByteString
          getSideEffectsBytes() {
        java.lang.Object ref = sideEffects_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sideEffects_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffects(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder clearSideEffects() {
        bitField0_ = (bitField0_ & ~0x00000080);
        sideEffects_ = getDefaultInstance().getSideEffects();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SideEffects states whether this webhook has side effects.
       * Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
       * Webhooks with side effects MUST implement a reconciliation system, since a request may be
       * rejected by a future step in the admission chain and the side effects therefore need to be undone.
       * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
       * sideEffects == Unknown or Some.
       * </pre>
       *
       * <code>optional string sideEffects = 6;</code>
       */
      public Builder setSideEffectsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        sideEffects_ = value;
        onChanged();
        return this;
      }

      private int timeoutSeconds_ ;
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public boolean hasTimeoutSeconds() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public int getTimeoutSeconds() {
        return timeoutSeconds_;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder setTimeoutSeconds(int value) {
        bitField0_ |= 0x00000100;
        timeoutSeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
       * the webhook call will be ignored or the API call will fail based on the
       * failure policy.
       * The timeout value must be between 1 and 30 seconds.
       * Default to 10 seconds.
       * +optional
       * </pre>
       *
       * <code>optional int32 timeoutSeconds = 7;</code>
       */
      public Builder clearTimeoutSeconds() {
        bitField0_ = (bitField0_ & ~0x00000100);
        timeoutSeconds_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAdmissionReviewVersionsIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          admissionReviewVersions_ = new com.google.protobuf.LazyStringArrayList(admissionReviewVersions_);
          bitField0_ |= 0x00000200;
         }
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getAdmissionReviewVersionsList() {
        return admissionReviewVersions_.getUnmodifiableView();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public int getAdmissionReviewVersionsCount() {
        return admissionReviewVersions_.size();
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public java.lang.String getAdmissionReviewVersions(int index) {
        return admissionReviewVersions_.get(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public com.google.protobuf.ByteString
          getAdmissionReviewVersionsBytes(int index) {
        return admissionReviewVersions_.getByteString(index);
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder setAdmissionReviewVersions(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersions(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAllAdmissionReviewVersions(
          java.lang.Iterable<java.lang.String> values) {
        ensureAdmissionReviewVersionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, admissionReviewVersions_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder clearAdmissionReviewVersions() {
        admissionReviewVersions_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
       * versions the Webhook expects. API server will try to use first version in
       * the list which it supports. If none of the versions specified in this list
       * supported by API server, validation will fail for this object.
       * If a persisted webhook configuration specifies allowed versions and does not
       * include any versions known to the API Server, calls to the webhook will fail
       * and be subject to the failure policy.
       * +listType=atomic
       * </pre>
       *
       * <code>repeated string admissionReviewVersions = 8;</code>
       */
      public Builder addAdmissionReviewVersionsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAdmissionReviewVersionsIsMutable();
        admissionReviewVersions_.add(value);
        onChanged();
        return this;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> matchConditions_ =
        java.util.Collections.emptyList();
      private void ensureMatchConditionsIsMutable() {
        if (!((bitField0_ & 0x00000400) == 0x00000400)) {
          matchConditions_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition>(matchConditions_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> matchConditionsBuilder_;

      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> getMatchConditionsList() {
        if (matchConditionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(matchConditions_);
        } else {
          return matchConditionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public int getMatchConditionsCount() {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.size();
        } else {
          return matchConditionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition getMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);
        } else {
          return matchConditionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder setMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.set(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition value) {
        if (matchConditionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, value);
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addMatchConditions(
          int index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder builderForValue) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.add(index, builderForValue.build());
          onChanged();
        } else {
          matchConditionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder addAllMatchConditions(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchCondition> values) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, matchConditions_);
          onChanged();
        } else {
          matchConditionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder clearMatchConditions() {
        if (matchConditionsBuilder_ == null) {
          matchConditions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          matchConditionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public Builder removeMatchConditions(int index) {
        if (matchConditionsBuilder_ == null) {
          ensureMatchConditionsIsMutable();
          matchConditions_.remove(index);
          onChanged();
        } else {
          matchConditionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder getMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder getMatchConditionsOrBuilder(
          int index) {
        if (matchConditionsBuilder_ == null) {
          return matchConditions_.get(index);  } else {
          return matchConditionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
           getMatchConditionsOrBuilderList() {
        if (matchConditionsBuilder_ != null) {
          return matchConditionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(matchConditions_);
        }
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder() {
        return getMatchConditionsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder addMatchConditionsBuilder(
          int index) {
        return getMatchConditionsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.getDefaultInstance());
      }
      /**
       * <pre>
       * MatchConditions is a list of conditions that must be met for a request to be sent to this
       * webhook. Match conditions filter requests that have already been matched by the rules,
       * namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
       * There are a maximum of 64 match conditions allowed.
       * The exact matching logic is (in order):
       *   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
       *   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
       *   3. If any matchCondition evaluates to an error (but none are FALSE):
       *      - If failurePolicy=Fail, reject the request
       *      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * +optional
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.MatchCondition matchConditions = 11;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder> 
           getMatchConditionsBuilderList() {
        return getMatchConditionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder> 
          getMatchConditionsFieldBuilder() {
        if (matchConditionsBuilder_ == null) {
          matchConditionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.MatchCondition, io.kubernetes.client.proto.V1Admissionregistration.MatchCondition.Builder, io.kubernetes.client.proto.V1Admissionregistration.MatchConditionOrBuilder>(
                  matchConditions_,
                  ((bitField0_ & 0x00000400) == 0x00000400),
                  getParentForChildren(),
                  isClean());
          matchConditions_ = null;
        }
        return matchConditionsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingWebhook)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingWebhook)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingWebhook>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhook>() {
      @java.lang.Override
      public ValidatingWebhook parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingWebhook(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhook> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhook> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookConfigurationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook> 
        getWebhooksList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook getWebhooks(int index);
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    int getWebhooksCount();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder> 
        getWebhooksOrBuilderList();
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration}
   */
  public  static final class ValidatingWebhookConfiguration extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration)
      ValidatingWebhookConfigurationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingWebhookConfiguration.newBuilder() to construct.
    private ValidatingWebhookConfiguration(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhookConfiguration() {
      webhooks_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingWebhookConfiguration(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook>();
                mutable_bitField0_ |= 0x00000002;
              }
              webhooks_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int WEBHOOKS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook> webhooks_;
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook> getWebhooksList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder> 
        getWebhooksOrBuilderList() {
      return webhooks_;
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    public int getWebhooksCount() {
      return webhooks_.size();
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook getWebhooks(int index) {
      return webhooks_.get(index);
    }
    /**
     * <pre>
     * Webhooks is a list of webhooks and the affected resources and operations.
     * +optional
     * +patchMergeKey=name
     * +patchStrategy=merge
     * +listType=map
     * +listMapKey=name
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
        int index) {
      return webhooks_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        output.writeMessage(2, webhooks_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < webhooks_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, webhooks_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getWebhooksList()
          .equals(other.getWebhooksList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getWebhooksCount() > 0) {
        hash = (37 * hash) + WEBHOOKS_FIELD_NUMBER;
        hash = (53 * hash) + getWebhooksList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getWebhooksFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (webhooksBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            webhooks_ = java.util.Collections.unmodifiableList(webhooks_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.webhooks_ = webhooks_;
        } else {
          result.webhooks_ = webhooksBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (webhooksBuilder_ == null) {
          if (!other.webhooks_.isEmpty()) {
            if (webhooks_.isEmpty()) {
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureWebhooksIsMutable();
              webhooks_.addAll(other.webhooks_);
            }
            onChanged();
          }
        } else {
          if (!other.webhooks_.isEmpty()) {
            if (webhooksBuilder_.isEmpty()) {
              webhooksBuilder_.dispose();
              webhooksBuilder_ = null;
              webhooks_ = other.webhooks_;
              bitField0_ = (bitField0_ & ~0x00000002);
              webhooksBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getWebhooksFieldBuilder() : null;
            } else {
              webhooksBuilder_.addAllMessages(other.webhooks_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook> webhooks_ =
        java.util.Collections.emptyList();
      private void ensureWebhooksIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          webhooks_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook>(webhooks_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder> webhooksBuilder_;

      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook> getWebhooksList() {
        if (webhooksBuilder_ == null) {
          return java.util.Collections.unmodifiableList(webhooks_);
        } else {
          return webhooksBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public int getWebhooksCount() {
        if (webhooksBuilder_ == null) {
          return webhooks_.size();
        } else {
          return webhooksBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook getWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);
        } else {
          return webhooksBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.set(index, value);
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder setWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.set(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook value) {
        if (webhooksBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureWebhooksIsMutable();
          webhooks_.add(index, value);
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addWebhooks(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder builderForValue) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.add(index, builderForValue.build());
          onChanged();
        } else {
          webhooksBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder addAllWebhooks(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook> values) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, webhooks_);
          onChanged();
        } else {
          webhooksBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder clearWebhooks() {
        if (webhooksBuilder_ == null) {
          webhooks_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          webhooksBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public Builder removeWebhooks(int index) {
        if (webhooksBuilder_ == null) {
          ensureWebhooksIsMutable();
          webhooks_.remove(index);
          onChanged();
        } else {
          webhooksBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder getWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder getWebhooksOrBuilder(
          int index) {
        if (webhooksBuilder_ == null) {
          return webhooks_.get(index);  } else {
          return webhooksBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder> 
           getWebhooksOrBuilderList() {
        if (webhooksBuilder_ != null) {
          return webhooksBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(webhooks_);
        }
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder addWebhooksBuilder() {
        return getWebhooksFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder addWebhooksBuilder(
          int index) {
        return getWebhooksFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.getDefaultInstance());
      }
      /**
       * <pre>
       * Webhooks is a list of webhooks and the affected resources and operations.
       * +optional
       * +patchMergeKey=name
       * +patchStrategy=merge
       * +listType=map
       * +listMapKey=name
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder> 
           getWebhooksBuilderList() {
        return getWebhooksFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder> 
          getWebhooksFieldBuilder() {
        if (webhooksBuilder_ == null) {
          webhooksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhook.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookOrBuilder>(
                  webhooks_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          webhooks_ = null;
        }
        return webhooksBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingWebhookConfiguration>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhookConfiguration>() {
      @java.lang.Override
      public ValidatingWebhookConfiguration parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingWebhookConfiguration(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhookConfiguration> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhookConfiguration> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidatingWebhookConfigurationListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration> 
        getItemsList();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration getItems(int index);
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList}
   */
  public  static final class ValidatingWebhookConfigurationList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList)
      ValidatingWebhookConfigurationListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidatingWebhookConfigurationList.newBuilder() to construct.
    private ValidatingWebhookConfigurationList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidatingWebhookConfigurationList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidatingWebhookConfigurationList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration> items_;
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * List of ValidatingWebhookConfiguration.
     * </pre>
     *
     * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList other = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList)
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.class, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList build() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList result = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.getDefaultInstance());
      }
      /**
       * <pre>
       * List of ValidatingWebhookConfiguration.
       * </pre>
       *
       * <code>repeated .k8s.io.api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfiguration.Builder, io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.ValidatingWebhookConfigurationList)
    private static final io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ValidatingWebhookConfigurationList>
        PARSER = new com.google.protobuf.AbstractParser<ValidatingWebhookConfigurationList>() {
      @java.lang.Override
      public ValidatingWebhookConfigurationList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidatingWebhookConfigurationList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidatingWebhookConfigurationList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidatingWebhookConfigurationList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.ValidatingWebhookConfigurationList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.Validation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();

    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    boolean hasMessage();
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    boolean hasReason();
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    java.lang.String getReason();
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    com.google.protobuf.ByteString
        getReasonBytes();

    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    boolean hasMessageExpression();
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    java.lang.String getMessageExpression();
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    com.google.protobuf.ByteString
        getMessageExpressionBytes();
  }
  /**
   * <pre>
   * Validation specifies the CEL expression which is used to apply the validation.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.Validation}
   */
  public  static final class Validation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.Validation)
      ValidationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Validation.newBuilder() to construct.
    private Validation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Validation() {
      expression_ = "";
      message_ = "";
      reason_ = "";
      messageExpression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Validation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              expression_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              message_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              reason_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              messageExpression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Validation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Validation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.Validation.class, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder.class);
    }

    private int bitField0_;
    public static final int EXPRESSION_FIELD_NUMBER = 1;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression represents the expression which will be evaluated by CEL.
     * ref: https://github.com/google/cel-spec
     * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
     * - 'object' - The object from the incoming request. The value is null for DELETE requests.
     * - 'oldObject' - The existing object. The value is null for CREATE requests.
     * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
     * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
     * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
     * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
     *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
     * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
     *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
     * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
     *   request resource.
     * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
     * object. No other metadata properties are accessible.
     * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
     * Accessible property names are escaped according to the following rules when accessed in the expression:
     * - '__' escapes to '__underscores__'
     * - '.' escapes to '__dot__'
     * - '-' escapes to '__dash__'
     * - '/' escapes to '__slash__'
     * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
     * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
     * 	  "import", "let", "loop", "package", "namespace", "return".
     * Examples:
     *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
     *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
     *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
     * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
     * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
     *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
     *     non-intersecting elements in `Y` are appended, retaining their partial order.
     *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
     *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
     *     non-intersecting keys are appended, retaining their partial order.
     * Required.
     * </pre>
     *
     * <code>optional string Expression = 1;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    private volatile java.lang.Object message_;
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Message represents the message displayed when validation fails. The message is required if the Expression contains
     * line breaks. The message must not contain line breaks.
     * If unset, the message is "failed rule: {Rule}".
     * e.g. "must be a URL with the host matching spec.host"
     * If the Expression contains line breaks. Message is required.
     * The message must not contain line breaks.
     * If unset, the message is "failed Expression: {Expression}".
     * +optional
     * </pre>
     *
     * <code>optional string message = 2;</code>
     */
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REASON_FIELD_NUMBER = 3;
    private volatile java.lang.Object reason_;
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    public boolean hasReason() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    public java.lang.String getReason() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          reason_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Reason represents a machine-readable description of why this validation failed.
     * If this is the first validation in the list to fail, this reason, as well as the
     * corresponding HTTP response code, are used in the
     * HTTP response to the client.
     * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
     * If not set, StatusReasonInvalid is used in the response to the client.
     * +optional
     * </pre>
     *
     * <code>optional string reason = 3;</code>
     */
    public com.google.protobuf.ByteString
        getReasonBytes() {
      java.lang.Object ref = reason_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reason_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MESSAGEEXPRESSION_FIELD_NUMBER = 4;
    private volatile java.lang.Object messageExpression_;
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    public boolean hasMessageExpression() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    public java.lang.String getMessageExpression() {
      java.lang.Object ref = messageExpression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          messageExpression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
     * Since messageExpression is used as a failure message, it must evaluate to a string.
     * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
     * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
     * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
     * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
     * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
     * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
     * Example:
     * "object.x must be less than max ("+string(params.max)+")"
     * +optional
     * </pre>
     *
     * <code>optional string messageExpression = 4;</code>
     */
    public com.google.protobuf.ByteString
        getMessageExpressionBytes() {
      java.lang.Object ref = messageExpression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        messageExpression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, expression_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, reason_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, messageExpression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, expression_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, reason_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, messageExpression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.Validation)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.Validation other = (io.kubernetes.client.proto.V1Admissionregistration.Validation) obj;

      boolean result = true;
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && (hasMessage() == other.hasMessage());
      if (hasMessage()) {
        result = result && getMessage()
            .equals(other.getMessage());
      }
      result = result && (hasReason() == other.hasReason());
      if (hasReason()) {
        result = result && getReason()
            .equals(other.getReason());
      }
      result = result && (hasMessageExpression() == other.hasMessageExpression());
      if (hasMessageExpression()) {
        result = result && getMessageExpression()
            .equals(other.getMessageExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      if (hasMessage()) {
        hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getMessage().hashCode();
      }
      if (hasReason()) {
        hash = (37 * hash) + REASON_FIELD_NUMBER;
        hash = (53 * hash) + getReason().hashCode();
      }
      if (hasMessageExpression()) {
        hash = (37 * hash) + MESSAGEEXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getMessageExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Validation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.Validation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Validation specifies the CEL expression which is used to apply the validation.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.Validation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.Validation)
        io.kubernetes.client.proto.V1Admissionregistration.ValidationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Validation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Validation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.Validation.class, io.kubernetes.client.proto.V1Admissionregistration.Validation.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.Validation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        reason_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        messageExpression_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Validation_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Validation getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.Validation.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Validation build() {
        io.kubernetes.client.proto.V1Admissionregistration.Validation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Validation buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.Validation result = new io.kubernetes.client.proto.V1Admissionregistration.Validation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.expression_ = expression_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.message_ = message_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.reason_ = reason_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.messageExpression_ = messageExpression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.Validation) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.Validation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.Validation other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.Validation.getDefaultInstance()) return this;
        if (other.hasExpression()) {
          bitField0_ |= 0x00000001;
          expression_ = other.expression_;
          onChanged();
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000002;
          message_ = other.message_;
          onChanged();
        }
        if (other.hasReason()) {
          bitField0_ |= 0x00000004;
          reason_ = other.reason_;
          onChanged();
        }
        if (other.hasMessageExpression()) {
          bitField0_ |= 0x00000008;
          messageExpression_ = other.messageExpression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.Validation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.Validation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression represents the expression which will be evaluated by CEL.
       * ref: https://github.com/google/cel-spec
       * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
       * - 'object' - The object from the incoming request. The value is null for DELETE requests.
       * - 'oldObject' - The existing object. The value is null for CREATE requests.
       * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
       * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
       * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
       * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
       *   For example, a variable named 'foo' can be accessed as 'variables.foo'.
       * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
       *   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
       * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
       *   request resource.
       * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
       * object. No other metadata properties are accessible.
       * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
       * Accessible property names are escaped according to the following rules when accessed in the expression:
       * - '__' escapes to '__underscores__'
       * - '.' escapes to '__dot__'
       * - '-' escapes to '__dash__'
       * - '/' escapes to '__slash__'
       * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
       * 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
       * 	  "import", "let", "loop", "package", "namespace", "return".
       * Examples:
       *   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ &gt; 0"}
       *   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop &gt; 0"}
       *   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d &gt; 0"}
       * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
       * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
       *   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
       *     non-intersecting elements in `Y` are appended, retaining their partial order.
       *   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
       *     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
       *     non-intersecting keys are appended, retaining their partial order.
       * Required.
       * </pre>
       *
       * <code>optional string Expression = 1;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        expression_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            message_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000002);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message represents the message displayed when validation fails. The message is required if the Expression contains
       * line breaks. The message must not contain line breaks.
       * If unset, the message is "failed rule: {Rule}".
       * e.g. "must be a URL with the host matching spec.host"
       * If the Expression contains line breaks. Message is required.
       * The message must not contain line breaks.
       * If unset, the message is "failed Expression: {Expression}".
       * +optional
       * </pre>
       *
       * <code>optional string message = 2;</code>
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        message_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object reason_ = "";
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public boolean hasReason() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public java.lang.String getReason() {
        java.lang.Object ref = reason_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            reason_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public com.google.protobuf.ByteString
          getReasonBytes() {
        java.lang.Object ref = reason_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          reason_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public Builder setReason(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        reason_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public Builder clearReason() {
        bitField0_ = (bitField0_ & ~0x00000004);
        reason_ = getDefaultInstance().getReason();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reason represents a machine-readable description of why this validation failed.
       * If this is the first validation in the list to fail, this reason, as well as the
       * corresponding HTTP response code, are used in the
       * HTTP response to the client.
       * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
       * If not set, StatusReasonInvalid is used in the response to the client.
       * +optional
       * </pre>
       *
       * <code>optional string reason = 3;</code>
       */
      public Builder setReasonBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        reason_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object messageExpression_ = "";
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public boolean hasMessageExpression() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public java.lang.String getMessageExpression() {
        java.lang.Object ref = messageExpression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            messageExpression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public com.google.protobuf.ByteString
          getMessageExpressionBytes() {
        java.lang.Object ref = messageExpression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          messageExpression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public Builder setMessageExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        messageExpression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public Builder clearMessageExpression() {
        bitField0_ = (bitField0_ & ~0x00000008);
        messageExpression_ = getDefaultInstance().getMessageExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
       * Since messageExpression is used as a failure message, it must evaluate to a string.
       * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
       * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
       * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
       * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
       * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
       * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
       * Example:
       * "object.x must be less than max ("+string(params.max)+")"
       * +optional
       * </pre>
       *
       * <code>optional string messageExpression = 4;</code>
       */
      public Builder setMessageExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        messageExpression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.Validation)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.Validation)
    private static final io.kubernetes.client.proto.V1Admissionregistration.Validation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.Validation();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.Validation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Validation>
        PARSER = new com.google.protobuf.AbstractParser<Validation>() {
      @java.lang.Override
      public Validation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Validation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Validation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Validation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.Validation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VariableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.Variable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    boolean hasName();
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    boolean hasExpression();
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    java.lang.String getExpression();
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    com.google.protobuf.ByteString
        getExpressionBytes();
  }
  /**
   * <pre>
   * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
   * +structType=atomic
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.Variable}
   */
  public  static final class Variable extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.Variable)
      VariableOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Variable.newBuilder() to construct.
    private Variable(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Variable() {
      name_ = "";
      expression_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Variable(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              expression_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Variable_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Variable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.Variable.class, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
     * The variable can be accessed in other expressions through `variables`
     * For example, if name is "foo", the variable will be available as `variables.foo`
     * </pre>
     *
     * <code>optional string Name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EXPRESSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object expression_;
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    public boolean hasExpression() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    public java.lang.String getExpression() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          expression_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Expression is the expression that will be evaluated as the value of the variable.
     * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
     * </pre>
     *
     * <code>optional string Expression = 2;</code>
     */
    public com.google.protobuf.ByteString
        getExpressionBytes() {
      java.lang.Object ref = expression_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        expression_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, expression_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, expression_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.Variable)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.Variable other = (io.kubernetes.client.proto.V1Admissionregistration.Variable) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasExpression() == other.hasExpression());
      if (hasExpression()) {
        result = result && getExpression()
            .equals(other.getExpression());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasExpression()) {
        hash = (37 * hash) + EXPRESSION_FIELD_NUMBER;
        hash = (53 * hash) + getExpression().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.Variable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.Variable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
     * +structType=atomic
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.Variable}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.Variable)
        io.kubernetes.client.proto.V1Admissionregistration.VariableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Variable_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Variable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.Variable.class, io.kubernetes.client.proto.V1Admissionregistration.Variable.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.Variable.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        expression_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_Variable_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Variable getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.Variable.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Variable build() {
        io.kubernetes.client.proto.V1Admissionregistration.Variable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.Variable buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.Variable result = new io.kubernetes.client.proto.V1Admissionregistration.Variable(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.expression_ = expression_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.Variable) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.Variable)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.Variable other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.Variable.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasExpression()) {
          bitField0_ |= 0x00000002;
          expression_ = other.expression_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.Variable parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.Variable) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
       * The variable can be accessed in other expressions through `variables`
       * For example, if name is "foo", the variable will be available as `variables.foo`
       * </pre>
       *
       * <code>optional string Name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object expression_ = "";
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public boolean hasExpression() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public java.lang.String getExpression() {
        java.lang.Object ref = expression_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            expression_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public com.google.protobuf.ByteString
          getExpressionBytes() {
        java.lang.Object ref = expression_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          expression_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public Builder setExpression(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public Builder clearExpression() {
        bitField0_ = (bitField0_ & ~0x00000002);
        expression_ = getDefaultInstance().getExpression();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expression is the expression that will be evaluated as the value of the variable.
       * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
       * </pre>
       *
       * <code>optional string Expression = 2;</code>
       */
      public Builder setExpressionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        expression_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.Variable)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.Variable)
    private static final io.kubernetes.client.proto.V1Admissionregistration.Variable DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.Variable();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.Variable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Variable>
        PARSER = new com.google.protobuf.AbstractParser<Variable>() {
      @java.lang.Override
      public Variable parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Variable(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Variable> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Variable> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.Variable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface WebhookClientConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.admissionregistration.v1.WebhookClientConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    boolean hasUrl();
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    java.lang.String getUrl();
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    com.google.protobuf.ByteString
        getUrlBytes();

    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
     */
    boolean hasService();
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ServiceReference getService();
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
     */
    io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder();

    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    boolean hasCaBundle();
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    com.google.protobuf.ByteString getCaBundle();
  }
  /**
   * <pre>
   * WebhookClientConfig contains the information to make a TLS
   * connection with the webhook
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.admissionregistration.v1.WebhookClientConfig}
   */
  public  static final class WebhookClientConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.admissionregistration.v1.WebhookClientConfig)
      WebhookClientConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use WebhookClientConfig.newBuilder() to construct.
    private WebhookClientConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private WebhookClientConfig() {
      url_ = "";
      caBundle_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private WebhookClientConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = service_.toBuilder();
              }
              service_ = input.readMessage(io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(service_);
                service_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 18: {
              bitField0_ |= 0x00000004;
              caBundle_ = input.readBytes();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              url_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.class, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder.class);
    }

    private int bitField0_;
    public static final int URL_FIELD_NUMBER = 3;
    private volatile java.lang.Object url_;
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    public java.lang.String getUrl() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          url_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * `url` gives the location of the webhook, in standard URL form
     * (`scheme://host:port/path`). Exactly one of `url` or `service`
     * must be specified.
     * The `host` should not refer to a service running in the cluster; use
     * the `service` field instead. The host might be resolved via external
     * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
     * in-cluster DNS as that would be a layering violation). `host` may
     * also be an IP address.
     * Please note that using `localhost` or `127.0.0.1` as a `host` is
     * risky unless you take great care to run this webhook on all hosts
     * which run an apiserver which might need to make calls to this
     * webhook. Such installs are likely to be non-portable, i.e., not easy
     * to turn up in a new cluster.
     * The scheme must be "https"; the URL must begin with "https://".
     * A path is optional, and if present may be any string permissible in
     * a URL. You may use the path to pass an arbitrary string to the
     * webhook, for example, a cluster identifier.
     * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
     * allowed. Fragments ("#...") and query parameters ("?...") are not
     * allowed, either.
     * +optional
     * </pre>
     *
     * <code>optional string url = 3;</code>
     */
    public com.google.protobuf.ByteString
        getUrlBytes() {
      java.lang.Object ref = url_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        url_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVICE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.V1Admissionregistration.ServiceReference service_;
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
     */
    public boolean hasService() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference getService() {
      return service_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
    }
    /**
     * <pre>
     * `service` is a reference to the service for this webhook. Either
     * `service` or `url` must be specified.
     * If the webhook is running within the cluster, then you should use `service`.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
     */
    public io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder() {
      return service_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
    }

    public static final int CABUNDLE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString caBundle_;
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    public boolean hasCaBundle() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
     * If unspecified, system trust roots on the apiserver are used.
     * +optional
     * </pre>
     *
     * <code>optional bytes caBundle = 2;</code>
     */
    public com.google.protobuf.ByteString getCaBundle() {
      return caBundle_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(1, getService());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(2, caBundle_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, url_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getService());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, caBundle_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, url_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig other = (io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig) obj;

      boolean result = true;
      result = result && (hasUrl() == other.hasUrl());
      if (hasUrl()) {
        result = result && getUrl()
            .equals(other.getUrl());
      }
      result = result && (hasService() == other.hasService());
      if (hasService()) {
        result = result && getService()
            .equals(other.getService());
      }
      result = result && (hasCaBundle() == other.hasCaBundle());
      if (hasCaBundle()) {
        result = result && getCaBundle()
            .equals(other.getCaBundle());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasUrl()) {
        hash = (37 * hash) + URL_FIELD_NUMBER;
        hash = (53 * hash) + getUrl().hashCode();
      }
      if (hasService()) {
        hash = (37 * hash) + SERVICE_FIELD_NUMBER;
        hash = (53 * hash) + getService().hashCode();
      }
      if (hasCaBundle()) {
        hash = (37 * hash) + CABUNDLE_FIELD_NUMBER;
        hash = (53 * hash) + getCaBundle().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * WebhookClientConfig contains the information to make a TLS
     * connection with the webhook
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.admissionregistration.v1.WebhookClientConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.admissionregistration.v1.WebhookClientConfig)
        io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.class, io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getServiceFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        url_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (serviceBuilder_ == null) {
          service_ = null;
        } else {
          serviceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        caBundle_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_descriptor;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig build() {
        io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig buildPartial() {
        io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig result = new io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.url_ = url_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (serviceBuilder_ == null) {
          result.service_ = service_;
        } else {
          result.service_ = serviceBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.caBundle_ = caBundle_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig) {
          return mergeFrom((io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig other) {
        if (other == io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig.getDefaultInstance()) return this;
        if (other.hasUrl()) {
          bitField0_ |= 0x00000001;
          url_ = other.url_;
          onChanged();
        }
        if (other.hasService()) {
          mergeService(other.getService());
        }
        if (other.hasCaBundle()) {
          setCaBundle(other.getCaBundle());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object url_ = "";
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public boolean hasUrl() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public java.lang.String getUrl() {
        java.lang.Object ref = url_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            url_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public com.google.protobuf.ByteString
          getUrlBytes() {
        java.lang.Object ref = url_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          url_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public Builder setUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        url_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public Builder clearUrl() {
        bitField0_ = (bitField0_ & ~0x00000001);
        url_ = getDefaultInstance().getUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `url` gives the location of the webhook, in standard URL form
       * (`scheme://host:port/path`). Exactly one of `url` or `service`
       * must be specified.
       * The `host` should not refer to a service running in the cluster; use
       * the `service` field instead. The host might be resolved via external
       * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
       * in-cluster DNS as that would be a layering violation). `host` may
       * also be an IP address.
       * Please note that using `localhost` or `127.0.0.1` as a `host` is
       * risky unless you take great care to run this webhook on all hosts
       * which run an apiserver which might need to make calls to this
       * webhook. Such installs are likely to be non-portable, i.e., not easy
       * to turn up in a new cluster.
       * The scheme must be "https"; the URL must begin with "https://".
       * A path is optional, and if present may be any string permissible in
       * a URL. You may use the path to pass an arbitrary string to the
       * webhook, for example, a cluster identifier.
       * Attempting to use a user or basic auth e.g. "user:password&#64;" is not
       * allowed. Fragments ("#...") and query parameters ("?...") are not
       * allowed, either.
       * +optional
       * </pre>
       *
       * <code>optional string url = 3;</code>
       */
      public Builder setUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        url_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Admissionregistration.ServiceReference service_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder> serviceBuilder_;
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public boolean hasService() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference getService() {
        if (serviceBuilder_ == null) {
          return service_ == null ? io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
        } else {
          return serviceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public Builder setService(io.kubernetes.client.proto.V1Admissionregistration.ServiceReference value) {
        if (serviceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          service_ = value;
          onChanged();
        } else {
          serviceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public Builder setService(
          io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder builderForValue) {
        if (serviceBuilder_ == null) {
          service_ = builderForValue.build();
          onChanged();
        } else {
          serviceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public Builder mergeService(io.kubernetes.client.proto.V1Admissionregistration.ServiceReference value) {
        if (serviceBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              service_ != null &&
              service_ != io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance()) {
            service_ =
              io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.newBuilder(service_).mergeFrom(value).buildPartial();
          } else {
            service_ = value;
          }
          onChanged();
        } else {
          serviceBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public Builder clearService() {
        if (serviceBuilder_ == null) {
          service_ = null;
          onChanged();
        } else {
          serviceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder getServiceBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getServiceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      public io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder getServiceOrBuilder() {
        if (serviceBuilder_ != null) {
          return serviceBuilder_.getMessageOrBuilder();
        } else {
          return service_ == null ?
              io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.getDefaultInstance() : service_;
        }
      }
      /**
       * <pre>
       * `service` is a reference to the service for this webhook. Either
       * `service` or `url` must be specified.
       * If the webhook is running within the cluster, then you should use `service`.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.admissionregistration.v1.ServiceReference service = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder> 
          getServiceFieldBuilder() {
        if (serviceBuilder_ == null) {
          serviceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Admissionregistration.ServiceReference, io.kubernetes.client.proto.V1Admissionregistration.ServiceReference.Builder, io.kubernetes.client.proto.V1Admissionregistration.ServiceReferenceOrBuilder>(
                  getService(),
                  getParentForChildren(),
                  isClean());
          service_ = null;
        }
        return serviceBuilder_;
      }

      private com.google.protobuf.ByteString caBundle_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public boolean hasCaBundle() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public com.google.protobuf.ByteString getCaBundle() {
        return caBundle_;
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public Builder setCaBundle(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        caBundle_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
       * If unspecified, system trust roots on the apiserver are used.
       * +optional
       * </pre>
       *
       * <code>optional bytes caBundle = 2;</code>
       */
      public Builder clearCaBundle() {
        bitField0_ = (bitField0_ & ~0x00000004);
        caBundle_ = getDefaultInstance().getCaBundle();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.admissionregistration.v1.WebhookClientConfig)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.admissionregistration.v1.WebhookClientConfig)
    private static final io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig();
    }

    public static io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<WebhookClientConfig>
        PARSER = new com.google.protobuf.AbstractParser<WebhookClientConfig>() {
      @java.lang.Override
      public WebhookClientConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new WebhookClientConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<WebhookClientConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<WebhookClientConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.kubernetes.client.proto.V1Admissionregistration.WebhookClientConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_MatchResources_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_MatchResources_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ParamKind_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ParamKind_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ParamRef_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ParamRef_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_Rule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_Rule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_Validation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_Validation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_Variable_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_Variable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n3k8s.io/api/admissionregistration/v1/ge" +
      "nerated.proto\022#k8s.io.api.admissionregis" +
      "tration.v1\0324k8s.io/apimachinery/pkg/apis" +
      "/meta/v1/generated.proto\032/k8s.io/apimach" +
      "inery/pkg/runtime/generated.proto\0326k8s.i" +
      "o/apimachinery/pkg/runtime/schema/genera" +
      "ted.proto\"7\n\017AuditAnnotation\022\013\n\003key\030\001 \001(" +
      "\t\022\027\n\017valueExpression\030\002 \001(\t\"6\n\021Expression" +
      "Warning\022\020\n\010fieldRef\030\002 \001(\t\022\017\n\007warning\030\003 \001" +
      "(\t\"2\n\016MatchCondition\022\014\n\004name\030\001 \001(\t\022\022\n\nex" +
      "pression\030\002 \001(\t\"\363\002\n\016MatchResources\022N\n\021nam" +
      "espaceSelector\030\001 \001(\01323.k8s.io.apimachine" +
      "ry.pkg.apis.meta.v1.LabelSelector\022K\n\016obj" +
      "ectSelector\030\002 \001(\01323.k8s.io.apimachinery." +
      "pkg.apis.meta.v1.LabelSelector\022S\n\rresour" +
      "ceRules\030\003 \003(\0132<.k8s.io.api.admissionregi" +
      "stration.v1.NamedRuleWithOperations\022Z\n\024e" +
      "xcludeResourceRules\030\004 \003(\0132<.k8s.io.api.a" +
      "dmissionregistration.v1.NamedRuleWithOpe" +
      "rations\022\023\n\013matchPolicy\030\007 \001(\t\"\270\004\n\017Mutatin" +
      "gWebhook\022\014\n\004name\030\001 \001(\t\022N\n\014clientConfig\030\002" +
      " \001(\01328.k8s.io.api.admissionregistration." +
      "v1.WebhookClientConfig\022F\n\005rules\030\003 \003(\01327." +
      "k8s.io.api.admissionregistration.v1.Rule" +
      "WithOperations\022\025\n\rfailurePolicy\030\004 \001(\t\022\023\n" +
      "\013matchPolicy\030\t \001(\t\022N\n\021namespaceSelector\030" +
      "\005 \001(\01323.k8s.io.apimachinery.pkg.apis.met" +
      "a.v1.LabelSelector\022K\n\016objectSelector\030\013 \001" +
      "(\01323.k8s.io.apimachinery.pkg.apis.meta.v" +
      "1.LabelSelector\022\023\n\013sideEffects\030\006 \001(\t\022\026\n\016" +
      "timeoutSeconds\030\007 \001(\005\022\037\n\027admissionReviewV" +
      "ersions\030\010 \003(\t\022\032\n\022reinvocationPolicy\030\n \001(" +
      "\t\022L\n\017matchConditions\030\014 \003(\01323.k8s.io.api." +
      "admissionregistration.v1.MatchCondition\"" +
      "\252\001\n\034MutatingWebhookConfiguration\022B\n\010meta" +
      "data\030\001 \001(\01320.k8s.io.apimachinery.pkg.api" +
      "s.meta.v1.ObjectMeta\022F\n\010Webhooks\030\002 \003(\01324" +
      ".k8s.io.api.admissionregistration.v1.Mut" +
      "atingWebhook\"\266\001\n MutatingWebhookConfigur" +
      "ationList\022@\n\010metadata\030\001 \001(\0132..k8s.io.api" +
      "machinery.pkg.apis.meta.v1.ListMeta\022P\n\005i" +
      "tems\030\002 \003(\0132A.k8s.io.api.admissionregistr" +
      "ation.v1.MutatingWebhookConfiguration\"\205\001" +
      "\n\027NamedRuleWithOperations\022\025\n\rresourceNam" +
      "es\030\001 \003(\t\022S\n\022ruleWithOperations\030\002 \001(\01327.k" +
      "8s.io.api.admissionregistration.v1.RuleW" +
      "ithOperations\"-\n\tParamKind\022\022\n\napiVersion" +
      "\030\001 \001(\t\022\014\n\004kind\030\002 \001(\t\"\223\001\n\010ParamRef\022\014\n\004nam" +
      "e\030\001 \001(\t\022\021\n\tnamespace\030\002 \001(\t\022E\n\010selector\030\003" +
      " \001(\01323.k8s.io.apimachinery.pkg.apis.meta" +
      ".v1.LabelSelector\022\037\n\027parameterNotFoundAc" +
      "tion\030\004 \001(\t\"P\n\004Rule\022\021\n\tapiGroups\030\001 \003(\t\022\023\n" +
      "\013apiVersions\030\002 \003(\t\022\021\n\tresources\030\003 \003(\t\022\r\n" +
      "\005scope\030\004 \001(\t\"a\n\022RuleWithOperations\022\022\n\nop" +
      "erations\030\001 \003(\t\0227\n\004rule\030\002 \001(\0132).k8s.io.ap" +
      "i.admissionregistration.v1.Rule\"O\n\020Servi" +
      "ceReference\022\021\n\tnamespace\030\001 \001(\t\022\014\n\004name\030\002" +
      " \001(\t\022\014\n\004path\030\003 \001(\t\022\014\n\004port\030\004 \001(\005\"b\n\014Type" +
      "Checking\022R\n\022expressionWarnings\030\001 \003(\01326.k" +
      "8s.io.api.admissionregistration.v1.Expre" +
      "ssionWarning\"\207\002\n\031ValidatingAdmissionPoli" +
      "cy\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachine" +
      "ry.pkg.apis.meta.v1.ObjectMeta\022P\n\004spec\030\002" +
      " \001(\0132B.k8s.io.api.admissionregistration." +
      "v1.ValidatingAdmissionPolicySpec\022T\n\006stat" +
      "us\030\003 \001(\0132D.k8s.io.api.admissionregistrat" +
      "ion.v1.ValidatingAdmissionPolicyStatus\"\277" +
      "\001\n ValidatingAdmissionPolicyBinding\022B\n\010m" +
      "etadata\030\001 \001(\01320.k8s.io.apimachinery.pkg." +
      "apis.meta.v1.ObjectMeta\022W\n\004spec\030\002 \001(\0132I." +
      "k8s.io.api.admissionregistration.v1.Vali" +
      "datingAdmissionPolicyBindingSpec\"\276\001\n$Val" +
      "idatingAdmissionPolicyBindingList\022@\n\010met" +
      "adata\030\001 \001(\0132..k8s.io.apimachinery.pkg.ap" +
      "is.meta.v1.ListMeta\022T\n\005items\030\002 \003(\0132E.k8s" +
      ".io.api.admissionregistration.v1.Validat" +
      "ingAdmissionPolicyBinding\"\343\001\n$Validating" +
      "AdmissionPolicyBindingSpec\022\022\n\npolicyName" +
      "\030\001 \001(\t\022?\n\010paramRef\030\002 \001(\0132-.k8s.io.api.ad" +
      "missionregistration.v1.ParamRef\022K\n\016match" +
      "Resources\030\003 \001(\01323.k8s.io.api.admissionre" +
      "gistration.v1.MatchResources\022\031\n\021validati" +
      "onActions\030\004 \003(\t\"\260\001\n\035ValidatingAdmissionP" +
      "olicyList\022@\n\010metadata\030\001 \001(\0132..k8s.io.api" +
      "machinery.pkg.apis.meta.v1.ListMeta\022M\n\005i" +
      "tems\030\002 \003(\0132>.k8s.io.api.admissionregistr" +
      "ation.v1.ValidatingAdmissionPolicy\"\356\003\n\035V" +
      "alidatingAdmissionPolicySpec\022A\n\tparamKin" +
      "d\030\001 \001(\0132..k8s.io.api.admissionregistrati" +
      "on.v1.ParamKind\022M\n\020matchConstraints\030\002 \001(" +
      "\01323.k8s.io.api.admissionregistration.v1." +
      "MatchResources\022D\n\013validations\030\003 \003(\0132/.k8" +
      "s.io.api.admissionregistration.v1.Valida" +
      "tion\022\025\n\rfailurePolicy\030\004 \001(\t\022N\n\020auditAnno" +
      "tations\030\005 \003(\01324.k8s.io.api.admissionregi" +
      "stration.v1.AuditAnnotation\022L\n\017matchCond" +
      "itions\030\006 \003(\01323.k8s.io.api.admissionregis" +
      "tration.v1.MatchCondition\022@\n\tvariables\030\007" +
      " \003(\0132-.k8s.io.api.admissionregistration." +
      "v1.Variable\"\313\001\n\037ValidatingAdmissionPolic" +
      "yStatus\022\032\n\022observedGeneration\030\001 \001(\003\022G\n\014t" +
      "ypeChecking\030\002 \001(\01321.k8s.io.api.admission" +
      "registration.v1.TypeChecking\022C\n\nconditio" +
      "ns\030\003 \003(\0132/.k8s.io.apimachinery.pkg.apis." +
      "meta.v1.Condition\"\236\004\n\021ValidatingWebhook\022" +
      "\014\n\004name\030\001 \001(\t\022N\n\014clientConfig\030\002 \001(\01328.k8" +
      "s.io.api.admissionregistration.v1.Webhoo" +
      "kClientConfig\022F\n\005rules\030\003 \003(\01327.k8s.io.ap" +
      "i.admissionregistration.v1.RuleWithOpera" +
      "tions\022\025\n\rfailurePolicy\030\004 \001(\t\022\023\n\013matchPol" +
      "icy\030\t \001(\t\022N\n\021namespaceSelector\030\005 \001(\01323.k" +
      "8s.io.apimachinery.pkg.apis.meta.v1.Labe" +
      "lSelector\022K\n\016objectSelector\030\n \001(\01323.k8s." +
      "io.apimachinery.pkg.apis.meta.v1.LabelSe" +
      "lector\022\023\n\013sideEffects\030\006 \001(\t\022\026\n\016timeoutSe" +
      "conds\030\007 \001(\005\022\037\n\027admissionReviewVersions\030\010" +
      " \003(\t\022L\n\017matchConditions\030\013 \003(\01323.k8s.io.a" +
      "pi.admissionregistration.v1.MatchConditi" +
      "on\"\256\001\n\036ValidatingWebhookConfiguration\022B\n" +
      "\010metadata\030\001 \001(\01320.k8s.io.apimachinery.pk" +
      "g.apis.meta.v1.ObjectMeta\022H\n\010Webhooks\030\002 " +
      "\003(\01326.k8s.io.api.admissionregistration.v" +
      "1.ValidatingWebhook\"\272\001\n\"ValidatingWebhoo" +
      "kConfigurationList\022@\n\010metadata\030\001 \001(\0132..k" +
      "8s.io.apimachinery.pkg.apis.meta.v1.List" +
      "Meta\022R\n\005items\030\002 \003(\0132C.k8s.io.api.admissi" +
      "onregistration.v1.ValidatingWebhookConfi" +
      "guration\"\\\n\nValidation\022\022\n\nExpression\030\001 \001" +
      "(\t\022\017\n\007message\030\002 \001(\t\022\016\n\006reason\030\003 \001(\t\022\031\n\021m" +
      "essageExpression\030\004 \001(\t\",\n\010Variable\022\014\n\004Na" +
      "me\030\001 \001(\t\022\022\n\nExpression\030\002 \001(\t\"|\n\023WebhookC" +
      "lientConfig\022\013\n\003url\030\003 \001(\t\022F\n\007service\030\001 \001(" +
      "\01325.k8s.io.api.admissionregistration.v1." +
      "ServiceReference\022\020\n\010caBundle\030\002 \001(\014BZ\n\032io" +
      ".kubernetes.client.protoB\027V1Admissionreg" +
      "istrationZ#k8s.io/api/admissionregistrat" +
      "ion/v1"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
        }, assigner);
    internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_AuditAnnotation_descriptor,
        new java.lang.String[] { "Key", "ValueExpression", });
    internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ExpressionWarning_descriptor,
        new java.lang.String[] { "FieldRef", "Warning", });
    internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_MatchCondition_descriptor,
        new java.lang.String[] { "Name", "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1_MatchResources_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_admissionregistration_v1_MatchResources_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_MatchResources_descriptor,
        new java.lang.String[] { "NamespaceSelector", "ObjectSelector", "ResourceRules", "ExcludeResourceRules", "MatchPolicy", });
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhook_descriptor,
        new java.lang.String[] { "Name", "ClientConfig", "Rules", "FailurePolicy", "MatchPolicy", "NamespaceSelector", "ObjectSelector", "SideEffects", "TimeoutSeconds", "AdmissionReviewVersions", "ReinvocationPolicy", "MatchConditions", });
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfiguration_descriptor,
        new java.lang.String[] { "Metadata", "Webhooks", });
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_MutatingWebhookConfigurationList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_NamedRuleWithOperations_descriptor,
        new java.lang.String[] { "ResourceNames", "RuleWithOperations", });
    internal_static_k8s_io_api_admissionregistration_v1_ParamKind_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_k8s_io_api_admissionregistration_v1_ParamKind_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ParamKind_descriptor,
        new java.lang.String[] { "ApiVersion", "Kind", });
    internal_static_k8s_io_api_admissionregistration_v1_ParamRef_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_k8s_io_api_admissionregistration_v1_ParamRef_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ParamRef_descriptor,
        new java.lang.String[] { "Name", "Namespace", "Selector", "ParameterNotFoundAction", });
    internal_static_k8s_io_api_admissionregistration_v1_Rule_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_k8s_io_api_admissionregistration_v1_Rule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_Rule_descriptor,
        new java.lang.String[] { "ApiGroups", "ApiVersions", "Resources", "Scope", });
    internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_RuleWithOperations_descriptor,
        new java.lang.String[] { "Operations", "Rule", });
    internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ServiceReference_descriptor,
        new java.lang.String[] { "Namespace", "Name", "Path", "Port", });
    internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_TypeChecking_descriptor,
        new java.lang.String[] { "ExpressionWarnings", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicy_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBinding_descriptor,
        new java.lang.String[] { "Metadata", "Spec", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyBindingSpec_descriptor,
        new java.lang.String[] { "PolicyName", "ParamRef", "MatchResources", "ValidationActions", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicySpec_descriptor,
        new java.lang.String[] { "ParamKind", "MatchConstraints", "Validations", "FailurePolicy", "AuditAnnotations", "MatchConditions", "Variables", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingAdmissionPolicyStatus_descriptor,
        new java.lang.String[] { "ObservedGeneration", "TypeChecking", "Conditions", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhook_descriptor,
        new java.lang.String[] { "Name", "ClientConfig", "Rules", "FailurePolicy", "MatchPolicy", "NamespaceSelector", "ObjectSelector", "SideEffects", "TimeoutSeconds", "AdmissionReviewVersions", "MatchConditions", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfiguration_descriptor,
        new java.lang.String[] { "Metadata", "Webhooks", });
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_ValidatingWebhookConfigurationList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_admissionregistration_v1_Validation_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_k8s_io_api_admissionregistration_v1_Validation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_Validation_descriptor,
        new java.lang.String[] { "Expression", "Message", "Reason", "MessageExpression", });
    internal_static_k8s_io_api_admissionregistration_v1_Variable_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_k8s_io_api_admissionregistration_v1_Variable_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_Variable_descriptor,
        new java.lang.String[] { "Name", "Expression", });
    internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_admissionregistration_v1_WebhookClientConfig_descriptor,
        new java.lang.String[] { "Url", "Service", "CaBundle", });
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
